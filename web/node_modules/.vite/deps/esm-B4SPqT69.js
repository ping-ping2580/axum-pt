import { __toESM } from "./chunk-51aI8Tpl.js";
import { require_react } from "./react-DN4s_Om_.js";

//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/clamp/clamp.mjs
function clamp(value, min, max) {
	if (min === void 0 && max === void 0) return value;
	if (min !== void 0 && max === void 0) return Math.max(value, min);
	if (min === void 0 && max !== void 0) return Math.min(value, max);
	return Math.min(Math.max(value, min), max);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/lower-first/lower-first.mjs
function lowerFirst(value) {
	return typeof value !== "string" ? "" : value.charAt(0).toLowerCase() + value.slice(1);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/random-id/random-id.mjs
function randomId(prefix = "mantine-") {
	return `${prefix}${Math.random().toString(36).slice(2, 11)}`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/range/range.mjs
function range$1(start, end) {
	const length = Math.abs(end - start) + 1;
	const reversed = start > end;
	if (!reversed) return Array.from({ length }, (_, index) => index + start);
	return Array.from({ length }, (_, index) => start - index);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/shallow-equal/shallow-equal.mjs
function shallowEqual(a, b) {
	if (a === b) return true;
	if (Number.isNaN(a) && Number.isNaN(b)) return true;
	if (!(a instanceof Object) || !(b instanceof Object)) return false;
	const keys = Object.keys(a);
	const { length } = keys;
	if (length !== Object.keys(b).length) return false;
	for (let i = 0; i < length; i += 1) {
		const key = keys[i];
		if (!(key in b)) return false;
		if (a[key] !== b[key] && !(Number.isNaN(a[key]) && Number.isNaN(b[key]))) return false;
	}
	return true;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/utils/upper-first/upper-first.mjs
function upperFirst(value) {
	return typeof value !== "string" ? "" : value.charAt(0).toUpperCase() + value.slice(1);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-callback-ref/use-callback-ref.mjs
var import_react = __toESM(require_react(), 1);
function useCallbackRef(callback) {
	const callbackRef = (0, import_react.useRef)(callback);
	(0, import_react.useEffect)(() => {
		callbackRef.current = callback;
	});
	return (0, import_react.useMemo)(() => (...args) => callbackRef.current?.(...args), []);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-debounced-callback/use-debounced-callback.mjs
function useDebouncedCallback(callback, options) {
	const delay = typeof options === "number" ? options : options.delay;
	const flushOnUnmount = typeof options === "number" ? false : options.flushOnUnmount;
	const leading = typeof options === "number" ? false : options.leading;
	const handleCallback = useCallbackRef(callback);
	const debounceTimerRef = (0, import_react.useRef)(0);
	const flushRef = (0, import_react.useRef)(() => {});
	const leadingRef = (0, import_react.useRef)(leading);
	const lastCallback = Object.assign((0, import_react.useCallback)((...args) => {
		window.clearTimeout(debounceTimerRef.current);
		if (leading && leadingRef.current) {
			leadingRef.current = false;
			handleCallback(...args);
			return;
		}
		const flush = () => {
			if (debounceTimerRef.current !== 0) {
				debounceTimerRef.current = 0;
				leadingRef.current = true;
				handleCallback(...args);
			}
		};
		flushRef.current = flush;
		lastCallback.flush = flush;
		debounceTimerRef.current = window.setTimeout(flush, delay);
		leadingRef.current = false;
	}, [
		handleCallback,
		delay,
		leading
	]), { flush: flushRef.current });
	(0, import_react.useEffect)(() => () => {
		window.clearTimeout(debounceTimerRef.current);
		if (flushOnUnmount) lastCallback.flush();
	}, [lastCallback, flushOnUnmount]);
	return lastCallback;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-click-outside/use-click-outside.mjs
const DEFAULT_EVENTS$1 = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
	const ref = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		const listener = (event) => {
			const { target } = event ?? {};
			if (Array.isArray(nodes)) {
				const shouldIgnore = target?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(target) && target.tagName !== "HTML";
				const shouldTrigger = nodes.every((node) => !!node && !event.composedPath().includes(node));
				shouldTrigger && !shouldIgnore && handler();
			} else if (ref.current && !ref.current.contains(target)) handler();
		};
		(events || DEFAULT_EVENTS$1).forEach((fn) => document.addEventListener(fn, listener));
		return () => {
			(events || DEFAULT_EVENTS$1).forEach((fn) => document.removeEventListener(fn, listener));
		};
	}, [
		ref,
		handler,
		nodes
	]);
	return ref;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-clipboard/use-clipboard.mjs
function useClipboard({ timeout = 2e3 } = {}) {
	const [error, setError] = (0, import_react.useState)(null);
	const [copied, setCopied] = (0, import_react.useState)(false);
	const [copyTimeout, setCopyTimeout] = (0, import_react.useState)(null);
	const handleCopyResult = (value) => {
		window.clearTimeout(copyTimeout);
		setCopyTimeout(window.setTimeout(() => setCopied(false), timeout));
		setCopied(value);
	};
	const copy = (valueToCopy) => {
		if ("clipboard" in navigator) navigator.clipboard.writeText(valueToCopy).then(() => handleCopyResult(true)).catch((err) => setError(err));
		else setError(new Error("useClipboard: navigator.clipboard is not supported"));
	};
	const reset = () => {
		setCopied(false);
		setError(null);
		window.clearTimeout(copyTimeout);
	};
	return {
		copy,
		reset,
		error,
		copied
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-media-query/use-media-query.mjs
function attachMediaListener(query, callback) {
	try {
		query.addEventListener("change", callback);
		return () => query.removeEventListener("change", callback);
	} catch (e) {
		query.addListener(callback);
		return () => query.removeListener(callback);
	}
}
function getInitialValue$1(query, initialValue) {
	if (typeof window !== "undefined" && "matchMedia" in window) return window.matchMedia(query).matches;
	return false;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = { getInitialValueInEffect: true }) {
	const [matches, setMatches] = (0, import_react.useState)(getInitialValueInEffect ? initialValue : getInitialValue$1(query));
	const queryRef = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		if ("matchMedia" in window) {
			queryRef.current = window.matchMedia(query);
			setMatches(queryRef.current.matches);
			return attachMediaListener(queryRef.current, (event) => setMatches(event.matches));
		}
		return void 0;
	}, [query]);
	return matches;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-color-scheme/use-color-scheme.mjs
function useColorScheme(initialValue, options) {
	return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-counter/use-counter.mjs
const DEFAULT_OPTIONS$1 = {
	min: -Infinity,
	max: Infinity
};
function useCounter(initialValue = 0, options) {
	const { min, max } = {
		...DEFAULT_OPTIONS$1,
		...options
	};
	const [count, setCount] = (0, import_react.useState)(clamp(initialValue, min, max));
	const increment = () => setCount((current) => clamp(current + 1, min, max));
	const decrement = () => setCount((current) => clamp(current - 1, min, max));
	const set = (value) => setCount(clamp(value, min, max));
	const reset = () => setCount(clamp(initialValue, min, max));
	return [count, {
		increment,
		decrement,
		set,
		reset
	}];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-debounced-state/use-debounced-state.mjs
function useDebouncedState(defaultValue, wait, options = { leading: false }) {
	const [value, setValue] = (0, import_react.useState)(defaultValue);
	const timeoutRef = (0, import_react.useRef)(null);
	const leadingRef = (0, import_react.useRef)(true);
	const clearTimeout$1 = () => window.clearTimeout(timeoutRef.current);
	(0, import_react.useEffect)(() => clearTimeout$1, []);
	const debouncedSetValue = (0, import_react.useCallback)((newValue) => {
		clearTimeout$1();
		if (leadingRef.current && options.leading) setValue(newValue);
		else timeoutRef.current = window.setTimeout(() => {
			leadingRef.current = true;
			setValue(newValue);
		}, wait);
		leadingRef.current = false;
	}, [options.leading]);
	return [value, debouncedSetValue];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-debounced-value/use-debounced-value.mjs
function useDebouncedValue(value, wait, options = { leading: false }) {
	const [_value, setValue] = (0, import_react.useState)(value);
	const mountedRef = (0, import_react.useRef)(false);
	const timeoutRef = (0, import_react.useRef)(null);
	const cooldownRef = (0, import_react.useRef)(false);
	const cancel = () => window.clearTimeout(timeoutRef.current);
	(0, import_react.useEffect)(() => {
		if (mountedRef.current) if (!cooldownRef.current && options.leading) {
			cooldownRef.current = true;
			setValue(value);
		} else {
			cancel();
			timeoutRef.current = window.setTimeout(() => {
				cooldownRef.current = false;
				setValue(value);
			}, wait);
		}
	}, [
		value,
		options.leading,
		wait
	]);
	(0, import_react.useEffect)(() => {
		mountedRef.current = true;
		return cancel;
	}, []);
	return [_value, cancel];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-isomorphic-effect/use-isomorphic-effect.mjs
const useIsomorphicEffect = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-document-title/use-document-title.mjs
function useDocumentTitle(title) {
	useIsomorphicEffect(() => {
		if (typeof title === "string" && title.trim().length > 0) document.title = title.trim();
	}, [title]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-document-visibility/use-document-visibility.mjs
function useDocumentVisibility() {
	const [documentVisibility, setDocumentVisibility] = (0, import_react.useState)("visible");
	(0, import_react.useEffect)(() => {
		const listener = () => setDocumentVisibility(document.visibilityState);
		document.addEventListener("visibilitychange", listener);
		return () => document.removeEventListener("visibilitychange", listener);
	}, []);
	return documentVisibility;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-did-update/use-did-update.mjs
function useDidUpdate(fn, dependencies) {
	const mounted = (0, import_react.useRef)(false);
	(0, import_react.useEffect)(() => () => {
		mounted.current = false;
	}, []);
	(0, import_react.useEffect)(() => {
		if (mounted.current) return fn();
		mounted.current = true;
		return void 0;
	}, dependencies);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-focus-return/use-focus-return.mjs
function useFocusReturn({ opened, shouldReturnFocus = true }) {
	const lastActiveElement = (0, import_react.useRef)(null);
	const returnFocus = () => {
		if (lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus === "function") lastActiveElement.current?.focus({ preventScroll: true });
	};
	useDidUpdate(() => {
		let timeout = -1;
		const clearFocusTimeout = (event) => {
			if (event.key === "Tab") window.clearTimeout(timeout);
		};
		document.addEventListener("keydown", clearFocusTimeout);
		if (opened) lastActiveElement.current = document.activeElement;
		else if (shouldReturnFocus) timeout = window.setTimeout(returnFocus, 10);
		return () => {
			window.clearTimeout(timeout);
			document.removeEventListener("keydown", clearFocusTimeout);
		};
	}, [opened, shouldReturnFocus]);
	return returnFocus;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-focus-trap/tabbable.mjs
const TABBABLE_NODES = /input|select|textarea|button|object/;
const FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
	return element.style.display === "none";
}
function visible(element) {
	const isHidden = element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden";
	if (isHidden) return false;
	let parentElement = element;
	while (parentElement) {
		if (parentElement === document.body || parentElement.nodeType === 11) break;
		if (hidden(parentElement)) return false;
		parentElement = parentElement.parentNode;
	}
	return true;
}
function getElementTabIndex(element) {
	let tabIndex = element.getAttribute("tabindex");
	if (tabIndex === null) tabIndex = void 0;
	return parseInt(tabIndex, 10);
}
function focusable(element) {
	const nodeName = element.nodeName.toLowerCase();
	const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
	const res = TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);
	return res && visible(element);
}
function tabbable(element) {
	const tabIndex = getElementTabIndex(element);
	const isTabIndexNaN = Number.isNaN(tabIndex);
	return (isTabIndexNaN || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
	return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-focus-trap/scope-tab.mjs
function scopeTab(node, event) {
	const tabbable$1 = findTabbableDescendants(node);
	if (!tabbable$1.length) {
		event.preventDefault();
		return;
	}
	const finalTabbable = tabbable$1[event.shiftKey ? 0 : tabbable$1.length - 1];
	const root = node.getRootNode();
	let leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;
	const activeElement = root.activeElement;
	const activeElementIsRadio = activeElement.tagName === "INPUT" && activeElement.getAttribute("type") === "radio";
	if (activeElementIsRadio) {
		const activeRadioGroup = tabbable$1.filter((element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement.getAttribute("name"));
		leavingFinalTabbable = activeRadioGroup.includes(finalTabbable);
	}
	if (!leavingFinalTabbable) return;
	event.preventDefault();
	const target = tabbable$1[event.shiftKey ? tabbable$1.length - 1 : 0];
	if (target) target.focus();
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-focus-trap/use-focus-trap.mjs
function useFocusTrap(active = true) {
	const ref = (0, import_react.useRef)(null);
	const focusNode = (node) => {
		let focusElement = node.querySelector("[data-autofocus]");
		if (!focusElement) {
			const children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
			focusElement = children.find(tabbable) || children.find(focusable) || null;
			if (!focusElement && focusable(node)) focusElement = node;
		}
		if (focusElement) focusElement.focus({ preventScroll: true });
		else console.warn("[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node", node);
	};
	const setRef = (0, import_react.useCallback)((node) => {
		if (!active) return;
		if (node === null) return;
		if (ref.current === node) return;
		if (node) {
			setTimeout(() => {
				if (node.getRootNode()) focusNode(node);
				else console.warn("[@mantine/hooks/use-focus-trap] Ref node is not part of the dom", node);
			});
			ref.current = node;
		} else ref.current = null;
	}, [active]);
	(0, import_react.useEffect)(() => {
		if (!active) return void 0;
		ref.current && setTimeout(() => focusNode(ref.current));
		const handleKeyDown = (event) => {
			if (event.key === "Tab" && ref.current) scopeTab(ref.current, event);
		};
		document.addEventListener("keydown", handleKeyDown);
		return () => document.removeEventListener("keydown", handleKeyDown);
	}, [active]);
	return setRef;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-force-update/use-force-update.mjs
const reducer = (value) => (value + 1) % 1e6;
function useForceUpdate() {
	const [, update] = (0, import_react.useReducer)(reducer, 0);
	return update;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-id/use-react-id.mjs
const __useId = import_react.default["useId".toString()] || (() => void 0);
function useReactId() {
	const id = __useId();
	return id ? `mantine-${id.replace(/:/g, "")}` : "";
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-id/use-id.mjs
function useId(staticId) {
	const reactId = useReactId();
	const [uuid, setUuid] = (0, import_react.useState)(reactId);
	useIsomorphicEffect(() => {
		setUuid(randomId());
	}, []);
	if (typeof staticId === "string") return staticId;
	if (typeof window === "undefined") return reactId;
	return uuid;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-idle/use-idle.mjs
const DEFAULT_EVENTS = [
	"keydown",
	"mousemove",
	"touchmove",
	"click",
	"scroll",
	"wheel"
];
const DEFAULT_OPTIONS = {
	events: DEFAULT_EVENTS,
	initialState: true
};
function useIdle(timeout, options) {
	const { events, initialState } = {
		...DEFAULT_OPTIONS,
		...options
	};
	const [idle, setIdle] = (0, import_react.useState)(initialState);
	const timer = (0, import_react.useRef)(-1);
	(0, import_react.useEffect)(() => {
		const handleEvents = () => {
			setIdle(false);
			if (timer.current) window.clearTimeout(timer.current);
			timer.current = window.setTimeout(() => {
				setIdle(true);
			}, timeout);
		};
		events.forEach((event) => document.addEventListener(event, handleEvents));
		timer.current = window.setTimeout(() => {
			setIdle(true);
		}, timeout);
		return () => {
			events.forEach((event) => document.removeEventListener(event, handleEvents));
		};
	}, [timeout]);
	return idle;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-interval/use-interval.mjs
function useInterval(fn, interval, { autoInvoke = false } = {}) {
	const [active, setActive] = (0, import_react.useState)(false);
	const intervalRef = (0, import_react.useRef)(null);
	const fnRef = (0, import_react.useRef)(null);
	const start = () => {
		setActive((old) => {
			if (!old && (!intervalRef.current || intervalRef.current === -1)) intervalRef.current = window.setInterval(fnRef.current, interval);
			return true;
		});
	};
	const stop = () => {
		setActive(false);
		window.clearInterval(intervalRef.current || -1);
		intervalRef.current = -1;
	};
	const toggle = () => {
		if (active) stop();
		else start();
	};
	(0, import_react.useEffect)(() => {
		fnRef.current = fn;
		active && start();
		return stop;
	}, [
		fn,
		active,
		interval
	]);
	(0, import_react.useEffect)(() => {
		if (autoInvoke) start();
	}, []);
	return {
		start,
		stop,
		toggle,
		active
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-list-state/use-list-state.mjs
function useListState(initialValue = []) {
	const [state, setState] = (0, import_react.useState)(initialValue);
	const append = (...items) => setState((current) => [...current, ...items]);
	const prepend = (...items) => setState((current) => [...items, ...current]);
	const insert = (index, ...items) => setState((current) => [
		...current.slice(0, index),
		...items,
		...current.slice(index)
	]);
	const apply = (fn) => setState((current) => current.map((item, index) => fn(item, index)));
	const remove = (...indices) => setState((current) => current.filter((_, index) => !indices.includes(index)));
	const pop = () => setState((current) => {
		const cloned = [...current];
		cloned.pop();
		return cloned;
	});
	const shift = () => setState((current) => {
		const cloned = [...current];
		cloned.shift();
		return cloned;
	});
	const reorder = ({ from, to }) => setState((current) => {
		const cloned = [...current];
		const item = current[from];
		cloned.splice(from, 1);
		cloned.splice(to, 0, item);
		return cloned;
	});
	const swap = ({ from, to }) => setState((current) => {
		const cloned = [...current];
		const fromItem = cloned[from];
		const toItem = cloned[to];
		cloned.splice(to, 1, fromItem);
		cloned.splice(from, 1, toItem);
		return cloned;
	});
	const setItem = (index, item) => setState((current) => {
		const cloned = [...current];
		cloned[index] = item;
		return cloned;
	});
	const setItemProp = (index, prop, value) => setState((current) => {
		const cloned = [...current];
		cloned[index] = {
			...cloned[index],
			[prop]: value
		};
		return cloned;
	});
	const applyWhere = (condition, fn) => setState((current) => current.map((item, index) => condition(item, index) ? fn(item, index) : item));
	const filter = (fn) => {
		setState((current) => current.filter(fn));
	};
	return [state, {
		setState,
		append,
		prepend,
		insert,
		pop,
		shift,
		apply,
		applyWhere,
		remove,
		reorder,
		swap,
		setItem,
		setItemProp,
		filter
	}];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-window-event/use-window-event.mjs
function useWindowEvent(type, listener, options) {
	(0, import_react.useEffect)(() => {
		window.addEventListener(type, listener, options);
		return () => window.removeEventListener(type, listener, options);
	}, [type, listener]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-local-storage/create-storage.mjs
function serializeJSON(value, hookName = "use-local-storage") {
	try {
		return JSON.stringify(value);
	} catch (error) {
		throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
	}
}
function deserializeJSON(value) {
	try {
		return value && JSON.parse(value);
	} catch {
		return value;
	}
}
function createStorageHandler(type) {
	const getItem = (key) => {
		try {
			return window[type].getItem(key);
		} catch (error) {
			console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked");
			return null;
		}
	};
	const setItem = (key, value) => {
		try {
			window[type].setItem(key, value);
		} catch (error) {
			console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
		}
	};
	const removeItem = (key) => {
		try {
			window[type].removeItem(key);
		} catch (error) {
			console.warn("use-local-storage: Failed to remove value from storage, localStorage is blocked");
		}
	};
	return {
		getItem,
		setItem,
		removeItem
	};
}
function createStorage(type, hookName) {
	const eventName = type === "localStorage" ? "mantine-local-storage" : "mantine-session-storage";
	const { getItem, setItem, removeItem } = createStorageHandler(type);
	return function useStorage({ key, defaultValue, getInitialValueInEffect = true, sync = true, deserialize = deserializeJSON, serialize = (value$1) => serializeJSON(value$1, hookName) }) {
		const readStorageValue = (0, import_react.useCallback)((skipStorage) => {
			let storageBlockedOrSkipped;
			try {
				storageBlockedOrSkipped = typeof window === "undefined" || !(type in window) || window[type] === null || !!skipStorage;
			} catch (_e) {
				storageBlockedOrSkipped = true;
			}
			if (storageBlockedOrSkipped) return defaultValue;
			const storageValue = getItem(key);
			return storageValue !== null ? deserialize(storageValue) : defaultValue;
		}, [key, defaultValue]);
		const [value, setValue] = (0, import_react.useState)(readStorageValue(getInitialValueInEffect));
		const setStorageValue = (0, import_react.useCallback)((val) => {
			if (val instanceof Function) setValue((current) => {
				const result = val(current);
				setItem(key, serialize(result));
				queueMicrotask(() => {
					window.dispatchEvent(new CustomEvent(eventName, { detail: {
						key,
						value: val(current)
					} }));
				});
				return result;
			});
			else {
				setItem(key, serialize(val));
				window.dispatchEvent(new CustomEvent(eventName, { detail: {
					key,
					value: val
				} }));
				setValue(val);
			}
		}, [key]);
		const removeStorageValue = (0, import_react.useCallback)(() => {
			removeItem(key);
			window.dispatchEvent(new CustomEvent(eventName, { detail: {
				key,
				value: defaultValue
			} }));
		}, []);
		useWindowEvent("storage", (event) => {
			if (sync) {
				if (event.storageArea === window[type] && event.key === key) setValue(deserialize(event.newValue ?? void 0));
			}
		});
		useWindowEvent(eventName, (event) => {
			if (sync) {
				if (event.detail.key === key) setValue(event.detail.value);
			}
		});
		(0, import_react.useEffect)(() => {
			if (defaultValue !== void 0 && value === void 0) setStorageValue(defaultValue);
		}, [
			defaultValue,
			value,
			setStorageValue
		]);
		(0, import_react.useEffect)(() => {
			const val = readStorageValue();
			val !== void 0 && setStorageValue(val);
		}, [key]);
		return [
			value === void 0 ? defaultValue : value,
			setStorageValue,
			removeStorageValue
		];
	};
}
function readValue(type) {
	const { getItem } = createStorageHandler(type);
	return function read({ key, defaultValue, deserialize = deserializeJSON }) {
		let storageBlockedOrSkipped;
		try {
			storageBlockedOrSkipped = typeof window === "undefined" || !(type in window) || window[type] === null;
		} catch (_e) {
			storageBlockedOrSkipped = true;
		}
		if (storageBlockedOrSkipped) return defaultValue;
		const storageValue = getItem(key);
		return storageValue !== null ? deserialize(storageValue) : defaultValue;
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-local-storage/use-local-storage.mjs
function useLocalStorage(props) {
	return createStorage("localStorage", "use-local-storage")(props);
}
const readLocalStorageValue = readValue("localStorage");

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-session-storage/use-session-storage.mjs
function useSessionStorage(props) {
	return createStorage("sessionStorage", "use-session-storage")(props);
}
const readSessionStorageValue = readValue("sessionStorage");

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-merged-ref/use-merged-ref.mjs
function assignRef(ref, value) {
	if (typeof ref === "function") return ref(value);
	else if (typeof ref === "object" && ref !== null && "current" in ref) ref.current = value;
}
function mergeRefs(...refs) {
	const cleanupMap = /* @__PURE__ */ new Map();
	return (node) => {
		refs.forEach((ref) => {
			const cleanup = assignRef(ref, node);
			if (cleanup) cleanupMap.set(ref, cleanup);
		});
		if (cleanupMap.size > 0) return () => {
			refs.forEach((ref) => {
				const cleanup = cleanupMap.get(ref);
				if (cleanup) cleanup();
				else assignRef(ref, null);
			});
			cleanupMap.clear();
		};
	};
}
function useMergedRef(...refs) {
	return (0, import_react.useCallback)(mergeRefs(...refs), refs);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-mouse/use-mouse.mjs
function useMouse(options = { resetOnExit: false }) {
	const [position, setPosition] = (0, import_react.useState)({
		x: 0,
		y: 0
	});
	const ref = (0, import_react.useRef)(null);
	const setMousePosition = (event) => {
		if (ref.current) {
			const rect = event.currentTarget.getBoundingClientRect();
			const x = Math.max(0, Math.round(event.pageX - rect.left - (window.pageXOffset || window.scrollX)));
			const y = Math.max(0, Math.round(event.pageY - rect.top - (window.pageYOffset || window.scrollY)));
			setPosition({
				x,
				y
			});
		} else setPosition({
			x: event.clientX,
			y: event.clientY
		});
	};
	const resetMousePosition = () => setPosition({
		x: 0,
		y: 0
	});
	(0, import_react.useEffect)(() => {
		const element = ref?.current ? ref.current : document;
		element.addEventListener("mousemove", setMousePosition);
		if (options.resetOnExit) element.addEventListener("mouseleave", resetMousePosition);
		return () => {
			element.removeEventListener("mousemove", setMousePosition);
			if (options.resetOnExit) element.removeEventListener("mouseleave", resetMousePosition);
		};
	}, [ref.current]);
	return {
		ref,
		...position
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-move/use-move.mjs
function clampUseMovePosition(position) {
	return {
		x: clamp(position.x, 0, 1),
		y: clamp(position.y, 0, 1)
	};
}
function useMove(onChange, handlers, dir = "ltr") {
	const ref = (0, import_react.useRef)(null);
	const mounted = (0, import_react.useRef)(false);
	const isSliding = (0, import_react.useRef)(false);
	const frame = (0, import_react.useRef)(0);
	const [active, setActive] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		mounted.current = true;
	}, []);
	(0, import_react.useEffect)(() => {
		const node = ref.current;
		const onScrub = ({ x, y }) => {
			cancelAnimationFrame(frame.current);
			frame.current = requestAnimationFrame(() => {
				if (mounted.current && node) {
					node.style.userSelect = "none";
					const rect = node.getBoundingClientRect();
					if (rect.width && rect.height) {
						const _x = clamp((x - rect.left) / rect.width, 0, 1);
						onChange({
							x: dir === "ltr" ? _x : 1 - _x,
							y: clamp((y - rect.top) / rect.height, 0, 1)
						});
					}
				}
			});
		};
		const bindEvents = () => {
			document.addEventListener("mousemove", onMouseMove);
			document.addEventListener("mouseup", stopScrubbing);
			document.addEventListener("touchmove", onTouchMove);
			document.addEventListener("touchend", stopScrubbing);
		};
		const unbindEvents = () => {
			document.removeEventListener("mousemove", onMouseMove);
			document.removeEventListener("mouseup", stopScrubbing);
			document.removeEventListener("touchmove", onTouchMove);
			document.removeEventListener("touchend", stopScrubbing);
		};
		const startScrubbing = () => {
			if (!isSliding.current && mounted.current) {
				isSliding.current = true;
				typeof handlers?.onScrubStart === "function" && handlers.onScrubStart();
				setActive(true);
				bindEvents();
			}
		};
		const stopScrubbing = () => {
			if (isSliding.current && mounted.current) {
				isSliding.current = false;
				setActive(false);
				unbindEvents();
				setTimeout(() => {
					typeof handlers?.onScrubEnd === "function" && handlers.onScrubEnd();
				}, 0);
			}
		};
		const onMouseDown = (event) => {
			startScrubbing();
			event.preventDefault();
			onMouseMove(event);
		};
		const onMouseMove = (event) => onScrub({
			x: event.clientX,
			y: event.clientY
		});
		const onTouchStart = (event) => {
			if (event.cancelable) event.preventDefault();
			startScrubbing();
			onTouchMove(event);
		};
		const onTouchMove = (event) => {
			if (event.cancelable) event.preventDefault();
			onScrub({
				x: event.changedTouches[0].clientX,
				y: event.changedTouches[0].clientY
			});
		};
		node?.addEventListener("mousedown", onMouseDown);
		node?.addEventListener("touchstart", onTouchStart, { passive: false });
		return () => {
			if (node) {
				node.removeEventListener("mousedown", onMouseDown);
				node.removeEventListener("touchstart", onTouchStart);
			}
		};
	}, [dir, onChange]);
	return {
		ref,
		active
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-uncontrolled/use-uncontrolled.mjs
function useUncontrolled({ value, defaultValue, finalValue, onChange = () => {} }) {
	const [uncontrolledValue, setUncontrolledValue] = (0, import_react.useState)(defaultValue !== void 0 ? defaultValue : finalValue);
	const handleUncontrolledChange = (val, ...payload) => {
		setUncontrolledValue(val);
		onChange?.(val, ...payload);
	};
	if (value !== void 0) return [
		value,
		onChange,
		true
	];
	return [
		uncontrolledValue,
		handleUncontrolledChange,
		false
	];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-pagination/use-pagination.mjs
function range(start, end) {
	const length = end - start + 1;
	return Array.from({ length }, (_, index) => index + start);
}
const DOTS = "dots";
function usePagination({ total, siblings = 1, boundaries = 1, page, initialPage = 1, onChange }) {
	const _total = Math.max(Math.trunc(total), 0);
	const [activePage, setActivePage] = useUncontrolled({
		value: page,
		onChange,
		defaultValue: initialPage,
		finalValue: initialPage
	});
	const setPage = (pageNumber) => {
		if (pageNumber <= 0) setActivePage(1);
		else if (pageNumber > _total) setActivePage(_total);
		else setActivePage(pageNumber);
	};
	const next = () => setPage(activePage + 1);
	const previous = () => setPage(activePage - 1);
	const first = () => setPage(1);
	const last = () => setPage(_total);
	const paginationRange = (0, import_react.useMemo)(() => {
		const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;
		if (totalPageNumbers >= _total) return range(1, _total);
		const leftSiblingIndex = Math.max(activePage - siblings, boundaries);
		const rightSiblingIndex = Math.min(activePage + siblings, _total - boundaries);
		const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;
		const shouldShowRightDots = rightSiblingIndex < _total - (boundaries + 1);
		if (!shouldShowLeftDots && shouldShowRightDots) {
			const leftItemCount = siblings * 2 + boundaries + 2;
			return [
				...range(1, leftItemCount),
				DOTS,
				...range(_total - (boundaries - 1), _total)
			];
		}
		if (shouldShowLeftDots && !shouldShowRightDots) {
			const rightItemCount = boundaries + 1 + 2 * siblings;
			return [
				...range(1, boundaries),
				DOTS,
				...range(_total - rightItemCount, _total)
			];
		}
		return [
			...range(1, boundaries),
			DOTS,
			...range(leftSiblingIndex, rightSiblingIndex),
			DOTS,
			...range(_total - boundaries + 1, _total)
		];
	}, [
		_total,
		siblings,
		activePage
	]);
	return {
		range: paginationRange,
		active: activePage,
		setPage,
		next,
		previous,
		first,
		last
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-queue/use-queue.mjs
function useQueue({ initialValues = [], limit }) {
	const [state, setState] = (0, import_react.useState)({
		state: initialValues.slice(0, limit),
		queue: initialValues.slice(limit)
	});
	const add = (...items) => setState((current) => {
		const results = [
			...current.state,
			...current.queue,
			...items
		];
		return {
			state: results.slice(0, limit),
			queue: results.slice(limit)
		};
	});
	const update = (fn) => setState((current) => {
		const results = fn([...current.state, ...current.queue]);
		return {
			state: results.slice(0, limit),
			queue: results.slice(limit)
		};
	});
	const cleanQueue = () => setState((current) => ({
		state: current.state,
		queue: []
	}));
	return {
		state: state.state,
		queue: state.queue,
		add,
		update,
		cleanQueue
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-page-leave/use-page-leave.mjs
function usePageLeave(onPageLeave) {
	(0, import_react.useEffect)(() => {
		document.documentElement.addEventListener("mouseleave", onPageLeave);
		return () => document.documentElement.removeEventListener("mouseleave", onPageLeave);
	}, []);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-reduced-motion/use-reduced-motion.mjs
function useReducedMotion(initialValue, options) {
	return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-into-view/utils/ease-in-out-quad.mjs
const easeInOutQuad = (t) => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-into-view/utils/get-relative-position.mjs
const getRelativePosition = ({ axis, target, parent, alignment, offset, isList }) => {
	if (!target || !parent && typeof document === "undefined") return 0;
	const isCustomParent = !!parent;
	const parentElement = parent || document.body;
	const parentPosition = parentElement.getBoundingClientRect();
	const targetPosition = target.getBoundingClientRect();
	const getDiff = (property) => targetPosition[property] - parentPosition[property];
	if (axis === "y") {
		const diff = getDiff("top");
		if (diff === 0) return 0;
		if (alignment === "start") {
			const distance = diff - offset;
			const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;
			return shouldScroll ? distance : 0;
		}
		const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;
		if (alignment === "end") {
			const distance = diff + offset - parentHeight + targetPosition.height;
			const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;
			return shouldScroll ? distance : 0;
		}
		if (alignment === "center") return diff - parentHeight / 2 + targetPosition.height / 2;
		return 0;
	}
	if (axis === "x") {
		const diff = getDiff("left");
		if (diff === 0) return 0;
		if (alignment === "start") {
			const distance = diff - offset;
			const shouldScroll = distance <= targetPosition.width || !isList;
			return shouldScroll ? distance : 0;
		}
		const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;
		if (alignment === "end") {
			const distance = diff + offset - parentWidth + targetPosition.width;
			const shouldScroll = distance >= -targetPosition.width || !isList;
			return shouldScroll ? distance : 0;
		}
		if (alignment === "center") return diff - parentWidth / 2 + targetPosition.width / 2;
		return 0;
	}
	return 0;
};

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-into-view/utils/get-scroll-start.mjs
const getScrollStart = ({ axis, parent }) => {
	if (!parent && typeof document === "undefined") return 0;
	const method = axis === "y" ? "scrollTop" : "scrollLeft";
	if (parent) return parent[method];
	const { body, documentElement } = document;
	return body[method] + documentElement[method];
};

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-into-view/utils/set-scroll-param.mjs
const setScrollParam = ({ axis, parent, distance }) => {
	if (!parent && typeof document === "undefined") return;
	const method = axis === "y" ? "scrollTop" : "scrollLeft";
	if (parent) parent[method] = distance;
	else {
		const { body, documentElement } = document;
		body[method] = distance;
		documentElement[method] = distance;
	}
};

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-into-view/use-scroll-into-view.mjs
function useScrollIntoView({ duration = 1250, axis = "y", onScrollFinish, easing = easeInOutQuad, offset = 0, cancelable = true, isList = false } = {}) {
	const frameID = (0, import_react.useRef)(0);
	const startTime = (0, import_react.useRef)(0);
	const shouldStop = (0, import_react.useRef)(false);
	const scrollableRef = (0, import_react.useRef)(null);
	const targetRef = (0, import_react.useRef)(null);
	const reducedMotion = useReducedMotion();
	const cancel = () => {
		if (frameID.current) cancelAnimationFrame(frameID.current);
	};
	const scrollIntoView = (0, import_react.useCallback)(({ alignment = "start" } = {}) => {
		shouldStop.current = false;
		if (frameID.current) cancel();
		const start = getScrollStart({
			parent: scrollableRef.current,
			axis
		}) ?? 0;
		const change = getRelativePosition({
			parent: scrollableRef.current,
			target: targetRef.current,
			axis,
			alignment,
			offset,
			isList
		}) - (scrollableRef.current ? 0 : start);
		function animateScroll() {
			if (startTime.current === 0) startTime.current = performance.now();
			const now = performance.now();
			const elapsed = now - startTime.current;
			const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;
			const distance = start + change * easing(t);
			setScrollParam({
				parent: scrollableRef.current,
				axis,
				distance
			});
			if (!shouldStop.current && t < 1) frameID.current = requestAnimationFrame(animateScroll);
			else {
				typeof onScrollFinish === "function" && onScrollFinish();
				startTime.current = 0;
				frameID.current = 0;
				cancel();
			}
		}
		animateScroll();
	}, [
		axis,
		duration,
		easing,
		isList,
		offset,
		onScrollFinish,
		reducedMotion
	]);
	const handleStop = () => {
		if (cancelable) shouldStop.current = true;
	};
	useWindowEvent("wheel", handleStop, { passive: true });
	useWindowEvent("touchmove", handleStop, { passive: true });
	(0, import_react.useEffect)(() => cancel, []);
	return {
		scrollableRef,
		targetRef,
		scrollIntoView,
		cancel
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-resize-observer/use-resize-observer.mjs
const defaultState = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	top: 0,
	left: 0,
	bottom: 0,
	right: 0
};
function useResizeObserver(options) {
	const frameID = (0, import_react.useRef)(0);
	const ref = (0, import_react.useRef)(null);
	const [rect, setRect] = (0, import_react.useState)(defaultState);
	const observer = (0, import_react.useMemo)(() => typeof window !== "undefined" ? new ResizeObserver((entries) => {
		const entry = entries[0];
		if (entry) {
			cancelAnimationFrame(frameID.current);
			frameID.current = requestAnimationFrame(() => {
				if (ref.current) {
					const boxSize = entry.borderBoxSize?.[0] || entry.contentBoxSize?.[0];
					if (boxSize) {
						const width = boxSize.inlineSize;
						const height = boxSize.blockSize;
						setRect({
							width,
							height,
							x: entry.contentRect.x,
							y: entry.contentRect.y,
							top: entry.contentRect.top,
							left: entry.contentRect.left,
							bottom: entry.contentRect.bottom,
							right: entry.contentRect.right
						});
					} else setRect(entry.contentRect);
				}
			});
		}
	}) : null, []);
	(0, import_react.useEffect)(() => {
		if (ref.current) observer?.observe(ref.current, options);
		return () => {
			observer?.disconnect();
			if (frameID.current) cancelAnimationFrame(frameID.current);
		};
	}, [ref.current]);
	return [ref, rect];
}
function useElementSize(options) {
	const [ref, { width, height }] = useResizeObserver(options);
	return {
		ref,
		width,
		height
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-shallow-effect/use-shallow-effect.mjs
function shallowCompare(prevValue, currValue) {
	if (!prevValue || !currValue) return false;
	if (prevValue === currValue) return true;
	if (prevValue.length !== currValue.length) return false;
	for (let i = 0; i < prevValue.length; i += 1) if (!shallowEqual(prevValue[i], currValue[i])) return false;
	return true;
}
function useShallowCompare(dependencies) {
	const ref = (0, import_react.useRef)([]);
	const updateRef = (0, import_react.useRef)(0);
	if (!shallowCompare(ref.current, dependencies)) {
		ref.current = dependencies;
		updateRef.current += 1;
	}
	return [updateRef.current];
}
function useShallowEffect(cb, dependencies) {
	(0, import_react.useEffect)(cb, useShallowCompare(dependencies));
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-toggle/use-toggle.mjs
function useToggle(options = [false, true]) {
	const [[option], toggle] = (0, import_react.useReducer)((state, action) => {
		const value = action instanceof Function ? action(state[0]) : action;
		const index = Math.abs(state.indexOf(value));
		return state.slice(index).concat(state.slice(0, index));
	}, options);
	return [option, toggle];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-viewport-size/use-viewport-size.mjs
const eventListerOptions = { passive: true };
function useViewportSize() {
	const [windowSize, setWindowSize] = (0, import_react.useState)({
		width: 0,
		height: 0
	});
	const setSize = (0, import_react.useCallback)(() => {
		setWindowSize({
			width: window.innerWidth || 0,
			height: window.innerHeight || 0
		});
	}, []);
	useWindowEvent("resize", setSize, eventListerOptions);
	useWindowEvent("orientationchange", setSize, eventListerOptions);
	(0, import_react.useEffect)(setSize, []);
	return windowSize;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-window-scroll/use-window-scroll.mjs
function getScrollPosition() {
	return typeof window !== "undefined" ? {
		x: window.pageXOffset,
		y: window.pageYOffset
	} : {
		x: 0,
		y: 0
	};
}
function scrollTo({ x, y }) {
	if (typeof window !== "undefined") {
		const scrollOptions = { behavior: "smooth" };
		if (typeof x === "number") scrollOptions.left = x;
		if (typeof y === "number") scrollOptions.top = y;
		window.scrollTo(scrollOptions);
	}
}
function useWindowScroll() {
	const [position, setPosition] = (0, import_react.useState)({
		x: 0,
		y: 0
	});
	useWindowEvent("scroll", () => setPosition(getScrollPosition()));
	useWindowEvent("resize", () => setPosition(getScrollPosition()));
	(0, import_react.useEffect)(() => {
		setPosition(getScrollPosition());
	}, []);
	return [position, scrollTo];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-intersection/use-intersection.mjs
function useIntersection(options) {
	const [entry, setEntry] = (0, import_react.useState)(null);
	const observer = (0, import_react.useRef)(null);
	const ref = (0, import_react.useCallback)((element) => {
		if (observer.current) {
			observer.current.disconnect();
			observer.current = null;
		}
		if (element === null) {
			setEntry(null);
			return;
		}
		observer.current = new IntersectionObserver(([_entry]) => {
			setEntry(_entry);
		}, options);
		observer.current.observe(element);
	}, [
		options?.rootMargin,
		options?.root,
		options?.threshold
	]);
	return {
		ref,
		entry
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-hash/use-hash.mjs
function useHash({ getInitialValueInEffect = true } = {}) {
	const [hash, setHash] = (0, import_react.useState)(getInitialValueInEffect ? "" : window.location.hash || "");
	const setHashHandler = (value) => {
		const valueWithHash = value.startsWith("#") ? value : `#${value}`;
		window.location.hash = valueWithHash;
		setHash(valueWithHash);
	};
	useWindowEvent("hashchange", () => {
		const newHash = window.location.hash;
		if (hash !== newHash) setHash(newHash);
	});
	(0, import_react.useEffect)(() => {
		if (getInitialValueInEffect) setHash(window.location.hash);
	}, []);
	return [hash, setHashHandler];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-hotkeys/parse-hotkey.mjs
const keyNameMap = {
	" ": "space",
	ArrowLeft: "arrowleft",
	ArrowRight: "arrowright",
	ArrowUp: "arrowup",
	ArrowDown: "arrowdown",
	Escape: "esc",
	Esc: "esc",
	Enter: "enter",
	Tab: "tab",
	Backspace: "backspace",
	Delete: "delete",
	Insert: "insert",
	Home: "home",
	End: "end",
	PageUp: "pageup",
	PageDown: "pagedown",
	"+": "plus",
	"-": "minus",
	"*": "asterisk",
	"/": "slash"
};
function normalizeKey(key) {
	const lowerKey = key.replace("Key", "").toLowerCase();
	return keyNameMap[key] || lowerKey;
}
function parseHotkey(hotkey) {
	const keys = hotkey.toLowerCase().split("+").map((part) => part.trim());
	const modifiers = {
		alt: keys.includes("alt"),
		ctrl: keys.includes("ctrl"),
		meta: keys.includes("meta"),
		mod: keys.includes("mod"),
		shift: keys.includes("shift"),
		plus: keys.includes("[plus]")
	};
	const reservedKeys = [
		"alt",
		"ctrl",
		"meta",
		"shift",
		"mod"
	];
	const freeKey = keys.find((key) => !reservedKeys.includes(key));
	return {
		...modifiers,
		key: freeKey === "[plus]" ? "+" : freeKey
	};
}
function isExactHotkey(hotkey, event, usePhysicalKeys) {
	const { alt, ctrl, meta, mod, shift, key } = hotkey;
	const { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey, code: pressedCode } = event;
	if (alt !== altKey) return false;
	if (mod) {
		if (!ctrlKey && !metaKey) return false;
	} else {
		if (ctrl !== ctrlKey) return false;
		if (meta !== metaKey) return false;
	}
	if (shift !== shiftKey) return false;
	if (key && (usePhysicalKeys ? normalizeKey(pressedCode) === normalizeKey(key) : normalizeKey(pressedKey ?? pressedCode) === normalizeKey(key))) return true;
	return false;
}
function getHotkeyMatcher(hotkey, usePhysicalKeys) {
	return (event) => isExactHotkey(parseHotkey(hotkey), event, usePhysicalKeys);
}
function getHotkeyHandler(hotkeys) {
	return (event) => {
		const _event = "nativeEvent" in event ? event.nativeEvent : event;
		hotkeys.forEach(([hotkey, handler, options = {
			preventDefault: true,
			usePhysicalKeys: false
		}]) => {
			if (getHotkeyMatcher(hotkey, options.usePhysicalKeys)(_event)) {
				if (options.preventDefault) event.preventDefault();
				handler(_event);
			}
		});
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-hotkeys/use-hotkeys.mjs
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = false) {
	if (event.target instanceof HTMLElement) {
		if (triggerOnContentEditable) return !tagsToIgnore.includes(event.target.tagName);
		return !event.target.isContentEditable && !tagsToIgnore.includes(event.target.tagName);
	}
	return true;
}
function useHotkeys(hotkeys, tagsToIgnore = [
	"INPUT",
	"TEXTAREA",
	"SELECT"
], triggerOnContentEditable = false) {
	(0, import_react.useEffect)(() => {
		const keydownListener = (event) => {
			hotkeys.forEach(([hotkey, handler, options = {
				preventDefault: true,
				usePhysicalKeys: false
			}]) => {
				if (getHotkeyMatcher(hotkey, options.usePhysicalKeys)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable)) {
					if (options.preventDefault) event.preventDefault();
					handler(event);
				}
			});
		};
		document.documentElement.addEventListener("keydown", keydownListener);
		return () => document.documentElement.removeEventListener("keydown", keydownListener);
	}, [hotkeys]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-fullscreen/use-fullscreen.mjs
function getFullscreenElement() {
	const _document = window.document;
	const fullscreenElement = _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement;
	return fullscreenElement;
}
function exitFullscreen() {
	const _document = window.document;
	if (typeof _document.exitFullscreen === "function") return _document.exitFullscreen();
	if (typeof _document.msExitFullscreen === "function") return _document.msExitFullscreen();
	if (typeof _document.webkitExitFullscreen === "function") return _document.webkitExitFullscreen();
	if (typeof _document.mozCancelFullScreen === "function") return _document.mozCancelFullScreen();
	return null;
}
function enterFullScreen(element) {
	const _element = element;
	return _element.requestFullscreen?.() || _element.msRequestFullscreen?.() || _element.webkitEnterFullscreen?.() || _element.webkitRequestFullscreen?.() || _element.mozRequestFullscreen?.();
}
const prefixes = [
	"",
	"webkit",
	"moz",
	"ms"
];
function addEvents(element, { onFullScreen, onError }) {
	prefixes.forEach((prefix) => {
		element.addEventListener(`${prefix}fullscreenchange`, onFullScreen);
		element.addEventListener(`${prefix}fullscreenerror`, onError);
	});
	return () => {
		prefixes.forEach((prefix) => {
			element.removeEventListener(`${prefix}fullscreenchange`, onFullScreen);
			element.removeEventListener(`${prefix}fullscreenerror`, onError);
		});
	};
}
function useFullscreen() {
	const [fullscreen, setFullscreen] = (0, import_react.useState)(false);
	const _ref = (0, import_react.useRef)(null);
	const handleFullscreenChange = (0, import_react.useCallback)((event) => {
		setFullscreen(event.target === getFullscreenElement());
	}, [setFullscreen]);
	const handleFullscreenError = (0, import_react.useCallback)((event) => {
		setFullscreen(false);
		console.error(`[@mantine/hooks] use-fullscreen: Error attempting full-screen mode method: ${event} (${event.target})`);
	}, [setFullscreen]);
	const toggle = (0, import_react.useCallback)(async () => {
		if (!getFullscreenElement()) await enterFullScreen(_ref.current);
		else await exitFullscreen();
	}, []);
	const ref = (0, import_react.useCallback)((element) => {
		if (element === null) _ref.current = window.document.documentElement;
		else _ref.current = element;
	}, []);
	(0, import_react.useEffect)(() => {
		if (!_ref.current && window.document) {
			_ref.current = window.document.documentElement;
			return addEvents(_ref.current, {
				onFullScreen: handleFullscreenChange,
				onError: handleFullscreenError
			});
		}
		if (_ref.current) return addEvents(_ref.current, {
			onFullScreen: handleFullscreenChange,
			onError: handleFullscreenError
		});
		return void 0;
	}, [_ref.current]);
	return {
		ref,
		toggle,
		fullscreen
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-logger/use-logger.mjs
function useLogger(componentName, props) {
	(0, import_react.useEffect)(() => {
		console.log(`${componentName} mounted`, ...props);
		return () => console.log(`${componentName} unmounted`);
	}, []);
	useDidUpdate(() => {
		console.log(`${componentName} updated`, ...props);
	}, props);
	return null;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-hover/use-hover.mjs
function useHover() {
	const [hovered, setHovered] = (0, import_react.useState)(false);
	const ref = (0, import_react.useRef)(null);
	const onMouseEnter = (0, import_react.useCallback)(() => setHovered(true), []);
	const onMouseLeave = (0, import_react.useCallback)(() => setHovered(false), []);
	(0, import_react.useEffect)(() => {
		const node = ref.current;
		if (node) {
			node.addEventListener("mouseenter", onMouseEnter);
			node.addEventListener("mouseleave", onMouseLeave);
			return () => {
				node?.removeEventListener("mouseenter", onMouseEnter);
				node?.removeEventListener("mouseleave", onMouseLeave);
			};
		}
		return void 0;
	}, [ref.current]);
	return {
		ref,
		hovered
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-validated-state/use-validated-state.mjs
function useValidatedState(initialValue, validation, initialValidationState) {
	const [value, setValue] = (0, import_react.useState)(initialValue);
	const [lastValidValue, setLastValidValue] = (0, import_react.useState)(validation(initialValue) ? initialValue : void 0);
	const [valid, setValid] = (0, import_react.useState)(typeof initialValidationState === "boolean" ? initialValidationState : validation(initialValue));
	const onChange = (val) => {
		if (validation(val)) {
			setLastValidValue(val);
			setValid(true);
		} else setValid(false);
		setValue(val);
	};
	return [{
		value,
		lastValidValue,
		valid
	}, onChange];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-os/use-os.mjs
function isMacOS(userAgent) {
	const macosPattern = /(Macintosh)|(MacIntel)|(MacPPC)|(Mac68K)/i;
	return macosPattern.test(userAgent);
}
function isIOS(userAgent) {
	const iosPattern = /(iPhone)|(iPad)|(iPod)/i;
	return iosPattern.test(userAgent);
}
function isWindows(userAgent) {
	const windowsPattern = /(Win32)|(Win64)|(Windows)|(WinCE)/i;
	return windowsPattern.test(userAgent);
}
function isAndroid(userAgent) {
	const androidPattern = /Android/i;
	return androidPattern.test(userAgent);
}
function isLinux(userAgent) {
	const linuxPattern = /Linux/i;
	return linuxPattern.test(userAgent);
}
function isChromeOS(userAgent) {
	const chromePattern = /CrOS/i;
	return chromePattern.test(userAgent);
}
function getOS() {
	if (typeof window === "undefined") return "undetermined";
	const { userAgent } = window.navigator;
	if (isIOS(userAgent) || isMacOS(userAgent) && "ontouchend" in document) return "ios";
	if (isMacOS(userAgent)) return "macos";
	if (isWindows(userAgent)) return "windows";
	if (isAndroid(userAgent)) return "android";
	if (isLinux(userAgent)) return "linux";
	if (isChromeOS(userAgent)) return "chromeos";
	return "undetermined";
}
function useOs(options = { getValueInEffect: true }) {
	const [value, setValue] = (0, import_react.useState)(options.getValueInEffect ? "undetermined" : getOS());
	useIsomorphicEffect(() => {
		if (options.getValueInEffect) setValue(getOS);
	}, []);
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-set-state/use-set-state.mjs
function useSetState(initialState) {
	const [state, setState] = (0, import_react.useState)(initialState);
	const _setState = (0, import_react.useCallback)((statePartial) => setState((current) => ({
		...current,
		...typeof statePartial === "function" ? statePartial(current) : statePartial
	})), []);
	return [state, _setState];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-input-state/use-input-state.mjs
function getInputOnChange(setValue) {
	return (val) => {
		if (!val) setValue(val);
		else if (typeof val === "function") setValue(val);
		else if (typeof val === "object" && "nativeEvent" in val) {
			const { currentTarget } = val;
			if (currentTarget.type === "checkbox") setValue(currentTarget.checked);
			else setValue(currentTarget.value);
		} else setValue(val);
	};
}
function useInputState(initialState) {
	const [value, setValue] = (0, import_react.useState)(initialState);
	return [value, getInputOnChange(setValue)];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-event-listener/use-event-listener.mjs
function useEventListener(type, listener, options) {
	const ref = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		const node = ref.current;
		if (node) {
			node.addEventListener(type, listener, options);
			return () => node?.removeEventListener(type, listener, options);
		}
		return void 0;
	}, [listener, options]);
	return ref;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-disclosure/use-disclosure.mjs
function useDisclosure(initialState = false, callbacks) {
	const { onOpen, onClose } = callbacks || {};
	const [opened, setOpened] = (0, import_react.useState)(initialState);
	const open = (0, import_react.useCallback)(() => {
		setOpened((isOpened) => {
			if (!isOpened) {
				onOpen?.();
				return true;
			}
			return isOpened;
		});
	}, [onOpen]);
	const close = (0, import_react.useCallback)(() => {
		setOpened((isOpened) => {
			if (isOpened) {
				onClose?.();
				return false;
			}
			return isOpened;
		});
	}, [onClose]);
	const toggle = (0, import_react.useCallback)(() => {
		opened ? close() : open();
	}, [
		close,
		open,
		opened
	]);
	return [opened, {
		open,
		close,
		toggle
	}];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-focus-within/use-focus-within.mjs
function containsRelatedTarget(event) {
	if (event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement) return event.currentTarget.contains(event.relatedTarget);
	return false;
}
function useFocusWithin({ onBlur, onFocus } = {}) {
	const ref = (0, import_react.useRef)(null);
	const [focused, setFocused] = (0, import_react.useState)(false);
	const focusedRef = (0, import_react.useRef)(false);
	const _setFocused = (value) => {
		setFocused(value);
		focusedRef.current = value;
	};
	const handleFocusIn = (event) => {
		if (!focusedRef.current) {
			_setFocused(true);
			onFocus?.(event);
		}
	};
	const handleFocusOut = (event) => {
		if (focusedRef.current && !containsRelatedTarget(event)) {
			_setFocused(false);
			onBlur?.(event);
		}
	};
	(0, import_react.useEffect)(() => {
		const node = ref.current;
		if (node) {
			node.addEventListener("focusin", handleFocusIn);
			node.addEventListener("focusout", handleFocusOut);
			return () => {
				node?.removeEventListener("focusin", handleFocusIn);
				node?.removeEventListener("focusout", handleFocusOut);
			};
		}
		return void 0;
	}, [handleFocusIn, handleFocusOut]);
	return {
		ref,
		focused
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-network/use-network.mjs
function getConnection() {
	if (typeof navigator === "undefined") return {};
	const _navigator = navigator;
	const connection = _navigator.connection || _navigator.mozConnection || _navigator.webkitConnection;
	if (!connection) return {};
	return {
		downlink: connection?.downlink,
		downlinkMax: connection?.downlinkMax,
		effectiveType: connection?.effectiveType,
		rtt: connection?.rtt,
		saveData: connection?.saveData,
		type: connection?.type
	};
}
function useNetwork() {
	const [status, setStatus] = (0, import_react.useState)({ online: true });
	const handleConnectionChange = (0, import_react.useCallback)(() => setStatus((current) => ({
		...current,
		...getConnection()
	})), []);
	useWindowEvent("online", () => setStatus({
		online: true,
		...getConnection()
	}));
	useWindowEvent("offline", () => setStatus({
		online: false,
		...getConnection()
	}));
	(0, import_react.useEffect)(() => {
		const _navigator = navigator;
		if (_navigator.connection) {
			setStatus({
				online: _navigator.onLine,
				...getConnection()
			});
			_navigator.connection.addEventListener("change", handleConnectionChange);
			return () => _navigator.connection.removeEventListener("change", handleConnectionChange);
		}
		if (typeof _navigator.onLine === "boolean") setStatus((current) => ({
			...current,
			online: _navigator.onLine
		}));
		return void 0;
	}, []);
	return status;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-timeout/use-timeout.mjs
function useTimeout(callback, delay, options = { autoInvoke: false }) {
	const timeoutRef = (0, import_react.useRef)(null);
	const start = (0, import_react.useCallback)((...callbackParams) => {
		if (!timeoutRef.current) timeoutRef.current = window.setTimeout(() => {
			callback(callbackParams);
			timeoutRef.current = null;
		}, delay);
	}, [delay]);
	const clear = (0, import_react.useCallback)(() => {
		if (timeoutRef.current) {
			window.clearTimeout(timeoutRef.current);
			timeoutRef.current = null;
		}
	}, []);
	(0, import_react.useEffect)(() => {
		if (options.autoInvoke) start();
		return clear;
	}, [clear, start]);
	return {
		start,
		clear
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-text-selection/use-text-selection.mjs
function useTextSelection() {
	const forceUpdate = useForceUpdate();
	const [selection, setSelection] = (0, import_react.useState)(null);
	const handleSelectionChange = () => {
		setSelection(document.getSelection());
		forceUpdate();
	};
	(0, import_react.useEffect)(() => {
		setSelection(document.getSelection());
		document.addEventListener("selectionchange", handleSelectionChange);
		return () => document.removeEventListener("selectionchange", handleSelectionChange);
	}, []);
	return selection;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-previous/use-previous.mjs
function usePrevious(value) {
	const ref = (0, import_react.useRef)(void 0);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	}, [value]);
	return ref.current;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-favicon/use-favicon.mjs
const MIME_TYPES = {
	ico: "image/x-icon",
	png: "image/png",
	svg: "image/svg+xml",
	gif: "image/gif"
};
function useFavicon(url) {
	const link = (0, import_react.useRef)(null);
	useIsomorphicEffect(() => {
		if (!url) return;
		if (!link.current) {
			const existingElements = document.querySelectorAll("link[rel*=\"icon\"]");
			existingElements.forEach((element2) => document.head.removeChild(element2));
			const element = document.createElement("link");
			element.rel = "shortcut icon";
			link.current = element;
			document.querySelector("head").appendChild(element);
		}
		const splittedUrl = url.split(".");
		link.current.setAttribute("type", MIME_TYPES[splittedUrl[splittedUrl.length - 1].toLowerCase()]);
		link.current.setAttribute("href", url);
	}, [url]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-headroom/use-headroom.mjs
const isFixed = (current, fixedAt) => current <= fixedAt;
const isPinnedOrReleased = (current, fixedAt, isCurrentlyPinnedRef, isScrollingUp, onPin, onRelease) => {
	const isInFixedPosition = isFixed(current, fixedAt);
	if (isInFixedPosition && !isCurrentlyPinnedRef.current) {
		isCurrentlyPinnedRef.current = true;
		onPin?.();
	} else if (!isInFixedPosition && isScrollingUp && !isCurrentlyPinnedRef.current) {
		isCurrentlyPinnedRef.current = true;
		onPin?.();
	} else if (!isInFixedPosition && isCurrentlyPinnedRef.current) {
		isCurrentlyPinnedRef.current = false;
		onRelease?.();
	}
};
const useScrollDirection = () => {
	const [lastScrollTop, setLastScrollTop] = (0, import_react.useState)(0);
	const [isScrollingUp, setIsScrollingUp] = (0, import_react.useState)(false);
	const [isResizing, setIsResizing] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		let resizeTimer;
		const onResize = () => {
			setIsResizing(true);
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(() => {
				setIsResizing(false);
			}, 300);
		};
		const onScroll = () => {
			if (isResizing) return;
			const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
			setIsScrollingUp(currentScrollTop < lastScrollTop);
			setLastScrollTop(currentScrollTop);
		};
		window.addEventListener("scroll", onScroll);
		window.addEventListener("resize", onResize);
		return () => {
			window.removeEventListener("scroll", onScroll);
			window.removeEventListener("resize", onResize);
		};
	}, [lastScrollTop, isResizing]);
	return isScrollingUp;
};
function useHeadroom({ fixedAt = 0, onPin, onFix, onRelease } = {}) {
	const isCurrentlyPinnedRef = (0, import_react.useRef)(false);
	const isScrollingUp = useScrollDirection();
	const [{ y: scrollPosition }] = useWindowScroll();
	useIsomorphicEffect(() => {
		isPinnedOrReleased(scrollPosition, fixedAt, isCurrentlyPinnedRef, isScrollingUp, onPin, onRelease);
	}, [scrollPosition]);
	useIsomorphicEffect(() => {
		if (isFixed(scrollPosition, fixedAt)) onFix?.();
	}, [
		scrollPosition,
		fixedAt,
		onFix
	]);
	if (isFixed(scrollPosition, fixedAt) || isScrollingUp) return true;
	return false;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-eye-dropper/use-eye-dropper.mjs
function isOpera() {
	return navigator.userAgent.includes("OPR");
}
function useEyeDropper() {
	const [supported, setSupported] = (0, import_react.useState)(false);
	useIsomorphicEffect(() => {
		setSupported(typeof window !== "undefined" && !isOpera() && "EyeDropper" in window);
	}, []);
	const open = (0, import_react.useCallback)((options = {}) => {
		if (supported) {
			const eyeDropper = new window.EyeDropper();
			return eyeDropper.open(options);
		}
		return Promise.resolve(void 0);
	}, [supported]);
	return {
		supported,
		open
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-in-viewport/use-in-viewport.mjs
function useInViewport() {
	const observer = (0, import_react.useRef)(null);
	const [inViewport, setInViewport] = (0, import_react.useState)(false);
	const ref = (0, import_react.useCallback)((node) => {
		if (typeof IntersectionObserver !== "undefined") {
			if (node && !observer.current) observer.current = new IntersectionObserver((entries) => setInViewport(entries.some((entry) => entry.isIntersecting)));
			else observer.current?.disconnect();
			if (node) observer.current?.observe(node);
			else setInViewport(false);
		}
	}, []);
	return {
		ref,
		inViewport
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-mutation-observer/use-mutation-observer.mjs
function useMutationObserver(callback, options, target) {
	const observer = (0, import_react.useRef)(null);
	const ref = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		const targetElement = typeof target === "function" ? target() : target;
		if (targetElement || ref.current) {
			observer.current = new MutationObserver(callback);
			observer.current.observe(targetElement || ref.current, options);
		}
		return () => {
			observer.current?.disconnect();
		};
	}, [callback, options]);
	return ref;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-mounted/use-mounted.mjs
function useMounted() {
	const [mounted, setMounted] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => setMounted(true), []);
	return mounted;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-state-history/use-state-history.mjs
function useStateHistory(initialValue) {
	const [state, setState] = (0, import_react.useState)({
		history: [initialValue],
		current: 0
	});
	const set = (0, import_react.useCallback)((val) => setState((currentState) => {
		const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
		return {
			history: nextState,
			current: nextState.length - 1
		};
	}), []);
	const back = (0, import_react.useCallback)((steps = 1) => setState((currentState) => ({
		history: currentState.history,
		current: Math.max(0, currentState.current - steps)
	})), []);
	const forward = (0, import_react.useCallback)((steps = 1) => setState((currentState) => ({
		history: currentState.history,
		current: Math.min(currentState.history.length - 1, currentState.current + steps)
	})), []);
	const reset = (0, import_react.useCallback)(() => {
		setState({
			history: [initialValue],
			current: 0
		});
	}, [initialValue]);
	const handlers = (0, import_react.useMemo)(() => ({
		back,
		forward,
		reset,
		set
	}), [
		back,
		forward,
		reset,
		set
	]);
	return [
		state.history[state.current],
		handlers,
		state
	];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-map/use-map.mjs
function useMap(initialState) {
	const mapRef = (0, import_react.useRef)(new Map(initialState));
	const forceUpdate = useForceUpdate();
	mapRef.current.set = (...args) => {
		Map.prototype.set.apply(mapRef.current, args);
		forceUpdate();
		return mapRef.current;
	};
	mapRef.current.clear = (...args) => {
		Map.prototype.clear.apply(mapRef.current, args);
		forceUpdate();
	};
	mapRef.current.delete = (...args) => {
		const res = Map.prototype.delete.apply(mapRef.current, args);
		forceUpdate();
		return res;
	};
	return mapRef.current;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-set/use-set.mjs
function useSet(values) {
	const setRef = (0, import_react.useRef)(new Set(values));
	const forceUpdate = useForceUpdate();
	setRef.current.add = (...args) => {
		const res = Set.prototype.add.apply(setRef.current, args);
		forceUpdate();
		return res;
	};
	setRef.current.clear = (...args) => {
		Set.prototype.clear.apply(setRef.current, args);
		forceUpdate();
	};
	setRef.current.delete = (...args) => {
		const res = Set.prototype.delete.apply(setRef.current, args);
		forceUpdate();
		return res;
	};
	return setRef.current;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-throttled-callback/use-throttled-callback.mjs
function useThrottledCallbackWithClearTimeout(callback, wait) {
	const handleCallback = useCallbackRef(callback);
	const latestInArgsRef = (0, import_react.useRef)(null);
	const latestOutArgsRef = (0, import_react.useRef)(null);
	const active = (0, import_react.useRef)(true);
	const waitRef = (0, import_react.useRef)(wait);
	const timeoutRef = (0, import_react.useRef)(-1);
	const clearTimeout$1 = () => window.clearTimeout(timeoutRef.current);
	const callThrottledCallback = (0, import_react.useCallback)((...args) => {
		handleCallback(...args);
		latestInArgsRef.current = args;
		latestOutArgsRef.current = args;
		active.current = false;
	}, [handleCallback]);
	const timerCallback = (0, import_react.useCallback)(() => {
		if (latestInArgsRef.current && latestInArgsRef.current !== latestOutArgsRef.current) {
			callThrottledCallback(...latestInArgsRef.current);
			timeoutRef.current = window.setTimeout(timerCallback, waitRef.current);
		} else active.current = true;
	}, [callThrottledCallback]);
	const throttled = (0, import_react.useCallback)((...args) => {
		if (active.current) {
			callThrottledCallback(...args);
			timeoutRef.current = window.setTimeout(timerCallback, waitRef.current);
		} else latestInArgsRef.current = args;
	}, [callThrottledCallback, timerCallback]);
	(0, import_react.useEffect)(() => {
		waitRef.current = wait;
	}, [wait]);
	return [throttled, clearTimeout$1];
}
function useThrottledCallback(callback, wait) {
	return useThrottledCallbackWithClearTimeout(callback, wait)[0];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-throttled-state/use-throttled-state.mjs
function useThrottledState(defaultValue, wait) {
	const [value, setValue] = (0, import_react.useState)(defaultValue);
	const [setThrottledValue, clearTimeout$1] = useThrottledCallbackWithClearTimeout(setValue, wait);
	(0, import_react.useEffect)(() => clearTimeout$1, []);
	return [value, setThrottledValue];
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-throttled-value/use-throttled-value.mjs
function useThrottledValue(value, wait) {
	const [throttledValue, setThrottledValue] = (0, import_react.useState)(value);
	const valueRef = (0, import_react.useRef)(value);
	const [throttledSetValue, clearTimeout$1] = useThrottledCallbackWithClearTimeout(setThrottledValue, wait);
	(0, import_react.useEffect)(() => {
		if (value !== valueRef.current) {
			valueRef.current = value;
			throttledSetValue(value);
		}
	}, [throttledSetValue, value]);
	(0, import_react.useEffect)(() => clearTimeout$1, []);
	return throttledValue;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-is-first-render/use-is-first-render.mjs
function useIsFirstRender() {
	const renderRef = (0, import_react.useRef)(true);
	if (renderRef.current === true) {
		renderRef.current = false;
		return true;
	}
	return renderRef.current;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-orientation/use-orientation.mjs
function getInitialValue(initialValue, getInitialValueInEffect) {
	if (getInitialValueInEffect) return initialValue;
	if (typeof window !== "undefined" && "screen" in window) return {
		angle: window.screen.orientation?.angle ?? initialValue.angle,
		type: window.screen.orientation?.type ?? initialValue.type
	};
	return initialValue;
}
function useOrientation({ defaultAngle = 0, defaultType = "landscape-primary", getInitialValueInEffect = true } = {}) {
	const [orientation, setOrientation] = (0, import_react.useState)(getInitialValue({
		angle: defaultAngle,
		type: defaultType
	}, getInitialValueInEffect));
	const handleOrientationChange = (event) => {
		const target = event.currentTarget;
		setOrientation({
			angle: target?.angle || 0,
			type: target?.type || "landscape-primary"
		});
	};
	useIsomorphicEffect(() => {
		window.screen.orientation?.addEventListener("change", handleOrientationChange);
		return () => window.screen.orientation?.removeEventListener("change", handleOrientationChange);
	}, []);
	return orientation;
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-fetch/use-fetch.mjs
function useFetch(url, { autoInvoke = true,...options } = {}) {
	const [data, setData] = (0, import_react.useState)(null);
	const [loading, setLoading] = (0, import_react.useState)(false);
	const [error, setError] = (0, import_react.useState)(null);
	const controller = (0, import_react.useRef)(null);
	const refetch = (0, import_react.useCallback)(() => {
		if (!url) return;
		if (controller.current) controller.current.abort();
		controller.current = new AbortController();
		setLoading(true);
		return fetch(url, {
			signal: controller.current.signal,
			...options
		}).then((res) => res.json()).then((res) => {
			setData(res);
			setLoading(false);
			return res;
		}).catch((err) => {
			setLoading(false);
			if (err.name !== "AbortError") setError(err);
			return err;
		});
	}, [url]);
	const abort = (0, import_react.useCallback)(() => {
		if (controller.current) controller.current?.abort("");
	}, []);
	(0, import_react.useEffect)(() => {
		if (autoInvoke) refetch();
		return () => {
			if (controller.current) controller.current.abort("");
		};
	}, [refetch, autoInvoke]);
	return {
		data,
		loading,
		error,
		refetch,
		abort
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-radial-move/use-radial-move.mjs
function radiansToDegrees(radians) {
	return radians * (180 / Math.PI);
}
function getElementCenter(element) {
	const rect = element.getBoundingClientRect();
	return [rect.left + rect.width / 2, rect.top + rect.height / 2];
}
function getAngle(coordinates, element) {
	const center = getElementCenter(element);
	const x = coordinates[0] - center[0];
	const y = coordinates[1] - center[1];
	const deg = radiansToDegrees(Math.atan2(x, y)) + 180;
	return 360 - deg;
}
function toFixed(value, digits) {
	return parseFloat(value.toFixed(digits));
}
function getDigitsAfterDot(value) {
	return value.toString().split(".")[1]?.length || 0;
}
function normalizeRadialValue(degree, step) {
	const clamped = clamp(degree, 0, 360);
	const high = Math.ceil(clamped / step);
	const low = Math.round(clamped / step);
	return toFixed(high >= clamped / step ? high * step === 360 ? 0 : high * step : low * step, getDigitsAfterDot(step));
}
function useRadialMove(onChange, { step = .01, onChangeEnd, onScrubStart, onScrubEnd } = {}) {
	const ref = (0, import_react.useRef)(null);
	const mounted = (0, import_react.useRef)(false);
	const [active, setActive] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		mounted.current = true;
	}, []);
	(0, import_react.useEffect)(() => {
		const node = ref.current;
		const update = (event, done = false) => {
			if (node) {
				node.style.userSelect = "none";
				const deg = getAngle([event.clientX, event.clientY], node);
				const newValue = normalizeRadialValue(deg, step || 1);
				onChange(newValue);
				done && onChangeEnd?.(newValue);
			}
		};
		const beginTracking = () => {
			onScrubStart?.();
			setActive(true);
			document.addEventListener("mousemove", handleMouseMove, false);
			document.addEventListener("mouseup", handleMouseUp, false);
			document.addEventListener("touchmove", handleTouchMove, { passive: false });
			document.addEventListener("touchend", handleTouchEnd, false);
		};
		const endTracking = () => {
			onScrubEnd?.();
			setActive(false);
			document.removeEventListener("mousemove", handleMouseMove, false);
			document.removeEventListener("mouseup", handleMouseUp, false);
			document.removeEventListener("touchmove", handleTouchMove, false);
			document.removeEventListener("touchend", handleTouchEnd, false);
		};
		const onMouseDown = (event) => {
			beginTracking();
			update(event);
		};
		const handleMouseMove = (event) => {
			update(event);
		};
		const handleMouseUp = (event) => {
			update(event, true);
			endTracking();
		};
		const handleTouchMove = (event) => {
			event.preventDefault();
			update(event.touches[0]);
		};
		const handleTouchEnd = (event) => {
			update(event.changedTouches[0], true);
			endTracking();
		};
		const handleTouchStart = (event) => {
			event.preventDefault();
			beginTracking();
			update(event.touches[0]);
		};
		node?.addEventListener("mousedown", onMouseDown);
		node?.addEventListener("touchstart", handleTouchStart, { passive: false });
		return () => {
			if (node) {
				node.removeEventListener("mousedown", onMouseDown);
				node.removeEventListener("touchstart", handleTouchStart);
			}
		};
	}, [onChange]);
	return {
		ref,
		active
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-scroll-spy/use-scroll-spy.mjs
function getHeadingsData(headings, getDepth, getValue) {
	const result = [];
	for (let i = 0; i < headings.length; i += 1) {
		const heading = headings[i];
		result.push({
			depth: getDepth(heading),
			value: getValue(heading),
			id: heading.id || randomId(),
			getNode: () => heading.id ? document.getElementById(heading.id) : heading
		});
	}
	return result;
}
function getActiveElement(rects) {
	if (rects.length === 0) return -1;
	const closest = rects.reduce((acc, item, index) => {
		if (Math.abs(acc.position) < Math.abs(item.y)) return acc;
		return {
			index,
			position: item.y
		};
	}, {
		index: 0,
		position: rects[0].y
	});
	return closest.index;
}
function getDefaultDepth(element) {
	return Number(element.tagName[1]);
}
function getDefaultValue(element) {
	return element.textContent || "";
}
function useScrollSpy({ selector = "h1, h2, h3, h4, h5, h6", getDepth = getDefaultDepth, getValue = getDefaultValue } = {}) {
	const [active, setActive] = (0, import_react.useState)(-1);
	const [initialized, setInitialized] = (0, import_react.useState)(false);
	const [data, setData] = (0, import_react.useState)([]);
	const headingsRef = (0, import_react.useRef)([]);
	const handleScroll = () => {
		setActive(getActiveElement(headingsRef.current.map((d) => d.getNode().getBoundingClientRect())));
	};
	const initialize = () => {
		const headings = getHeadingsData(Array.from(document.querySelectorAll(selector)), getDepth, getValue);
		headingsRef.current = headings;
		setInitialized(true);
		setData(headings);
		setActive(getActiveElement(headings.map((d) => d.getNode().getBoundingClientRect())));
	};
	(0, import_react.useEffect)(() => {
		initialize();
		window.addEventListener("scroll", handleScroll);
		return () => window.removeEventListener("scroll", handleScroll);
	}, []);
	return {
		reinitialize: initialize,
		active,
		initialized,
		data
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+hooks@8.0.2_react@19.1.0/node_modules/@mantine/hooks/esm/use-file-dialog/use-file-dialog.mjs
const defaultOptions = {
	multiple: true,
	accept: "*"
};
function getInitialFilesList(files) {
	if (!files) return null;
	if (files instanceof FileList) return files;
	const result = new DataTransfer();
	for (const file of files) result.items.add(file);
	return result.files;
}
function createInput(options) {
	if (typeof document === "undefined") return null;
	const input = document.createElement("input");
	input.type = "file";
	if (options.accept) input.accept = options.accept;
	if (options.multiple) input.multiple = options.multiple;
	if (options.capture) input.capture = options.capture;
	if (options.directory) input.webkitdirectory = options.directory;
	input.style.display = "none";
	return input;
}
function useFileDialog(input = {}) {
	const options = {
		...defaultOptions,
		...input
	};
	const [files, setFiles] = (0, import_react.useState)(getInitialFilesList(options.initialFiles));
	const inputRef = (0, import_react.useRef)(null);
	const handleChange = (0, import_react.useCallback)((event) => {
		const target = event.target;
		if (target?.files) {
			setFiles(target.files);
			options.onChange?.(target.files);
		}
	}, [options.onChange]);
	const createAndSetupInput = (0, import_react.useCallback)(() => {
		inputRef.current?.remove();
		inputRef.current = createInput(options);
		if (inputRef.current) {
			inputRef.current.addEventListener("change", handleChange, { once: true });
			document.body.appendChild(inputRef.current);
		}
	}, [options, handleChange]);
	useIsomorphicEffect(() => {
		createAndSetupInput();
		return () => inputRef.current?.remove();
	}, []);
	const reset = (0, import_react.useCallback)(() => {
		setFiles(null);
		options.onChange?.(null);
	}, [options.onChange]);
	const open = (0, import_react.useCallback)(() => {
		if (options.resetOnOpen) reset();
		createAndSetupInput();
		inputRef.current?.click();
	}, [
		options.resetOnOpen,
		reset,
		createAndSetupInput
	]);
	return {
		files,
		open,
		reset
	};
}

//#endregion
export { assignRef, clamp, clampUseMovePosition, getHotkeyHandler, lowerFirst, mergeRefs, normalizeRadialValue, randomId, range$1 as range, readLocalStorageValue, readSessionStorageValue, shallowEqual, upperFirst, useCallbackRef, useClickOutside, useClipboard, useColorScheme, useCounter, useDebouncedCallback, useDebouncedState, useDebouncedValue, useDidUpdate, useDisclosure, useDocumentTitle, useDocumentVisibility, useElementSize, useEventListener, useEyeDropper, useFavicon, useFetch, useFileDialog, useFocusReturn, useFocusTrap, useFocusWithin, useForceUpdate, useFullscreen, useHash, useHeadroom, useHotkeys, useHover, useId, useIdle, useInViewport, useInputState, useIntersection, useInterval, useIsFirstRender, useIsomorphicEffect, useListState, useLocalStorage, useLogger, useMap, useMediaQuery, useMergedRef, useMounted, useMouse, useMove, useMutationObserver, useNetwork, useOrientation, useOs, usePageLeave, usePagination, usePrevious, useQueue, useRadialMove, useReducedMotion, useResizeObserver, useScrollIntoView, useScrollSpy, useSessionStorage, useSet, useSetState, useShallowEffect, useStateHistory, useTextSelection, useThrottledCallback, useThrottledState, useThrottledValue, useTimeout, useToggle, useUncontrolled, useValidatedState, useViewportSize, useWindowEvent, useWindowScroll };
//# sourceMappingURL=esm-B4SPqT69.js.map