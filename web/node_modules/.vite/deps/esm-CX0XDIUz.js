import { __toESM } from "./chunk-51aI8Tpl.js";
import { require_with_selector } from "./with-selector-DtYlzctE.js";

//#region node_modules/.pnpm/@tanstack+store@0.7.1/node_modules/@tanstack/store/dist/esm/scheduler.js
const __storeToDerived = /* @__PURE__ */ new WeakMap();
const __derivedToStore = /* @__PURE__ */ new WeakMap();
const __depsThatHaveWrittenThisTick = { current: [] };
let __isFlushing = false;
let __batchDepth = 0;
const __pendingUpdates = /* @__PURE__ */ new Set();
const __initialBatchValues = /* @__PURE__ */ new Map();
function __flush_internals(relatedVals) {
	const sorted = Array.from(relatedVals).sort((a, b) => {
		if (a instanceof Derived && a.options.deps.includes(b)) return 1;
		if (b instanceof Derived && b.options.deps.includes(a)) return -1;
		return 0;
	});
	for (const derived of sorted) {
		if (__depsThatHaveWrittenThisTick.current.includes(derived)) continue;
		__depsThatHaveWrittenThisTick.current.push(derived);
		derived.recompute();
		const stores = __derivedToStore.get(derived);
		if (stores) for (const store of stores) {
			const relatedLinkedDerivedVals = __storeToDerived.get(store);
			if (!relatedLinkedDerivedVals) continue;
			__flush_internals(relatedLinkedDerivedVals);
		}
	}
}
function __notifyListeners(store) {
	store.listeners.forEach((listener) => listener({
		prevVal: store.prevState,
		currentVal: store.state
	}));
}
function __notifyDerivedListeners(derived) {
	derived.listeners.forEach((listener) => listener({
		prevVal: derived.prevState,
		currentVal: derived.state
	}));
}
function __flush(store) {
	if (__batchDepth > 0 && !__initialBatchValues.has(store)) __initialBatchValues.set(store, store.prevState);
	__pendingUpdates.add(store);
	if (__batchDepth > 0) return;
	if (__isFlushing) return;
	try {
		__isFlushing = true;
		while (__pendingUpdates.size > 0) {
			const stores = Array.from(__pendingUpdates);
			__pendingUpdates.clear();
			for (const store2 of stores) {
				const prevState = __initialBatchValues.get(store2) ?? store2.prevState;
				store2.prevState = prevState;
				__notifyListeners(store2);
			}
			for (const store2 of stores) {
				const derivedVals = __storeToDerived.get(store2);
				if (!derivedVals) continue;
				__depsThatHaveWrittenThisTick.current.push(store2);
				__flush_internals(derivedVals);
			}
			for (const store2 of stores) {
				const derivedVals = __storeToDerived.get(store2);
				if (!derivedVals) continue;
				for (const derived of derivedVals) __notifyDerivedListeners(derived);
			}
		}
	} finally {
		__isFlushing = false;
		__depsThatHaveWrittenThisTick.current = [];
		__initialBatchValues.clear();
	}
}
function batch(fn) {
	__batchDepth++;
	try {
		fn();
	} finally {
		__batchDepth--;
		if (__batchDepth === 0) {
			const pendingUpdateToFlush = Array.from(__pendingUpdates)[0];
			if (pendingUpdateToFlush) __flush(pendingUpdateToFlush);
		}
	}
}

//#endregion
//#region node_modules/.pnpm/@tanstack+store@0.7.1/node_modules/@tanstack/store/dist/esm/types.js
function isUpdaterFunction(updater) {
	return typeof updater === "function";
}

//#endregion
//#region node_modules/.pnpm/@tanstack+store@0.7.1/node_modules/@tanstack/store/dist/esm/store.js
var Store = class {
	constructor(initialState, options) {
		this.listeners = /* @__PURE__ */ new Set();
		this.subscribe = (listener) => {
			var _a, _b;
			this.listeners.add(listener);
			const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
			return () => {
				this.listeners.delete(listener);
				unsub == null || unsub();
			};
		};
		this.prevState = initialState;
		this.state = initialState;
		this.options = options;
	}
	setState(updater) {
		var _a, _b, _c;
		this.prevState = this.state;
		if ((_a = this.options) == null ? void 0 : _a.updateFn) this.state = this.options.updateFn(this.prevState)(updater);
		else if (isUpdaterFunction(updater)) this.state = updater(this.prevState);
		else this.state = updater;
		(_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null || _c.call(_b);
		__flush(this);
	}
};

//#endregion
//#region node_modules/.pnpm/@tanstack+store@0.7.1/node_modules/@tanstack/store/dist/esm/derived.js
var Derived = class Derived {
	constructor(options) {
		this.listeners = /* @__PURE__ */ new Set();
		this._subscriptions = [];
		this.lastSeenDepValues = [];
		this.getDepVals = () => {
			const prevDepVals = [];
			const currDepVals = [];
			for (const dep of this.options.deps) {
				prevDepVals.push(dep.prevState);
				currDepVals.push(dep.state);
			}
			this.lastSeenDepValues = currDepVals;
			return {
				prevDepVals,
				currDepVals,
				prevVal: this.prevState ?? void 0
			};
		};
		this.recompute = () => {
			var _a, _b;
			this.prevState = this.state;
			const { prevDepVals, currDepVals, prevVal } = this.getDepVals();
			this.state = this.options.fn({
				prevDepVals,
				currDepVals,
				prevVal
			});
			(_b = (_a = this.options).onUpdate) == null || _b.call(_a);
		};
		this.checkIfRecalculationNeededDeeply = () => {
			for (const dep of this.options.deps) if (dep instanceof Derived) dep.checkIfRecalculationNeededDeeply();
			let shouldRecompute = false;
			const lastSeenDepValues = this.lastSeenDepValues;
			const { currDepVals } = this.getDepVals();
			for (let i = 0; i < currDepVals.length; i++) if (currDepVals[i] !== lastSeenDepValues[i]) {
				shouldRecompute = true;
				break;
			}
			if (shouldRecompute) this.recompute();
		};
		this.mount = () => {
			this.registerOnGraph();
			this.checkIfRecalculationNeededDeeply();
			return () => {
				this.unregisterFromGraph();
				for (const cleanup of this._subscriptions) cleanup();
			};
		};
		this.subscribe = (listener) => {
			var _a, _b;
			this.listeners.add(listener);
			const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
			return () => {
				this.listeners.delete(listener);
				unsub == null || unsub();
			};
		};
		this.options = options;
		this.state = options.fn({
			prevDepVals: void 0,
			prevVal: void 0,
			currDepVals: this.getDepVals().currDepVals
		});
	}
	registerOnGraph(deps = this.options.deps) {
		for (const dep of deps) if (dep instanceof Derived) {
			dep.registerOnGraph();
			this.registerOnGraph(dep.options.deps);
		} else if (dep instanceof Store) {
			let relatedLinkedDerivedVals = __storeToDerived.get(dep);
			if (!relatedLinkedDerivedVals) {
				relatedLinkedDerivedVals = /* @__PURE__ */ new Set();
				__storeToDerived.set(dep, relatedLinkedDerivedVals);
			}
			relatedLinkedDerivedVals.add(this);
			let relatedStores = __derivedToStore.get(this);
			if (!relatedStores) {
				relatedStores = /* @__PURE__ */ new Set();
				__derivedToStore.set(this, relatedStores);
			}
			relatedStores.add(dep);
		}
	}
	unregisterFromGraph(deps = this.options.deps) {
		for (const dep of deps) if (dep instanceof Derived) this.unregisterFromGraph(dep.options.deps);
		else if (dep instanceof Store) {
			const relatedLinkedDerivedVals = __storeToDerived.get(dep);
			if (relatedLinkedDerivedVals) relatedLinkedDerivedVals.delete(this);
			const relatedStores = __derivedToStore.get(this);
			if (relatedStores) relatedStores.delete(dep);
		}
	}
};

//#endregion
//#region node_modules/.pnpm/@tanstack+react-store@0.7.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-store/dist/esm/index.js
var import_with_selector = __toESM(require_with_selector());
function useStore(store, selector = (d) => d) {
	const slice = (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, () => store.state, () => store.state, selector, shallow);
	return slice;
}
function shallow(objA, objB) {
	if (Object.is(objA, objB)) return true;
	if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return false;
	if (objA instanceof Map && objB instanceof Map) {
		if (objA.size !== objB.size) return false;
		for (const [k, v] of objA) if (!objB.has(k) || !Object.is(v, objB.get(k))) return false;
		return true;
	}
	if (objA instanceof Set && objB instanceof Set) {
		if (objA.size !== objB.size) return false;
		for (const v of objA) if (!objB.has(v)) return false;
		return true;
	}
	const keysA = Object.keys(objA);
	if (keysA.length !== Object.keys(objB).length) return false;
	for (let i = 0; i < keysA.length; i++) if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) return false;
	return true;
}

//#endregion
export { Derived, Store, batch, useStore };
//# sourceMappingURL=esm-CX0XDIUz.js.map