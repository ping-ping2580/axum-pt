import { __toESM } from "./chunk-51aI8Tpl.js";
import { require_react } from "./react-DN4s_Om_.js";
import { require_jsx_runtime } from "./jsx-runtime-IyzZn-RK.js";
import { Box, Button, Group, Modal, createUseExternalEvents, getDefaultZIndex } from "./esm-CVXcWmma.js";
import { randomId } from "./esm-B4SPqT69.js";
import "./react-dom-BighsA4B.js";

//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/context.mjs
var import_react = __toESM(require_react(), 1);
const ModalsContext = (0, import_react.createContext)(null);
ModalsContext.displayName = "@mantine/modals/ModalsContext";

//#endregion
//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/use-modals/use-modals.mjs
function useModals() {
	const ctx = (0, import_react.useContext)(ModalsContext);
	if (!ctx) throw new Error("[@mantine/modals] useModals hook was called outside of context, wrap your app with ModalsProvider component");
	return ctx;
}

//#endregion
//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/ConfirmModal.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function ConfirmModal({ id, cancelProps, confirmProps, labels = {
	cancel: "",
	confirm: ""
}, closeOnConfirm = true, closeOnCancel = true, groupProps, onCancel, onConfirm, children }) {
	const { cancel: cancelLabel, confirm: confirmLabel } = labels;
	const ctx = useModals();
	const handleCancel = (event) => {
		typeof cancelProps?.onClick === "function" && cancelProps?.onClick(event);
		typeof onCancel === "function" && onCancel();
		closeOnCancel && ctx.closeModal(id);
	};
	const handleConfirm = (event) => {
		typeof confirmProps?.onClick === "function" && confirmProps?.onClick(event);
		typeof onConfirm === "function" && onConfirm();
		closeOnConfirm && ctx.closeModal(id);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		mb: "md",
		children
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Group, {
		mt: children ? 0 : "md",
		justify: "flex-end",
		...groupProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
			variant: "default",
			...cancelProps,
			onClick: handleCancel,
			children: cancelProps?.children || cancelLabel
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
			...confirmProps,
			onClick: handleConfirm,
			children: confirmProps?.children || confirmLabel
		})]
	})] });
}

//#endregion
//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/events.mjs
const [useModalsEvents, createEvent] = createUseExternalEvents("mantine-modals");
const openModal = (payload) => {
	const id = payload.modalId || randomId();
	createEvent("openModal")({
		...payload,
		modalId: id
	});
	return id;
};
const openConfirmModal = (payload) => {
	const id = payload.modalId || randomId();
	createEvent("openConfirmModal")({
		...payload,
		modalId: id
	});
	return id;
};
const openContextModal = (payload) => {
	const id = payload.modalId || randomId();
	createEvent("openContextModal")({
		...payload,
		modalId: id
	});
	return id;
};
const closeModal = createEvent("closeModal");
const closeAllModals = createEvent("closeAllModals");
const updateModal = (payload) => createEvent("updateModal")(payload);
const updateContextModal = (payload) => createEvent("updateContextModal")(payload);
const modals = {
	open: openModal,
	close: closeModal,
	closeAll: closeAllModals,
	openConfirmModal,
	openContextModal,
	updateModal,
	updateContextModal
};

//#endregion
//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/reducer.mjs
function handleCloseModal(modal, canceled) {
	if (canceled && modal.type === "confirm") modal.props.onCancel?.();
	modal.props.onClose?.();
}
function modalsReducer(state, action) {
	switch (action.type) {
		case "OPEN": return {
			current: action.modal,
			modals: [...state.modals, action.modal]
		};
		case "CLOSE": {
			const modal = state.modals.find((m) => m.id === action.modalId);
			if (!modal) return state;
			handleCloseModal(modal, action.canceled);
			const remainingModals = state.modals.filter((m) => m.id !== action.modalId);
			return {
				current: remainingModals[remainingModals.length - 1] || state.current,
				modals: remainingModals
			};
		}
		case "CLOSE_ALL": {
			if (!state.modals.length) return state;
			state.modals.concat().reverse().forEach((modal) => {
				handleCloseModal(modal, action.canceled);
			});
			return {
				current: state.current,
				modals: []
			};
		}
		case "UPDATE": {
			const { modalId, newProps } = action;
			const updatedModals = state.modals.map((modal) => {
				if (modal.id !== modalId) return modal;
				if (modal.type === "content" || modal.type === "confirm") return {
					...modal,
					props: {
						...modal.props,
						...newProps
					}
				};
				if (modal.type === "context") return {
					...modal,
					props: {
						...modal.props,
						...newProps,
						innerProps: {
							...modal.props.innerProps,
							...newProps.innerProps
						}
					}
				};
				return modal;
			});
			const currentModal = state.current?.id === modalId ? updatedModals.find((modal) => modal.id === modalId) || state.current : state.current;
			return {
				...state,
				modals: updatedModals,
				current: currentModal
			};
		}
		default: return state;
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+modals@8.0.2_@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+rea_b3d31d8fe24c176dfc373262cf41c2d9/node_modules/@mantine/modals/esm/ModalsProvider.mjs
function separateConfirmModalProps(props) {
	if (!props) return {
		confirmProps: {},
		modalProps: {}
	};
	const { id, children, onCancel, onConfirm, closeOnConfirm, closeOnCancel, cancelProps, confirmProps, groupProps, labels,...others } = props;
	return {
		confirmProps: {
			id,
			children,
			onCancel,
			onConfirm,
			closeOnConfirm,
			closeOnCancel,
			cancelProps,
			confirmProps,
			groupProps,
			labels
		},
		modalProps: {
			id,
			...others
		}
	};
}
function ModalsProvider({ children, modalProps, labels, modals: modals$1 }) {
	const [state, dispatch] = (0, import_react.useReducer)(modalsReducer, {
		modals: [],
		current: null
	});
	const stateRef = (0, import_react.useRef)(state);
	stateRef.current = state;
	const closeAll = (0, import_react.useCallback)((canceled) => {
		dispatch({
			type: "CLOSE_ALL",
			canceled
		});
	}, [stateRef, dispatch]);
	const openModal$1 = (0, import_react.useCallback)(({ modalId,...props }) => {
		const id = modalId || randomId();
		dispatch({
			type: "OPEN",
			modal: {
				id,
				type: "content",
				props
			}
		});
		return id;
	}, [dispatch]);
	const openConfirmModal$1 = (0, import_react.useCallback)(({ modalId,...props }) => {
		const id = modalId || randomId();
		dispatch({
			type: "OPEN",
			modal: {
				id,
				type: "confirm",
				props
			}
		});
		return id;
	}, [dispatch]);
	const openContextModal$1 = (0, import_react.useCallback)((modal, { modalId,...props }) => {
		const id = modalId || randomId();
		dispatch({
			type: "OPEN",
			modal: {
				id,
				type: "context",
				props,
				ctx: modal
			}
		});
		return id;
	}, [dispatch]);
	const closeModal$1 = (0, import_react.useCallback)((id, canceled) => {
		dispatch({
			type: "CLOSE",
			modalId: id,
			canceled
		});
	}, [stateRef, dispatch]);
	const updateModal$1 = (0, import_react.useCallback)(({ modalId,...newProps }) => {
		dispatch({
			type: "UPDATE",
			modalId,
			newProps
		});
	}, [dispatch]);
	const updateContextModal$1 = (0, import_react.useCallback)(({ modalId,...newProps }) => {
		dispatch({
			type: "UPDATE",
			modalId,
			newProps
		});
	}, [dispatch]);
	useModalsEvents({
		openModal: openModal$1,
		openConfirmModal: openConfirmModal$1,
		openContextModal: ({ modal,...payload }) => openContextModal$1(modal, payload),
		closeModal: closeModal$1,
		closeContextModal: closeModal$1,
		closeAllModals: closeAll,
		updateModal: updateModal$1,
		updateContextModal: updateContextModal$1
	});
	const ctx = {
		modalProps: modalProps || {},
		modals: state.modals,
		openModal: openModal$1,
		openConfirmModal: openConfirmModal$1,
		openContextModal: openContextModal$1,
		closeModal: closeModal$1,
		closeContextModal: closeModal$1,
		closeAll,
		updateModal: updateModal$1,
		updateContextModal: updateContextModal$1
	};
	const getCurrentModal = () => {
		const currentModal = stateRef.current.current;
		switch (currentModal?.type) {
			case "context": {
				const { innerProps,...rest } = currentModal.props;
				const ContextModal = modals$1[currentModal.ctx];
				return {
					modalProps: rest,
					content: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ContextModal, {
						innerProps,
						context: ctx,
						id: currentModal.id
					})
				};
			}
			case "confirm": {
				const { modalProps: separatedModalProps, confirmProps: separatedConfirmProps } = separateConfirmModalProps(currentModal.props);
				return {
					modalProps: separatedModalProps,
					content: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ConfirmModal, {
						...separatedConfirmProps,
						id: currentModal.id,
						labels: currentModal.props.labels || labels
					})
				};
			}
			case "content": {
				const { children: currentModalChildren,...rest } = currentModal.props;
				return {
					modalProps: rest,
					content: currentModalChildren
				};
			}
			default: return {
				modalProps: {},
				content: null
			};
		}
	};
	const { modalProps: currentModalProps, content } = getCurrentModal();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ModalsContext.Provider, {
		value: ctx,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Modal, {
			zIndex: getDefaultZIndex("modal") + 1,
			...modalProps,
			...currentModalProps,
			opened: state.modals.length > 0,
			onClose: () => closeModal$1(state.current?.id),
			children: content
		}), children]
	});
}

//#endregion
export { ModalsProvider, closeAllModals, closeModal, modals, openConfirmModal, openContextModal, openModal, updateContextModal, updateModal, useModals };
//# sourceMappingURL=@mantine_modals.js.map