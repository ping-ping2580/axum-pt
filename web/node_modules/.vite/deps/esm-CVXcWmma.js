import { __toESM } from "./chunk-51aI8Tpl.js";
import { require_react } from "./react-DN4s_Om_.js";
import { require_jsx_runtime } from "./jsx-runtime-IyzZn-RK.js";
import { assignRef, clamp, clampUseMovePosition, mergeRefs, normalizeRadialValue, randomId, useCallbackRef, useClickOutside, useClipboard, useColorScheme, useDebouncedCallback, useDidUpdate, useDisclosure, useElementSize, useEyeDropper, useFocusReturn, useFocusTrap, useId, useIsomorphicEffect, useMediaQuery, useMergedRef, useMounted, useMove, useMutationObserver, usePagination, usePrevious, useRadialMove, useReducedMotion, useScrollSpy, useShallowEffect, useTimeout, useUncontrolled, useWindowEvent } from "./esm-B4SPqT69.js";
import { require_react_dom } from "./react-dom-BighsA4B.js";

//#region node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e) {
	var t, f, n = "";
	if ("string" == typeof e || "number" == typeof e) n += e;
	else if ("object" == typeof e) if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
	return n;
}
var clsx_default = clsx;

//#endregion
//#region node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
	__assign = Object.assign || function __assign$1(t) {
		for (var s, i = 1, n = arguments.length; i < n; i++) {
			s = arguments[i];
			for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		}
		return t;
	};
	return __assign.apply(this, arguments);
};
function __rest$1(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
}

//#endregion
//#region node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
/**
* Name of a CSS variable containing the amount of "hidden" scrollbar
* ! might be undefined ! use will fallback!
*/
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

//#endregion
//#region node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.6_react@19.1.0/node_modules/use-callback-ref/dist/es2015/assignRef.js
/**
* Assigns a value for a given ref, no matter of the ref format
* @param {RefObject} ref - a callback function or ref object
* @param value - a new value
*
* @see https://github.com/theKashey/use-callback-ref#assignref
* @example
* const refObject = useRef();
* const refFn = (ref) => {....}
*
* assignRef(refObject, "refValue");
* assignRef(refFn, "refValue");
*/
function assignRef$1(ref, value) {
	if (typeof ref === "function") ref(value);
	else if (ref) ref.current = value;
	return ref;
}

//#endregion
//#region node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.6_react@19.1.0/node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react = __toESM(require_react());
/**
* creates a MutableRef with ref change callback
* @param initialValue - initial ref value
* @param {Function} callback - a callback to run when value changes
*
* @example
* const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
* ref.current = 1;
* // prints 0 -> 1
*
* @see https://reactjs.org/docs/hooks-reference.html#useref
* @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
* @returns {MutableRefObject}
*/
function useCallbackRef$1(initialValue, callback) {
	var ref = (0, import_react.useState)(function() {
		return {
			value: initialValue,
			callback,
			facade: {
				get current() {
					return ref.value;
				},
				set current(value) {
					var last = ref.value;
					if (last !== value) {
						ref.value = value;
						ref.callback(value, last);
					}
				}
			}
		};
	})[0];
	ref.callback = callback;
	return ref.facade;
}

//#endregion
//#region node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.6_react@19.1.0/node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
/**
* Merges two or more refs together providing a single interface to set their value
* @param {RefObject|Ref} refs
* @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
*
* @see {@link mergeRefs} a version without buit-in memoization
* @see https://github.com/theKashey/use-callback-ref#usemergerefs
* @example
* const Component = React.forwardRef((props, ref) => {
*   const ownRef = useRef();
*   const domRef = useMergeRefs([ref, ownRef]); // ðŸ‘ˆ merge together
*   return <div ref={domRef}>...</div>
* }
*/
function useMergeRefs$1(refs, defaultValue) {
	var callbackRef = useCallbackRef$1(defaultValue || null, function(newValue) {
		return refs.forEach(function(ref) {
			return assignRef$1(ref, newValue);
		});
	});
	useIsomorphicLayoutEffect(function() {
		var oldValue = currentValues.get(callbackRef);
		if (oldValue) {
			var prevRefs_1 = new Set(oldValue);
			var nextRefs_1 = new Set(refs);
			var current_1 = callbackRef.current;
			prevRefs_1.forEach(function(ref) {
				if (!nextRefs_1.has(ref)) assignRef$1(ref, null);
			});
			nextRefs_1.forEach(function(ref) {
				if (!prevRefs_1.has(ref)) assignRef$1(ref, current_1);
			});
		}
		currentValues.set(callbackRef, refs);
	}, [refs]);
	return callbackRef;
}

//#endregion
//#region node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.6_react@19.1.0/node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
	return a;
}
function innerCreateMedium(defaults, middleware) {
	if (middleware === void 0) middleware = ItoI;
	var buffer = [];
	var assigned = false;
	var medium = {
		read: function() {
			if (assigned) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
			if (buffer.length) return buffer[buffer.length - 1];
			return defaults;
		},
		useMedium: function(data) {
			var item = middleware(data, assigned);
			buffer.push(item);
			return function() {
				buffer = buffer.filter(function(x) {
					return x !== item;
				});
			};
		},
		assignSyncMedium: function(cb) {
			assigned = true;
			while (buffer.length) {
				var cbs = buffer;
				buffer = [];
				cbs.forEach(cb);
			}
			buffer = {
				push: function(x) {
					return cb(x);
				},
				filter: function() {
					return buffer;
				}
			};
		},
		assignMedium: function(cb) {
			assigned = true;
			var pendingQueue = [];
			if (buffer.length) {
				var cbs = buffer;
				buffer = [];
				cbs.forEach(cb);
				pendingQueue = buffer;
			}
			var executeQueue = function() {
				var cbs$1 = pendingQueue;
				pendingQueue = [];
				cbs$1.forEach(cb);
			};
			var cycle = function() {
				return Promise.resolve().then(executeQueue);
			};
			cycle();
			buffer = {
				push: function(x) {
					pendingQueue.push(x);
					cycle();
				},
				filter: function(filter) {
					pendingQueue = pendingQueue.filter(filter);
					return buffer;
				}
			};
		}
	};
	return medium;
}
function createSidecarMedium(options$1) {
	if (options$1 === void 0) options$1 = {};
	var medium = innerCreateMedium(null);
	medium.options = __assign({
		async: true,
		ssr: false
	}, options$1);
	return medium;
}

//#endregion
//#region node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.6_react@19.1.0/node_modules/use-sidecar/dist/es2015/exports.js
var SideCar = function(_a) {
	var sideCar = _a.sideCar, rest = __rest$1(_a, ["sideCar"]);
	if (!sideCar) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
	var Target = sideCar.read();
	if (!Target) throw new Error("Sidecar medium not found");
	return import_react.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
	medium.useMedium(exported);
	return SideCar;
}

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
	return;
};
/**
* Removes scrollbar from the page and contain the scroll within the Lock
*/
var RemoveScroll = import_react.forwardRef(function(props, parentRef) {
	var ref = import_react.useRef(null);
	var _a = import_react.useState({
		onScrollCapture: nothing,
		onWheelCapture: nothing,
		onTouchMoveCapture: nothing
	}), callbacks = _a[0], setCallbacks = _a[1];
	var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container$1 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest$1(props, [
		"forwardProps",
		"children",
		"className",
		"removeScrollBar",
		"enabled",
		"shards",
		"sideCar",
		"noRelative",
		"noIsolation",
		"inert",
		"allowPinchZoom",
		"as",
		"gapMode"
	]);
	var SideCar$1 = sideCar;
	var containerRef = useMergeRefs$1([ref, parentRef]);
	var containerProps = __assign(__assign({}, rest), callbacks);
	return import_react.createElement(import_react.Fragment, null, enabled && import_react.createElement(SideCar$1, {
		sideCar: effectCar,
		removeScrollBar,
		shards,
		noRelative,
		noIsolation,
		inert,
		setCallbacks,
		allowPinchZoom: !!allowPinchZoom,
		lockRef: ref,
		gapMode
	}), forwardProps ? import_react.cloneElement(import_react.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : import_react.createElement(Container$1, __assign({}, containerProps, {
		className,
		ref: containerRef
	}), children));
});
RemoveScroll.defaultProps = {
	enabled: true,
	removeScrollBar: true,
	inert: false
};
RemoveScroll.classNames = {
	fullWidth: fullWidthClassName,
	zeroRight: zeroRightClassName
};

//#endregion
//#region node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
	if (currentNonce) return currentNonce;
	if (typeof __webpack_nonce__ !== "undefined") return __webpack_nonce__;
	return void 0;
};

//#endregion
//#region node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.6_react@19.1.0/node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
	if (!document) return null;
	var tag = document.createElement("style");
	tag.type = "text/css";
	var nonce = getNonce();
	if (nonce) tag.setAttribute("nonce", nonce);
	return tag;
}
function injectStyles(tag, css) {
	if (tag.styleSheet) tag.styleSheet.cssText = css;
	else tag.appendChild(document.createTextNode(css));
}
function insertStyleTag(tag) {
	var head = document.head || document.getElementsByTagName("head")[0];
	head.appendChild(tag);
}
var stylesheetSingleton = function() {
	var counter = 0;
	var stylesheet = null;
	return {
		add: function(style) {
			if (counter == 0) {
				if (stylesheet = makeStyleTag()) {
					injectStyles(stylesheet, style);
					insertStyleTag(stylesheet);
				}
			}
			counter++;
		},
		remove: function() {
			counter--;
			if (!counter && stylesheet) {
				stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
				stylesheet = null;
			}
		}
	};
};

//#endregion
//#region node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.6_react@19.1.0/node_modules/react-style-singleton/dist/es2015/hook.js
/**
* creates a hook to control style singleton
* @see {@link styleSingleton} for a safer component version
* @example
* ```tsx
* const useStyle = styleHookSingleton();
* ///
* useStyle('body { overflow: hidden}');
*/
var styleHookSingleton = function() {
	var sheet = stylesheetSingleton();
	return function(styles, isDynamic) {
		import_react.useEffect(function() {
			sheet.add(styles);
			return function() {
				sheet.remove();
			};
		}, [styles && isDynamic]);
	};
};

//#endregion
//#region node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.6_react@19.1.0/node_modules/react-style-singleton/dist/es2015/component.js
/**
* create a Component to add styles on demand
* - styles are added when first instance is mounted
* - styles are removed when the last instance is unmounted
* - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
*/
var styleSingleton = function() {
	var useStyle = styleHookSingleton();
	var Sheet = function(_a) {
		var styles = _a.styles, dynamic = _a.dynamic;
		useStyle(styles, dynamic);
		return null;
	};
	return Sheet;
};

//#endregion
//#region node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
	left: 0,
	top: 0,
	right: 0,
	gap: 0
};
var parse = function(x) {
	return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
	var cs = window.getComputedStyle(document.body);
	var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
	var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
	var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
	return [
		parse(left),
		parse(top),
		parse(right)
	];
};
var getGapWidth = function(gapMode) {
	if (gapMode === void 0) gapMode = "margin";
	if (typeof window === "undefined") return zeroGap;
	var offsets = getOffset(gapMode);
	var documentWidth = document.documentElement.clientWidth;
	var windowWidth = window.innerWidth;
	return {
		left: offsets[0],
		top: offsets[1],
		right: offsets[2],
		gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
	};
};

//#endregion
//#region node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
	var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
	if (gapMode === void 0) gapMode = "margin";
	return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
		allowRelative && "position: relative ".concat(important, ";"),
		gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
		gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
	].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
	var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
	return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
	import_react.useEffect(function() {
		document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
		return function() {
			var newCounter = getCurrentUseCounter() - 1;
			if (newCounter <= 0) document.body.removeAttribute(lockAttribute);
			else document.body.setAttribute(lockAttribute, newCounter.toString());
		};
	}, []);
};
/**
* Removes page scrollbar and blocks page scroll when mounted
*/
var RemoveScrollBar = function(_a) {
	var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
	useLockAttribute();
	var gap = import_react.useMemo(function() {
		return getGapWidth(gapMode);
	}, [gapMode]);
	return import_react.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") try {
	var options = Object.defineProperty({}, "passive", { get: function() {
		passiveSupported = true;
		return true;
	} });
	window.addEventListener("test", options, options);
	window.removeEventListener("test", options, options);
} catch (err) {
	passiveSupported = false;
}
var nonPassive = passiveSupported ? { passive: false } : false;

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
	return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
	if (!(node instanceof Element)) return false;
	var styles = window.getComputedStyle(node);
	return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node) {
	return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
	return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
	var ownerDocument = node.ownerDocument;
	var current = node;
	do {
		if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) current = current.host;
		var isScrollable = elementCouldBeScrolled(axis, current);
		if (isScrollable) {
			var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
			if (scrollHeight > clientHeight) return true;
		}
		current = current.parentNode;
	} while (current && current !== ownerDocument.body);
	return false;
};
var getVScrollVariables = function(_a) {
	var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
	return [
		scrollTop,
		scrollHeight,
		clientHeight
	];
};
var getHScrollVariables = function(_a) {
	var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
	return [
		scrollLeft,
		scrollWidth,
		clientWidth
	];
};
var elementCouldBeScrolled = function(axis, node) {
	return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
	return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
	/**
	* If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
	* and then increasingly negative as you scroll towards the end of the content.
	* @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
	*/
	return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
	var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
	var delta = directionFactor * sourceDelta;
	var target = event.target;
	var targetInLock = endTarget.contains(target);
	var shouldCancelScroll = false;
	var isDeltaPositive = delta > 0;
	var availableScroll = 0;
	var availableScrollTop = 0;
	do {
		var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
		var elementScroll = scroll_1 - capacity - directionFactor * position;
		if (position || elementScroll) {
			if (elementCouldBeScrolled(axis, target)) {
				availableScroll += elementScroll;
				availableScrollTop += position;
			}
		}
		target = target.parentNode.host || target.parentNode;
	} while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
	if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) shouldCancelScroll = true;
	else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) shouldCancelScroll = true;
	return shouldCancelScroll;
};

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
	return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
	return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
	return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
	return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
	return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
	var shouldPreventQueue = import_react.useRef([]);
	var touchStartRef = import_react.useRef([0, 0]);
	var activeAxis = import_react.useRef();
	var id = import_react.useState(idCounter++)[0];
	var Style$1 = import_react.useState(styleSingleton)[0];
	var lastProps = import_react.useRef(props);
	import_react.useEffect(function() {
		lastProps.current = props;
	}, [props]);
	import_react.useEffect(function() {
		if (props.inert) {
			document.body.classList.add("block-interactivity-".concat(id));
			var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
			allow_1.forEach(function(el) {
				return el.classList.add("allow-interactivity-".concat(id));
			});
			return function() {
				document.body.classList.remove("block-interactivity-".concat(id));
				allow_1.forEach(function(el) {
					return el.classList.remove("allow-interactivity-".concat(id));
				});
			};
		}
		return;
	}, [
		props.inert,
		props.lockRef.current,
		props.shards
	]);
	var shouldCancelEvent = import_react.useCallback(function(event, parent) {
		if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) return !lastProps.current.allowPinchZoom;
		var touch = getTouchXY(event);
		var touchStart = touchStartRef.current;
		var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
		var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
		var currentAxis;
		var target = event.target;
		var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
		if ("touches" in event && moveDirection === "h" && target.type === "range") return false;
		var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
		if (!canBeScrolledInMainDirection) return true;
		if (canBeScrolledInMainDirection) currentAxis = moveDirection;
		else {
			currentAxis = moveDirection === "v" ? "h" : "v";
			canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
		}
		if (!canBeScrolledInMainDirection) return false;
		if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) activeAxis.current = currentAxis;
		if (!currentAxis) return true;
		var cancelingAxis = activeAxis.current || currentAxis;
		return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
	}, []);
	var shouldPrevent = import_react.useCallback(function(_event) {
		var event = _event;
		if (!lockStack.length || lockStack[lockStack.length - 1] !== Style$1) return;
		var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
		var sourceEvent = shouldPreventQueue.current.filter(function(e) {
			return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
		})[0];
		if (sourceEvent && sourceEvent.should) {
			if (event.cancelable) event.preventDefault();
			return;
		}
		if (!sourceEvent) {
			var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
				return node.contains(event.target);
			});
			var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
			if (shouldStop) {
				if (event.cancelable) event.preventDefault();
			}
		}
	}, []);
	var shouldCancel = import_react.useCallback(function(name, delta, target, should) {
		var event = {
			name,
			delta,
			target,
			should,
			shadowParent: getOutermostShadowParent(target)
		};
		shouldPreventQueue.current.push(event);
		setTimeout(function() {
			shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
				return e !== event;
			});
		}, 1);
	}, []);
	var scrollTouchStart = import_react.useCallback(function(event) {
		touchStartRef.current = getTouchXY(event);
		activeAxis.current = void 0;
	}, []);
	var scrollWheel = import_react.useCallback(function(event) {
		shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
	}, []);
	var scrollTouchMove = import_react.useCallback(function(event) {
		shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
	}, []);
	import_react.useEffect(function() {
		lockStack.push(Style$1);
		props.setCallbacks({
			onScrollCapture: scrollWheel,
			onWheelCapture: scrollWheel,
			onTouchMoveCapture: scrollTouchMove
		});
		document.addEventListener("wheel", shouldPrevent, nonPassive);
		document.addEventListener("touchmove", shouldPrevent, nonPassive);
		document.addEventListener("touchstart", scrollTouchStart, nonPassive);
		return function() {
			lockStack = lockStack.filter(function(inst) {
				return inst !== Style$1;
			});
			document.removeEventListener("wheel", shouldPrevent, nonPassive);
			document.removeEventListener("touchmove", shouldPrevent, nonPassive);
			document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
		};
	}, []);
	var removeScrollBar = props.removeScrollBar, inert = props.inert;
	return import_react.createElement(import_react.Fragment, null, inert ? import_react.createElement(Style$1, { styles: generateStyle(id) }) : null, removeScrollBar ? import_react.createElement(RemoveScrollBar, {
		noRelative: props.noRelative,
		gapMode: props.gapMode
	}) : null);
}
function getOutermostShadowParent(node) {
	var shadowParent = null;
	while (node !== null) {
		if (node instanceof ShadowRoot) {
			shadowParent = node.host;
			node = node.host;
		}
		node = node.parentNode;
	}
	return shadowParent;
}

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

//#endregion
//#region node_modules/.pnpm/react-remove-scroll@2.7.0_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = import_react.forwardRef(function(props, ref) {
	return import_react.createElement(RemoveScroll, __assign({}, props, {
		ref,
		sideCar: sidecar_default
	}));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/keys/keys.mjs
function keys(object) {
	return Object.keys(object);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/deep-merge/deep-merge.mjs
function isObject(item) {
	return item && typeof item === "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
	const result = { ...target };
	const _source = source;
	if (isObject(target) && isObject(source)) Object.keys(source).forEach((key) => {
		if (isObject(_source[key])) if (!(key in target)) result[key] = _source[key];
		else result[key] = deepMerge(result[key], _source[key]);
		else result[key] = _source[key];
	});
	return result;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/camel-to-kebab-case/camel-to-kebab-case.mjs
function camelToKebabCase(value) {
	return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/units-converters/px.mjs
function getTransformedScaledValue(value) {
	if (typeof value !== "string" || !value.includes("var(--mantine-scale)")) return value;
	return value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px(value) {
	const transformedValue = getTransformedScaledValue(value);
	if (typeof transformedValue === "number") return transformedValue;
	if (typeof transformedValue === "string") {
		if (transformedValue.includes("calc") || transformedValue.includes("var")) return transformedValue;
		if (transformedValue.includes("px")) return Number(transformedValue.replace("px", ""));
		if (transformedValue.includes("rem")) return Number(transformedValue.replace("rem", "")) * 16;
		if (transformedValue.includes("em")) return Number(transformedValue.replace("em", "")) * 16;
		return Number(transformedValue);
	}
	return NaN;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/units-converters/rem.mjs
function scaleRem(remValue) {
	if (remValue === "0rem") return "0rem";
	return `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = false } = {}) {
	function converter(value) {
		if (value === 0 || value === "0") return `0${units}`;
		if (typeof value === "number") {
			const val = `${value / 16}${units}`;
			return shouldScale ? scaleRem(val) : val;
		}
		if (typeof value === "string") {
			if (value === "") return value;
			if (value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba(")) return value;
			if (value.includes(",")) return value.split(",").map((val) => converter(val)).join(",");
			if (value.includes(" ")) return value.split(" ").map((val) => converter(val)).join(" ");
			const replaced = value.replace("px", "");
			if (!Number.isNaN(Number(replaced))) {
				const val = `${Number(replaced) / 16}${units}`;
				return shouldScale ? scaleRem(val) : val;
			}
		}
		return value;
	}
	return converter;
}
const rem = createConverter("rem", { shouldScale: true });
const em = createConverter("em");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/filter-props/filter-props.mjs
function filterProps(props) {
	return Object.keys(props).reduce((acc, key) => {
		if (props[key] !== void 0) acc[key] = props[key];
		return acc;
	}, {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/is-number-like/is-number-like.mjs
function isNumberLike(value) {
	if (typeof value === "number") return true;
	if (typeof value === "string") {
		if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "") return true;
		const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
		const values$1 = value.trim().split(/\s+/);
		return values$1.every((val) => cssUnitsRegex.test(val));
	}
	return false;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/is-element/is-element.mjs
function isElement(value) {
	if (Array.isArray(value) || value === null) return false;
	if (typeof value === "object") {
		if (value.type === import_react.Fragment) return false;
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/create-safe-context/create-safe-context.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSafeContext(errorMessage) {
	const Context = (0, import_react.createContext)(null);
	const useSafeContext = () => {
		const ctx = (0, import_react.useContext)(Context);
		if (ctx === null) throw new Error(errorMessage);
		return ctx;
	};
	const Provider = ({ children, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, {
		value,
		children
	});
	return [Provider, useSafeContext];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/create-optional-context/create-optional-context.mjs
function createOptionalContext(initialValue = null) {
	const Context = (0, import_react.createContext)(initialValue);
	const useOptionalContext = () => (0, import_react.useContext)(Context);
	const Provider = ({ children, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, {
		value,
		children
	});
	return [Provider, useOptionalContext];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-safe-id/get-safe-id.mjs
function getSafeId(uid, errorMessage) {
	return (value) => {
		if (typeof value !== "string" || value.trim().length === 0) throw new Error(errorMessage);
		return `${uid}-${value}`;
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/find-element-ancestor/find-element-ancestor.mjs
function findElementAncestor(element, selector) {
	let _element = element;
	while ((_element = _element.parentElement) && !_element.matches(selector));
	return _element;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/create-scoped-keydown-handler/create-scoped-keydown-handler.mjs
function getPreviousIndex$2(current, elements, loop) {
	for (let i = current - 1; i >= 0; i -= 1) if (!elements[i].disabled) return i;
	if (loop) {
		for (let i = elements.length - 1; i > -1; i -= 1) if (!elements[i].disabled) return i;
	}
	return current;
}
function getNextIndex$2(current, elements, loop) {
	for (let i = current + 1; i < elements.length; i += 1) if (!elements[i].disabled) return i;
	if (loop) {
		for (let i = 0; i < elements.length; i += 1) if (!elements[i].disabled) return i;
	}
	return current;
}
function onSameLevel(target, sibling, parentSelector) {
	return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({ parentSelector, siblingSelector, onKeyDown, loop = true, activateOnFocus = false, dir = "rtl", orientation }) {
	return (event) => {
		onKeyDown?.(event);
		const elements = Array.from(findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(siblingSelector) || []).filter((node) => onSameLevel(event.currentTarget, node, parentSelector));
		const current = elements.findIndex((el) => event.currentTarget === el);
		const _nextIndex = getNextIndex$2(current, elements, loop);
		const _previousIndex = getPreviousIndex$2(current, elements, loop);
		const nextIndex = dir === "rtl" ? _previousIndex : _nextIndex;
		const previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
		switch (event.key) {
			case "ArrowRight": {
				if (orientation === "horizontal") {
					event.stopPropagation();
					event.preventDefault();
					elements[nextIndex].focus();
					activateOnFocus && elements[nextIndex].click();
				}
				break;
			}
			case "ArrowLeft": {
				if (orientation === "horizontal") {
					event.stopPropagation();
					event.preventDefault();
					elements[previousIndex].focus();
					activateOnFocus && elements[previousIndex].click();
				}
				break;
			}
			case "ArrowUp": {
				if (orientation === "vertical") {
					event.stopPropagation();
					event.preventDefault();
					elements[_previousIndex].focus();
					activateOnFocus && elements[_previousIndex].click();
				}
				break;
			}
			case "ArrowDown": {
				if (orientation === "vertical") {
					event.stopPropagation();
					event.preventDefault();
					elements[_nextIndex].focus();
					activateOnFocus && elements[_nextIndex].click();
				}
				break;
			}
			case "Home": {
				event.stopPropagation();
				event.preventDefault();
				!elements[0].disabled && elements[0].focus();
				break;
			}
			case "End": {
				event.stopPropagation();
				event.preventDefault();
				const last = elements.length - 1;
				!elements[last].disabled && elements[last].focus();
				break;
			}
		}
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-default-z-index/get-default-z-index.mjs
const elevations = {
	app: 100,
	modal: 200,
	popover: 300,
	overlay: 400,
	max: 9999
};
function getDefaultZIndex(level) {
	return elevations[level];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/noop/noop.mjs
const noop = () => {};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/close-on-escape/close-on-escape.mjs
function closeOnEscape(callback, options$1 = { active: true }) {
	if (typeof callback !== "function" || !options$1.active) return options$1.onKeyDown || noop;
	return (event) => {
		if (event.key === "Escape") {
			callback(event);
			options$1.onTrigger?.();
		}
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-size/get-size.mjs
function getSize(size$3, prefix = "size", convertToRem = true) {
	if (size$3 === void 0) return void 0;
	return isNumberLike(size$3) ? convertToRem ? rem(size$3) : size$3 : `var(--${prefix}-${size$3})`;
}
function getSpacing(size$3) {
	return getSize(size$3, "mantine-spacing");
}
function getRadius(size$3) {
	if (size$3 === void 0) return "var(--mantine-radius-default)";
	return getSize(size$3, "mantine-radius");
}
function getFontSize(size$3) {
	return getSize(size$3, "mantine-font-size");
}
function getLineHeight(size$3) {
	return getSize(size$3, "mantine-line-height", false);
}
function getShadow(size$3) {
	if (!size$3) return void 0;
	return getSize(size$3, "mantine-shadow", false);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/create-event-handler/create-event-handler.mjs
function createEventHandler(parentEventHandler, eventHandler) {
	return (event) => {
		parentEventHandler?.(event);
		eventHandler?.(event);
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-breakpoint-value/get-breakpoint-value.mjs
function getBreakpointValue(breakpoint, breakpoints) {
	if (breakpoint in breakpoints) return px(breakpoints[breakpoint]);
	return px(breakpoint);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-sorted-breakpoints/get-sorted-breakpoints.mjs
function getSortedBreakpoints(values$1, breakpoints) {
	const convertedBreakpoints = values$1.map((breakpoint) => ({
		value: breakpoint,
		px: getBreakpointValue(breakpoint, breakpoints)
	}));
	convertedBreakpoints.sort((a, b) => a.px - b.px);
	return convertedBreakpoints;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-base-value/get-base-value.mjs
function getBaseValue(value) {
	if (typeof value === "object" && value !== null) {
		if ("base" in value) return value.base;
		return void 0;
	}
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-context-item-index/get-context-item-index.mjs
function getContextItemIndex(elementSelector, parentSelector, node) {
	if (!node) return null;
	return Array.from(findElementAncestor(node, parentSelector)?.querySelectorAll(elementSelector) || []).findIndex((element) => element === node);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/use-hovered/use-hovered.mjs
function useHovered() {
	const [hovered, setHovered] = (0, import_react.useState)(-1);
	const resetHovered = () => setHovered(-1);
	return [hovered, {
		setHovered,
		resetHovered
	}];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/create-use-external-events/create-use-external-events.mjs
function dispatchEvent(type, detail) {
	window.dispatchEvent(new CustomEvent(type, { detail }));
}
function createUseExternalEvents(prefix) {
	function _useExternalEvents(events) {
		const handlers = Object.keys(events).reduce((acc, eventKey) => {
			acc[`${prefix}:${eventKey}`] = (event) => events[eventKey](event.detail);
			return acc;
		}, {});
		useIsomorphicEffect(() => {
			Object.keys(handlers).forEach((eventKey) => {
				window.removeEventListener(eventKey, handlers[eventKey]);
				window.addEventListener(eventKey, handlers[eventKey]);
			});
			return () => Object.keys(handlers).forEach((eventKey) => {
				window.removeEventListener(eventKey, handlers[eventKey]);
			});
		}, [handlers]);
	}
	function createEvent(event) {
		return (...payload) => dispatchEvent(`${prefix}:${String(event)}`, payload[0]);
	}
	return [_useExternalEvents, createEvent];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-env/get-env.mjs
function getEnv() {
	if (typeof process !== "undefined" && process.env && "development") return "development";
	return "development";
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/memoize/memoize.mjs
function memoize(func) {
	const cache = /* @__PURE__ */ new Map();
	return (...args) => {
		const key = JSON.stringify(args);
		if (cache.has(key)) return cache.get(key);
		const result = func(...args);
		cache.set(key, result);
		return result;
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/find-closest-number/find-closest-number.mjs
function findClosestNumber(value, numbers) {
	if (numbers.length === 0) return value;
	return numbers.reduce((prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/utils/get-ref-prop/get-ref-prop.mjs
function getRefProp(element) {
	const version = import_react.default.version;
	if (typeof import_react.default.version !== "string") return element?.ref;
	if (version.startsWith("18.")) return element?.ref;
	return element?.props?.ref;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/create-vars-resolver/create-vars-resolver.mjs
function createVarsResolver(resolver) {
	return resolver;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/resolve-class-names/resolve-class-names.mjs
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
	const merged = {};
	objects.forEach((obj) => {
		Object.entries(obj).forEach(([key, value]) => {
			if (merged[key]) merged[key] = clsx_default(merged[key], value);
			else merged[key] = value;
		});
	});
	return merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
	const arrayClassNames = Array.isArray(classNames) ? classNames : [classNames];
	const resolvedClassNames = arrayClassNames.map((item) => typeof item === "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES);
	return mergeClassNames(resolvedClassNames);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-styles/resolve-styles.mjs
function resolveStyles({ theme, styles, props, stylesCtx }) {
	const arrayStyles = Array.isArray(styles) ? styles : [styles];
	return arrayStyles.reduce((acc, style) => {
		if (typeof style === "function") return {
			...acc,
			...style(theme, props, stylesCtx)
		};
		return {
			...acc,
			...style
		};
	}, {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/Mantine.context.mjs
const MantineContext = (0, import_react.createContext)(null);
function useMantineContext() {
	const ctx = (0, import_react.useContext)(MantineContext);
	if (!ctx) throw new Error("[@mantine/core] MantineProvider was not found in tree");
	return ctx;
}
function useMantineCssVariablesResolver() {
	return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
	return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
	return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
	return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
	return useMantineContext().headless;
}
function useMantineSxTransform() {
	return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
	return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
	return useMantineContext().env || "default";
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/to-rgba/to-rgba.mjs
function isHexColor(hex) {
	const HEX_REGEXP = /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i;
	return HEX_REGEXP.test(hex);
}
function hexToRgba(color) {
	let hexString = color.replace("#", "");
	if (hexString.length === 3) {
		const shorthandHex = hexString.split("");
		hexString = [
			shorthandHex[0],
			shorthandHex[0],
			shorthandHex[1],
			shorthandHex[1],
			shorthandHex[2],
			shorthandHex[2]
		].join("");
	}
	if (hexString.length === 8) {
		const alpha$1 = parseInt(hexString.slice(6, 8), 16) / 255;
		return {
			r: parseInt(hexString.slice(0, 2), 16),
			g: parseInt(hexString.slice(2, 4), 16),
			b: parseInt(hexString.slice(4, 6), 16),
			a: alpha$1
		};
	}
	const parsed = parseInt(hexString, 16);
	const r$1 = parsed >> 16 & 255;
	const g = parsed >> 8 & 255;
	const b = parsed & 255;
	return {
		r: r$1,
		g,
		b,
		a: 1
	};
}
function rgbStringToRgba(color) {
	const [r$1, g, b, a] = color.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
	return {
		r: r$1,
		g,
		b,
		a: a || 1
	};
}
function hslStringToRgba(hslaString) {
	const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i;
	const matches$1 = hslaString.match(hslaRegex);
	if (!matches$1) return {
		r: 0,
		g: 0,
		b: 0,
		a: 1
	};
	const h = parseInt(matches$1[1], 10);
	const s = parseInt(matches$1[2], 10) / 100;
	const l = parseInt(matches$1[3], 10) / 100;
	const a = matches$1[5] ? parseFloat(matches$1[5]) : void 0;
	const chroma = (1 - Math.abs(2 * l - 1)) * s;
	const huePrime = h / 60;
	const x = chroma * (1 - Math.abs(huePrime % 2 - 1));
	const m = l - chroma / 2;
	let r$1;
	let g;
	let b;
	if (huePrime >= 0 && huePrime < 1) {
		r$1 = chroma;
		g = x;
		b = 0;
	} else if (huePrime >= 1 && huePrime < 2) {
		r$1 = x;
		g = chroma;
		b = 0;
	} else if (huePrime >= 2 && huePrime < 3) {
		r$1 = 0;
		g = chroma;
		b = x;
	} else if (huePrime >= 3 && huePrime < 4) {
		r$1 = 0;
		g = x;
		b = chroma;
	} else if (huePrime >= 4 && huePrime < 5) {
		r$1 = x;
		g = 0;
		b = chroma;
	} else {
		r$1 = chroma;
		g = 0;
		b = x;
	}
	return {
		r: Math.round((r$1 + m) * 255),
		g: Math.round((g + m) * 255),
		b: Math.round((b + m) * 255),
		a: a || 1
	};
}
function toRgba(color) {
	if (isHexColor(color)) return hexToRgba(color);
	if (color.startsWith("rgb")) return rgbStringToRgba(color);
	if (color.startsWith("hsl")) return hslStringToRgba(color);
	return {
		r: 0,
		g: 0,
		b: 0,
		a: 1
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/darken/darken.mjs
function darken(color, alpha$1) {
	if (color.startsWith("var(")) return `color-mix(in srgb, ${color}, black ${alpha$1 * 100}%)`;
	const { r: r$1, g, b, a } = toRgba(color);
	const f = 1 - alpha$1;
	const dark = (input) => Math.round(input * f);
	return `rgba(${dark(r$1)}, ${dark(g)}, ${dark(b)}, ${a})`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-primary-shade/get-primary-shade.mjs
function getPrimaryShade(theme, colorScheme) {
	if (typeof theme.primaryShade === "number") return theme.primaryShade;
	if (colorScheme === "dark") return theme.primaryShade.dark;
	return theme.primaryShade.light;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/luminance/luminance.mjs
function gammaCorrect(c) {
	return c <= .03928 ? c / 12.92 : ((c + .055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
	const match = oklchColor.match(/oklch\((.*?)%\s/);
	return match ? parseFloat(match[1]) : null;
}
function luminance(color) {
	if (color.startsWith("oklch(")) return (getLightnessFromOklch(color) || 0) / 100;
	const { r: r$1, g, b } = toRgba(color);
	const sR = r$1 / 255;
	const sG = g / 255;
	const sB = b / 255;
	const rLinear = gammaCorrect(sR);
	const gLinear = gammaCorrect(sG);
	const bLinear = gammaCorrect(sB);
	return .2126 * rLinear + .7152 * gLinear + .0722 * bLinear;
}
function isLightColor(color, luminanceThreshold = .179) {
	if (color.startsWith("var(")) return false;
	return luminance(color) > luminanceThreshold;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/parse-theme-color/parse-theme-color.mjs
function parseThemeColor({ color, theme, colorScheme }) {
	if (typeof color !== "string") throw new Error(`[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color}`);
	if (color === "bright") return {
		color,
		value: colorScheme === "dark" ? theme.white : theme.black,
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(colorScheme === "dark" ? theme.white : theme.black, theme.luminanceThreshold),
		variable: "--mantine-color-bright"
	};
	if (color === "dimmed") return {
		color,
		value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6], theme.luminanceThreshold),
		variable: "--mantine-color-dimmed"
	};
	if (color === "white" || color === "black") return {
		color,
		value: color === "white" ? theme.white : theme.black,
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(color === "white" ? theme.white : theme.black, theme.luminanceThreshold),
		variable: `--mantine-color-${color}`
	};
	const [_color, shade] = color.split(".");
	const colorShade = shade ? Number(shade) : void 0;
	const isThemeColor = _color in theme.colors;
	if (isThemeColor) {
		const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
		return {
			color: _color,
			value: colorValue,
			shade: colorShade,
			isThemeColor,
			isLight: isLightColor(colorValue, theme.luminanceThreshold),
			variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
		};
	}
	return {
		color,
		value: color,
		isThemeColor,
		isLight: isLightColor(color, theme.luminanceThreshold),
		shade: colorShade,
		variable: void 0
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs
function getThemeColor(color, theme) {
	const parsed = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	return parsed.variable ? `var(${parsed.variable})` : color;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-gradient/get-gradient.mjs
function getGradient(gradient, theme) {
	const merged = {
		from: gradient?.from || theme.defaultGradient.from,
		to: gradient?.to || theme.defaultGradient.to,
		deg: gradient?.deg ?? theme.defaultGradient.deg ?? 0
	};
	const fromColor = getThemeColor(merged.from, theme);
	const toColor = getThemeColor(merged.to, theme);
	return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/rgba/rgba.mjs
function rgba(color, alpha2) {
	if (typeof color !== "string" || alpha2 > 1 || alpha2 < 0) return "rgba(0, 0, 0, 1)";
	if (color.startsWith("var(")) {
		const mixPercentage = (1 - alpha2) * 100;
		return `color-mix(in srgb, ${color}, transparent ${mixPercentage}%)`;
	}
	if (color.startsWith("oklch")) {
		if (color.includes("/")) return color.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`);
		return color.replace(")", ` / ${alpha2})`);
	}
	const { r: r$1, g, b } = toRgba(color);
	return `rgba(${r$1}, ${g}, ${b}, ${alpha2})`;
}
const alpha = rgba;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/default-variant-colors-resolver/default-variant-colors-resolver.mjs
const defaultVariantColorsResolver = ({ color, theme, variant, gradient, autoContrast }) => {
	const parsed = parseThemeColor({
		color,
		theme
	});
	const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
	if (variant === "none") return {
		background: "transparent",
		hover: "transparent",
		color: "inherit",
		border: "none"
	};
	if (variant === "filled") {
		const textColor = _autoContrast ? parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" : "var(--mantine-color-white)";
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: `var(--mantine-color-${color}-filled)`,
				hover: `var(--mantine-color-${color}-filled-hover)`,
				color: textColor,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
				color: textColor,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: color,
			hover: darken(color, .1),
			color: textColor,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "light") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: `var(--mantine-color-${color}-light)`,
				hover: `var(--mantine-color-${color}-light-hover)`,
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			const parsedColor = theme.colors[parsed.color][parsed.shade];
			return {
				background: rgba(parsedColor, .1),
				hover: rgba(parsedColor, .12),
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: rgba(color, .1),
			hover: rgba(color, .12),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "outline") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: `var(--mantine-color-${color}-outline-hover)`,
				color: `var(--mantine-color-${color}-outline)`,
				border: `${rem(1)} solid var(--mantine-color-${color}-outline)`
			};
			return {
				background: "transparent",
				hover: rgba(theme.colors[parsed.color][parsed.shade], .05),
				color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
			};
		}
		return {
			background: "transparent",
			hover: rgba(color, .05),
			color,
			border: `${rem(1)} solid ${color}`
		};
	}
	if (variant === "subtle") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: `var(--mantine-color-${color}-light-hover)`,
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			const parsedColor = theme.colors[parsed.color][parsed.shade];
			return {
				background: "transparent",
				hover: rgba(parsedColor, .12),
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "transparent",
			hover: rgba(color, .12),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "transparent") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: "transparent",
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: "transparent",
				hover: "transparent",
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "transparent",
			hover: "transparent",
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "white") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "var(--mantine-color-white)",
				hover: darken(theme.white, .01),
				color: `var(--mantine-color-${color}-filled)`,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: "var(--mantine-color-white)",
				hover: darken(theme.white, .01),
				color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "var(--mantine-color-white)",
			hover: darken(theme.white, .01),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "gradient") return {
		background: getGradient(gradient, theme),
		hover: getGradient(gradient, theme),
		color: "var(--mantine-color-white)",
		border: "none"
	};
	if (variant === "default") return {
		background: "var(--mantine-color-default)",
		hover: "var(--mantine-color-default-hover)",
		color: "var(--mantine-color-default-color)",
		border: `${rem(1)} solid var(--mantine-color-default-border)`
	};
	return {};
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/default-colors.mjs
const DEFAULT_COLORS = {
	dark: [
		"#C9C9C9",
		"#b8b8b8",
		"#828282",
		"#696969",
		"#424242",
		"#3b3b3b",
		"#2e2e2e",
		"#242424",
		"#1f1f1f",
		"#141414"
	],
	gray: [
		"#f8f9fa",
		"#f1f3f5",
		"#e9ecef",
		"#dee2e6",
		"#ced4da",
		"#adb5bd",
		"#868e96",
		"#495057",
		"#343a40",
		"#212529"
	],
	red: [
		"#fff5f5",
		"#ffe3e3",
		"#ffc9c9",
		"#ffa8a8",
		"#ff8787",
		"#ff6b6b",
		"#fa5252",
		"#f03e3e",
		"#e03131",
		"#c92a2a"
	],
	pink: [
		"#fff0f6",
		"#ffdeeb",
		"#fcc2d7",
		"#faa2c1",
		"#f783ac",
		"#f06595",
		"#e64980",
		"#d6336c",
		"#c2255c",
		"#a61e4d"
	],
	grape: [
		"#f8f0fc",
		"#f3d9fa",
		"#eebefa",
		"#e599f7",
		"#da77f2",
		"#cc5de8",
		"#be4bdb",
		"#ae3ec9",
		"#9c36b5",
		"#862e9c"
	],
	violet: [
		"#f3f0ff",
		"#e5dbff",
		"#d0bfff",
		"#b197fc",
		"#9775fa",
		"#845ef7",
		"#7950f2",
		"#7048e8",
		"#6741d9",
		"#5f3dc4"
	],
	indigo: [
		"#edf2ff",
		"#dbe4ff",
		"#bac8ff",
		"#91a7ff",
		"#748ffc",
		"#5c7cfa",
		"#4c6ef5",
		"#4263eb",
		"#3b5bdb",
		"#364fc7"
	],
	blue: [
		"#e7f5ff",
		"#d0ebff",
		"#a5d8ff",
		"#74c0fc",
		"#4dabf7",
		"#339af0",
		"#228be6",
		"#1c7ed6",
		"#1971c2",
		"#1864ab"
	],
	cyan: [
		"#e3fafc",
		"#c5f6fa",
		"#99e9f2",
		"#66d9e8",
		"#3bc9db",
		"#22b8cf",
		"#15aabf",
		"#1098ad",
		"#0c8599",
		"#0b7285"
	],
	teal: [
		"#e6fcf5",
		"#c3fae8",
		"#96f2d7",
		"#63e6be",
		"#38d9a9",
		"#20c997",
		"#12b886",
		"#0ca678",
		"#099268",
		"#087f5b"
	],
	green: [
		"#ebfbee",
		"#d3f9d8",
		"#b2f2bb",
		"#8ce99a",
		"#69db7c",
		"#51cf66",
		"#40c057",
		"#37b24d",
		"#2f9e44",
		"#2b8a3e"
	],
	lime: [
		"#f4fce3",
		"#e9fac8",
		"#d8f5a2",
		"#c0eb75",
		"#a9e34b",
		"#94d82d",
		"#82c91e",
		"#74b816",
		"#66a80f",
		"#5c940d"
	],
	yellow: [
		"#fff9db",
		"#fff3bf",
		"#ffec99",
		"#ffe066",
		"#ffd43b",
		"#fcc419",
		"#fab005",
		"#f59f00",
		"#f08c00",
		"#e67700"
	],
	orange: [
		"#fff4e6",
		"#ffe8cc",
		"#ffd8a8",
		"#ffc078",
		"#ffa94d",
		"#ff922b",
		"#fd7e14",
		"#f76707",
		"#e8590c",
		"#d9480f"
	]
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/default-theme.mjs
const DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji";
const DEFAULT_THEME = {
	scale: 1,
	fontSmoothing: true,
	focusRing: "auto",
	white: "#fff",
	black: "#000",
	colors: DEFAULT_COLORS,
	primaryShade: {
		light: 6,
		dark: 8
	},
	primaryColor: "blue",
	variantColorResolver: defaultVariantColorsResolver,
	autoContrast: false,
	luminanceThreshold: .3,
	fontFamily: DEFAULT_FONT_FAMILY,
	fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
	respectReducedMotion: false,
	cursorType: "default",
	defaultGradient: {
		from: "blue",
		to: "cyan",
		deg: 45
	},
	defaultRadius: "sm",
	activeClassName: "mantine-active",
	focusClassName: "",
	headings: {
		fontFamily: DEFAULT_FONT_FAMILY,
		fontWeight: "700",
		textWrap: "wrap",
		sizes: {
			h1: {
				fontSize: rem(34),
				lineHeight: "1.3"
			},
			h2: {
				fontSize: rem(26),
				lineHeight: "1.35"
			},
			h3: {
				fontSize: rem(22),
				lineHeight: "1.4"
			},
			h4: {
				fontSize: rem(18),
				lineHeight: "1.45"
			},
			h5: {
				fontSize: rem(16),
				lineHeight: "1.5"
			},
			h6: {
				fontSize: rem(14),
				lineHeight: "1.5"
			}
		}
	},
	fontSizes: {
		xs: rem(12),
		sm: rem(14),
		md: rem(16),
		lg: rem(18),
		xl: rem(20)
	},
	lineHeights: {
		xs: "1.4",
		sm: "1.45",
		md: "1.55",
		lg: "1.6",
		xl: "1.65"
	},
	radius: {
		xs: rem(2),
		sm: rem(4),
		md: rem(8),
		lg: rem(16),
		xl: rem(32)
	},
	spacing: {
		xs: rem(10),
		sm: rem(12),
		md: rem(16),
		lg: rem(20),
		xl: rem(32)
	},
	breakpoints: {
		xs: "36em",
		sm: "48em",
		md: "62em",
		lg: "75em",
		xl: "88em"
	},
	shadows: {
		xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
		sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(15)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
		md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(25)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
		lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(23)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
		xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(28)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
	},
	other: {},
	components: {}
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/is-mantine-color-scheme.mjs
function isMantineColorScheme(value) {
	return value === "auto" || value === "dark" || value === "light";
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/local-storage-manager.mjs
function localStorageColorSchemeManager({ key = "mantine-color-scheme-value" } = {}) {
	let handleStorageEvent;
	return {
		get: (defaultValue) => {
			if (typeof window === "undefined") return defaultValue;
			try {
				const storedColorScheme = window.localStorage.getItem(key);
				return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
			} catch {
				return defaultValue;
			}
		},
		set: (value) => {
			try {
				window.localStorage.setItem(key, value);
			} catch (error$1) {
				console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", error$1);
			}
		},
		subscribe: (onUpdate) => {
			handleStorageEvent = (event) => {
				if (event.storageArea === window.localStorage && event.key === key) isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
			};
			window.addEventListener("storage", handleStorageEvent);
		},
		unsubscribe: () => {
			window.removeEventListener("storage", handleStorageEvent);
		},
		clear: () => {
			window.localStorage.removeItem(key);
		}
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/merge-mantine-theme/merge-mantine-theme.mjs
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more â€“ https://mantine.dev/theming/colors/#primary-color";
const INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
	if (shade < 0 || shade > 9) return false;
	return parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
	if (!(theme.primaryColor in theme.colors)) throw new Error(INVALID_PRIMARY_COLOR_ERROR);
	if (typeof theme.primaryShade === "object") {
		if (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)) throw new Error(INVALID_PRIMARY_SHADE_ERROR);
	}
	if (typeof theme.primaryShade === "number" && !isValidPrimaryShade(theme.primaryShade)) throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
	if (!themeOverride) {
		validateMantineTheme(currentTheme);
		return currentTheme;
	}
	const result = deepMerge(currentTheme, themeOverride);
	if (themeOverride.fontFamily && !themeOverride.headings?.fontFamily) result.headings.fontFamily = themeOverride.fontFamily;
	validateMantineTheme(result);
	return result;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs
const MantineThemeContext = (0, import_react.createContext)(null);
const useSafeMantineTheme = () => (0, import_react.useContext)(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
	const ctx = (0, import_react.useContext)(MantineThemeContext);
	if (!ctx) throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app");
	return ctx;
}
function MantineThemeProvider({ theme, children, inherit = true }) {
	const parentTheme = useSafeMantineTheme();
	const mergedTheme = (0, import_react.useMemo)(() => mergeMantineTheme(inherit ? parentTheme : DEFAULT_THEME, theme), [
		theme,
		parentTheme,
		inherit
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineThemeContext.Provider, {
		value: mergedTheme,
		children
	});
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineClasses/MantineClasses.mjs
function MantineClasses() {
	const theme = useMantineTheme();
	const nonce = useMantineStyleNonce();
	const classes$87 = keys(theme.breakpoints).reduce((acc, breakpoint) => {
		const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px");
		const pxValue = px(theme.breakpoints[breakpoint]);
		const maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - .1}px` : em(pxValue - .1);
		const minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
		return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
	}, "");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": "classes",
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: classes$87 }
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/css-variables-object-to-string.mjs
function cssVariablesObjectToString(variables) {
	return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/wrap-with-selector.mjs
function wrapWithSelector(selectors, code) {
	const _selectors = Array.isArray(selectors) ? selectors : [selectors];
	return _selectors.reduce((acc, selector) => `${selector}{${acc}}`, code);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/convert-css-variables.mjs
function convertCssVariables(input, selector) {
	const sharedVariables = cssVariablesObjectToString(input.variables);
	const shared = sharedVariables ? wrapWithSelector(selector, sharedVariables) : "";
	const dark = cssVariablesObjectToString(input.dark);
	const light = cssVariablesObjectToString(input.light);
	const darkForced = dark ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="dark"])`, dark) : wrapWithSelector(`${selector}[data-mantine-color-scheme="dark"]`, dark) : "";
	const lightForced = light ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="light"])`, light) : wrapWithSelector(`${selector}[data-mantine-color-scheme="light"]`, light) : "";
	return `${shared}${darkForced}${lightForced}`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-contrast-color/get-contrast-color.mjs
function getContrastColor({ color, theme, autoContrast }) {
	const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
	if (!_autoContrast) return "var(--mantine-color-white)";
	const parsed = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	return parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
	return getContrastColor({
		color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
		theme,
		autoContrast: null
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-css-color-variables.mjs
function getCSSColorVariables({ theme, color, colorScheme, name = color, withColorValues = true }) {
	if (!theme.colors[color]) return {};
	if (colorScheme === "light") {
		const primaryShade2 = getPrimaryShade(theme, "light");
		const dynamicVariables2 = {
			[`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
			[`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
			[`--mantine-color-${name}-light`]: alpha(theme.colors[color][primaryShade2], .1),
			[`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][primaryShade2], .12),
			[`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][primaryShade2], .05)
		};
		if (!withColorValues) return dynamicVariables2;
		return {
			[`--mantine-color-${name}-0`]: theme.colors[color][0],
			[`--mantine-color-${name}-1`]: theme.colors[color][1],
			[`--mantine-color-${name}-2`]: theme.colors[color][2],
			[`--mantine-color-${name}-3`]: theme.colors[color][3],
			[`--mantine-color-${name}-4`]: theme.colors[color][4],
			[`--mantine-color-${name}-5`]: theme.colors[color][5],
			[`--mantine-color-${name}-6`]: theme.colors[color][6],
			[`--mantine-color-${name}-7`]: theme.colors[color][7],
			[`--mantine-color-${name}-8`]: theme.colors[color][8],
			[`--mantine-color-${name}-9`]: theme.colors[color][9],
			...dynamicVariables2
		};
	}
	const primaryShade = getPrimaryShade(theme, "dark");
	const dynamicVariables = {
		[`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
		[`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
		[`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
		[`--mantine-color-${name}-light`]: alpha(theme.colors[color][Math.max(0, primaryShade - 2)], .15),
		[`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][Math.max(0, primaryShade - 2)], .2),
		[`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
		[`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
		[`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][Math.max(primaryShade - 4, 0)], .05)
	};
	if (!withColorValues) return dynamicVariables;
	return {
		[`--mantine-color-${name}-0`]: theme.colors[color][0],
		[`--mantine-color-${name}-1`]: theme.colors[color][1],
		[`--mantine-color-${name}-2`]: theme.colors[color][2],
		[`--mantine-color-${name}-3`]: theme.colors[color][3],
		[`--mantine-color-${name}-4`]: theme.colors[color][4],
		[`--mantine-color-${name}-5`]: theme.colors[color][5],
		[`--mantine-color-${name}-6`]: theme.colors[color][6],
		[`--mantine-color-${name}-7`]: theme.colors[color][7],
		[`--mantine-color-${name}-8`]: theme.colors[color][8],
		[`--mantine-color-${name}-9`]: theme.colors[color][9],
		...dynamicVariables
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/colors-tuple/colors-tuple.mjs
function colorsTuple(input) {
	if (Array.isArray(input)) return input;
	return Array(10).fill(input);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/virtual-color/virtual-color.mjs
function virtualColor(input) {
	const result = colorsTuple(Array.from({ length: 10 }).map((_, i) => `var(--mantine-color-${input.name}-${i})`));
	Object.defineProperty(result, "mantine-virtual-color", {
		enumerable: false,
		writable: false,
		configurable: false,
		value: true
	});
	Object.defineProperty(result, "dark", {
		enumerable: false,
		writable: false,
		configurable: false,
		value: input.dark
	});
	Object.defineProperty(result, "light", {
		enumerable: false,
		writable: false,
		configurable: false,
		value: input.light
	});
	Object.defineProperty(result, "name", {
		enumerable: false,
		writable: false,
		configurable: false,
		value: input.name
	});
	return result;
}
function isVirtualColor(value) {
	return !!value && typeof value === "object" && "mantine-virtual-color" in value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/default-css-variables-resolver.mjs
function assignSizeVariables(variables, sizes$1, name) {
	keys(sizes$1).forEach((size$3) => Object.assign(variables, { [`--mantine-${name}-${size$3}`]: sizes$1[size$3] }));
}
const defaultCssVariablesResolver = (theme) => {
	const lightPrimaryShade = getPrimaryShade(theme, "light");
	const defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius);
	const result = {
		variables: {
			"--mantine-scale": theme.scale.toString(),
			"--mantine-cursor-type": theme.cursorType,
			"--mantine-color-scheme": "light dark",
			"--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
			"--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
			"--mantine-color-white": theme.white,
			"--mantine-color-black": theme.black,
			"--mantine-line-height": theme.lineHeights.md,
			"--mantine-font-family": theme.fontFamily,
			"--mantine-font-family-monospace": theme.fontFamilyMonospace,
			"--mantine-font-family-headings": theme.headings.fontFamily,
			"--mantine-heading-font-weight": theme.headings.fontWeight,
			"--mantine-heading-text-wrap": theme.headings.textWrap,
			"--mantine-radius-default": defaultRadius,
			"--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
			"--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
			"--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
			"--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
			"--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
		},
		light: {
			"--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
			"--mantine-color-bright": "var(--mantine-color-black)",
			"--mantine-color-text": theme.black,
			"--mantine-color-body": theme.white,
			"--mantine-color-error": "var(--mantine-color-red-6)",
			"--mantine-color-placeholder": "var(--mantine-color-gray-5)",
			"--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
			"--mantine-color-default": "var(--mantine-color-white)",
			"--mantine-color-default-hover": "var(--mantine-color-gray-0)",
			"--mantine-color-default-color": "var(--mantine-color-black)",
			"--mantine-color-default-border": "var(--mantine-color-gray-4)",
			"--mantine-color-dimmed": "var(--mantine-color-gray-6)",
			"--mantine-color-disabled": "var(--mantine-color-gray-2)",
			"--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
			"--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
		},
		dark: {
			"--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
			"--mantine-color-bright": "var(--mantine-color-white)",
			"--mantine-color-text": "var(--mantine-color-dark-0)",
			"--mantine-color-body": "var(--mantine-color-dark-7)",
			"--mantine-color-error": "var(--mantine-color-red-8)",
			"--mantine-color-placeholder": "var(--mantine-color-dark-3)",
			"--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
			"--mantine-color-default": "var(--mantine-color-dark-6)",
			"--mantine-color-default-hover": "var(--mantine-color-dark-5)",
			"--mantine-color-default-color": "var(--mantine-color-white)",
			"--mantine-color-default-border": "var(--mantine-color-dark-4)",
			"--mantine-color-dimmed": "var(--mantine-color-dark-2)",
			"--mantine-color-disabled": "var(--mantine-color-dark-6)",
			"--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
			"--mantine-color-disabled-border": "var(--mantine-color-gray-6)"
		}
	};
	assignSizeVariables(result.variables, theme.breakpoints, "breakpoint");
	assignSizeVariables(result.variables, theme.spacing, "spacing");
	assignSizeVariables(result.variables, theme.fontSizes, "font-size");
	assignSizeVariables(result.variables, theme.lineHeights, "line-height");
	assignSizeVariables(result.variables, theme.shadows, "shadow");
	assignSizeVariables(result.variables, theme.radius, "radius");
	theme.colors[theme.primaryColor].forEach((_, index$4) => {
		result.variables[`--mantine-primary-color-${index$4}`] = `var(--mantine-color-${theme.primaryColor}-${index$4})`;
	});
	keys(theme.colors).forEach((color) => {
		const value = theme.colors[color];
		if (isVirtualColor(value)) {
			Object.assign(result.light, getCSSColorVariables({
				theme,
				name: value.name,
				color: value.light,
				colorScheme: "light",
				withColorValues: true
			}));
			Object.assign(result.dark, getCSSColorVariables({
				theme,
				name: value.name,
				color: value.dark,
				colorScheme: "dark",
				withColorValues: true
			}));
			return;
		}
		value.forEach((shade, index$4) => {
			result.variables[`--mantine-color-${color}-${index$4}`] = shade;
		});
		Object.assign(result.light, getCSSColorVariables({
			theme,
			color,
			colorScheme: "light",
			withColorValues: false
		}));
		Object.assign(result.dark, getCSSColorVariables({
			theme,
			color,
			colorScheme: "dark",
			withColorValues: false
		}));
	});
	const headings$3 = theme.headings.sizes;
	keys(headings$3).forEach((heading) => {
		result.variables[`--mantine-${heading}-font-size`] = headings$3[heading].fontSize;
		result.variables[`--mantine-${heading}-line-height`] = headings$3[heading].lineHeight;
		result.variables[`--mantine-${heading}-font-weight`] = headings$3[heading].fontWeight || theme.headings.fontWeight;
	});
	return result;
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-merged-variables.mjs
function getMergedVariables({ theme, generator }) {
	const defaultResolver = defaultCssVariablesResolver(theme);
	const providerGenerator = generator?.(theme);
	return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/remove-default-variables.mjs
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
	const cleaned = {
		variables: {},
		light: {},
		dark: {}
	};
	keys(input.variables).forEach((key) => {
		if (defaultCssVariables.variables[key] !== input.variables[key]) cleaned.variables[key] = input.variables[key];
	});
	keys(input.light).forEach((key) => {
		if (defaultCssVariables.light[key] !== input.light[key]) cleaned.light[key] = input.light[key];
	});
	keys(input.dark).forEach((key) => {
		if (defaultCssVariables.dark[key] !== input.dark[key]) cleaned.dark[key] = input.dark[key];
	});
	return cleaned;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs
function getColorSchemeCssVariables(selector) {
	return `
  ${selector}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({ cssVariablesSelector, deduplicateCssVariables }) {
	const theme = useMantineTheme();
	const nonce = useMantineStyleNonce();
	const generator = useMantineCssVariablesResolver();
	const mergedVariables = getMergedVariables({
		theme,
		generator
	});
	const shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables;
	const cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables;
	const css = convertCssVariables(cleanedVariables, cssVariablesSelector);
	if (css) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": true,
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}` }
	});
	return null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-mantine-color-scheme/use-provider-color-scheme.mjs
function setColorSchemeAttribute(colorScheme, getRootElement) {
	const hasDarkColorScheme = typeof window !== "undefined" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches;
	const computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
	getRootElement()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({ manager, defaultColorScheme, getRootElement, forceColorScheme }) {
	const media = (0, import_react.useRef)(null);
	const [value, setValue] = (0, import_react.useState)(() => manager.get(defaultColorScheme));
	const colorSchemeValue = forceColorScheme || value;
	const setColorScheme = (0, import_react.useCallback)((colorScheme) => {
		if (!forceColorScheme) {
			setColorSchemeAttribute(colorScheme, getRootElement);
			setValue(colorScheme);
			manager.set(colorScheme);
		}
	}, [
		manager.set,
		colorSchemeValue,
		forceColorScheme
	]);
	const clearColorScheme = (0, import_react.useCallback)(() => {
		setValue(defaultColorScheme);
		setColorSchemeAttribute(defaultColorScheme, getRootElement);
		manager.clear();
	}, [manager.clear, defaultColorScheme]);
	(0, import_react.useEffect)(() => {
		manager.subscribe(setColorScheme);
		return manager.unsubscribe;
	}, [manager.subscribe, manager.unsubscribe]);
	useIsomorphicEffect(() => {
		setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
	}, []);
	(0, import_react.useEffect)(() => {
		if (forceColorScheme) {
			setColorSchemeAttribute(forceColorScheme, getRootElement);
			return () => {};
		}
		if (forceColorScheme === void 0) setColorSchemeAttribute(value, getRootElement);
		if (typeof window !== "undefined" && "matchMedia" in window) media.current = window.matchMedia("(prefers-color-scheme: dark)");
		const listener = (event) => {
			if (value === "auto") setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
		};
		media.current?.addEventListener("change", listener);
		return () => media.current?.removeEventListener("change", listener);
	}, [value, forceColorScheme]);
	return {
		colorScheme: colorSchemeValue,
		setColorScheme,
		clearColorScheme
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-respect-reduce-motion/use-respect-reduce-motion.mjs
function useRespectReduceMotion({ respectReducedMotion, getRootElement }) {
	useIsomorphicEffect(() => {
		if (respectReducedMotion) getRootElement()?.setAttribute("data-respect-reduced-motion", "true");
	}, [respectReducedMotion]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
function MantineProvider({ theme, children, getStyleNonce, withStaticClasses = true, withGlobalClasses = true, deduplicateCssVariables = true, withCssVariables = true, cssVariablesSelector = ":root", classNamesPrefix = "mantine", colorSchemeManager = localStorageColorSchemeManager(), defaultColorScheme = "light", getRootElement = () => document.documentElement, cssVariablesResolver, forceColorScheme, stylesTransform, env }) {
	const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
		defaultColorScheme,
		forceColorScheme,
		manager: colorSchemeManager,
		getRootElement
	});
	useRespectReduceMotion({
		respectReducedMotion: theme?.respectReducedMotion || false,
		getRootElement
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineContext.Provider, {
		value: {
			colorScheme,
			setColorScheme,
			clearColorScheme,
			getRootElement,
			classNamesPrefix,
			getStyleNonce,
			cssVariablesResolver,
			cssVariablesSelector,
			withStaticClasses,
			stylesTransform,
			env
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(MantineThemeProvider, {
			theme,
			children: [
				withCssVariables && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineCssVariables, {
					cssVariablesSelector,
					deduplicateCssVariables
				}),
				withGlobalClasses && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineClasses, {}),
				children
			]
		})
	});
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function HeadlessMantineProvider({ children, theme }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineContext.Provider, {
		value: {
			colorScheme: "auto",
			setColorScheme: () => {},
			clearColorScheme: () => {},
			getRootElement: () => document.documentElement,
			classNamesPrefix: "mantine",
			cssVariablesSelector: ":root",
			withStaticClasses: false,
			headless: true
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineThemeProvider, {
			theme,
			children
		})
	});
}
HeadlessMantineProvider.displayName = "@mantine/core/HeadlessMantineProvider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs
function useResolvedStylesApi({ classNames, styles, props, stylesCtx }) {
	const theme = useMantineTheme();
	return {
		resolvedClassNames: resolveClassNames({
			theme,
			classNames,
			props,
			stylesCtx: stylesCtx || void 0
		}),
		resolvedStyles: resolveStyles({
			theme,
			styles,
			props,
			stylesCtx: stylesCtx || void 0
		})
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-global-class-names/get-global-class-names.mjs
const FOCUS_CLASS_NAMES = {
	always: "mantine-focus-always",
	auto: "mantine-focus-auto",
	never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options: options$1, unstyled }) {
	return clsx_default(options$1?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]), options$1?.active && !unstyled && theme.activeClassName);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-options-class-names/get-options-class-names.mjs
function getOptionsClassNames({ selector, stylesCtx, options: options$1, props, theme }) {
	return resolveClassNames({
		theme,
		classNames: options$1?.classNames,
		props: options$1?.props || props,
		stylesCtx
	})[selector];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-resolved-class-names/get-resolved-class-names.mjs
function getResolvedClassNames({ selector, stylesCtx, theme, classNames, props }) {
	return resolveClassNames({
		theme,
		classNames,
		props,
		stylesCtx
	})[selector];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-root-class-name/get-root-class-name.mjs
function getRootClassName({ rootSelector, selector, className }) {
	return rootSelector === selector ? className : void 0;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-selector-class-name/get-selector-class-name.mjs
function getSelectorClassName({ selector, classes: classes$87, unstyled }) {
	return unstyled ? void 0 : classes$87[selector];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-static-class-names/get-static-class-names.mjs
function getStaticClassNames({ themeName, classNamesPrefix, selector, withStaticClass }) {
	if (withStaticClass === false) return [];
	return themeName.map((n) => `${classNamesPrefix}-${n}-${selector}`);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-theme-class-names/get-theme-class-names.mjs
function getThemeClassNames({ themeName, theme, selector, props, stylesCtx }) {
	return themeName.map((n) => resolveClassNames({
		theme,
		classNames: theme.components[n]?.classNames,
		props,
		stylesCtx
	})?.[selector]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-variant-class-name/get-variant-class-name.mjs
function getVariantClassName({ options: options$1, classes: classes$87, selector, unstyled }) {
	return options$1?.variant && !unstyled ? classes$87[`${selector}--${options$1.variant}`] : void 0;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-class-name.mjs
function getClassName({ theme, options: options$1, themeName, selector, classNamesPrefix, classNames, classes: classes$87, unstyled, className, rootSelector, props, stylesCtx, withStaticClasses, headless, transformedStyles }) {
	return clsx_default(getGlobalClassNames({
		theme,
		options: options$1,
		unstyled: unstyled || headless
	}), getThemeClassNames({
		theme,
		themeName,
		selector,
		props,
		stylesCtx
	}), getVariantClassName({
		options: options$1,
		classes: classes$87,
		selector,
		unstyled
	}), getResolvedClassNames({
		selector,
		stylesCtx,
		theme,
		classNames,
		props
	}), getResolvedClassNames({
		selector,
		stylesCtx,
		theme,
		classNames: transformedStyles,
		props
	}), getOptionsClassNames({
		selector,
		stylesCtx,
		options: options$1,
		props,
		theme
	}), getRootClassName({
		rootSelector,
		selector,
		className
	}), getSelectorClassName({
		selector,
		classes: classes$87,
		unstyled: unstyled || headless
	}), withStaticClasses && !headless && getStaticClassNames({
		themeName,
		classNamesPrefix,
		selector,
		withStaticClass: options$1?.withStaticClass
	}), options$1?.className);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-theme-styles/get-theme-styles.mjs
function getThemeStyles({ theme, themeName, props, stylesCtx, selector }) {
	return themeName.map((n) => resolveStyles({
		theme,
		styles: theme.components[n]?.styles,
		props,
		stylesCtx
	})[selector]).reduce((acc, val) => ({
		...acc,
		...val
	}), {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-style/resolve-style.mjs
function resolveStyle({ style, theme }) {
	if (Array.isArray(style)) return [...style].reduce((acc, item) => ({
		...acc,
		...resolveStyle({
			style: item,
			theme
		})
	}), {});
	if (typeof style === "function") return style(theme);
	if (style == null) return {};
	return style;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/merge-vars.mjs
function mergeVars(vars) {
	return vars.reduce((acc, current) => {
		if (current) Object.keys(current).forEach((key) => {
			acc[key] = {
				...acc[key],
				...filterProps(current[key])
			};
		});
		return acc;
	}, {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/resolve-vars.mjs
function resolveVars({ vars, varsResolver: varsResolver$90, theme, props, stylesCtx, selector, themeName, headless }) {
	return mergeVars([
		headless ? {} : varsResolver$90?.(theme, props, stylesCtx),
		...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
		vars?.(theme, props, stylesCtx)
	])?.[selector];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-style.mjs
function getStyle({ theme, themeName, selector, options: options$1, props, stylesCtx, rootSelector, styles, style, vars, varsResolver: varsResolver$90, headless, withStylesTransform }) {
	return {
		...!withStylesTransform && getThemeStyles({
			theme,
			themeName,
			props,
			stylesCtx,
			selector
		}),
		...!withStylesTransform && resolveStyles({
			theme,
			styles,
			props,
			stylesCtx
		})[selector],
		...!withStylesTransform && resolveStyles({
			theme,
			styles: options$1?.styles,
			props: options$1?.props || props,
			stylesCtx
		})[selector],
		...resolveVars({
			theme,
			props,
			stylesCtx,
			vars,
			varsResolver: varsResolver$90,
			selector,
			themeName,
			headless
		}),
		...rootSelector === selector ? resolveStyle({
			style,
			theme
		}) : null,
		...resolveStyle({
			style: options$1?.style,
			theme
		})
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/use-transformed-styles.mjs
function useStylesTransform({ props, stylesCtx, themeName }) {
	const theme = useMantineTheme();
	const stylesTransform = useMantineStylesTransform()?.();
	const getTransformedStyles = (styles) => {
		if (!stylesTransform) return [];
		const transformedStyles = styles.map((style) => stylesTransform(style, {
			props,
			theme,
			ctx: stylesCtx
		}));
		return [...transformedStyles, ...themeName.map((n) => stylesTransform(theme.components[n]?.styles, {
			props,
			theme,
			ctx: stylesCtx
		}))].filter(Boolean);
	};
	return {
		getTransformedStyles,
		withStylesTransform: !!stylesTransform
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/styles-api/use-styles/use-styles.mjs
function useStyles({ name, classes: classes$87, props, stylesCtx, className, style, rootSelector = "root", unstyled, classNames, styles, vars, varsResolver: varsResolver$90 }) {
	const theme = useMantineTheme();
	const classNamesPrefix = useMantineClassNamesPrefix();
	const withStaticClasses = useMantineWithStaticClasses();
	const headless = useMantineIsHeadless();
	const themeName = (Array.isArray(name) ? name : [name]).filter((n) => n);
	const { withStylesTransform, getTransformedStyles } = useStylesTransform({
		props,
		stylesCtx,
		themeName
	});
	return (selector, options$1) => ({
		className: getClassName({
			theme,
			options: options$1,
			themeName,
			selector,
			classNamesPrefix,
			classNames,
			classes: classes$87,
			unstyled,
			className,
			rootSelector,
			props,
			stylesCtx,
			withStaticClasses,
			headless,
			transformedStyles: getTransformedStyles([options$1?.styles, styles])
		}),
		style: getStyle({
			theme,
			themeName,
			selector,
			options: options$1,
			props,
			stylesCtx,
			rootSelector,
			styles,
			style,
			vars,
			varsResolver: varsResolver$90,
			headless,
			withStylesTransform
		})
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/lighten/lighten.mjs
function lighten(color, alpha$1) {
	if (color.startsWith("var(")) return `color-mix(in srgb, ${color}, white ${alpha$1 * 100}%)`;
	const { r: r$1, g, b, a } = toRgba(color);
	const light = (input) => Math.round(input + (255 - input) * alpha$1);
	return `rgba(${light(r$1)}, ${light(g)}, ${light(b)}, ${a})`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-auto-contrast-value/get-auto-contrast-value.mjs
function getAutoContrastValue(autoContrast, theme) {
	return typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-mantine-color-scheme/use-mantine-color-scheme.mjs
function disableTransition(nonce) {
	const style = document.createElement("style");
	style.setAttribute("data-mantine-styles", "inline");
	style.innerHTML = "*, *::before, *::after {transition: none !important;}";
	style.setAttribute("data-mantine-disable-transition", "true");
	nonce && style.setAttribute("nonce", nonce);
	document.head.appendChild(style);
	const clear = () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
	return clear;
}
function useMantineColorScheme({ keepTransitions } = {}) {
	const clearStylesRef = (0, import_react.useRef)(noop);
	const timeoutRef = (0, import_react.useRef)(-1);
	const ctx = (0, import_react.useContext)(MantineContext);
	const nonce = useMantineStyleNonce();
	const nonceValue = (0, import_react.useRef)(nonce?.());
	if (!ctx) throw new Error("[@mantine/core] MantineProvider was not found in tree");
	const setColorScheme = (value) => {
		ctx.setColorScheme(value);
		clearStylesRef.current = keepTransitions ? () => {} : disableTransition(nonceValue.current);
		window.clearTimeout(timeoutRef.current);
		timeoutRef.current = window.setTimeout(() => {
			clearStylesRef.current?.();
		}, 10);
	};
	const clearColorScheme = () => {
		ctx.clearColorScheme();
		clearStylesRef.current = keepTransitions ? () => {} : disableTransition(nonceValue.current);
		window.clearTimeout(timeoutRef.current);
		timeoutRef.current = window.setTimeout(() => {
			clearStylesRef.current?.();
		}, 10);
	};
	const osColorScheme = useColorScheme("light", { getInitialValueInEffect: false });
	const computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme;
	const toggleColorScheme = (0, import_react.useCallback)(() => setColorScheme(computedColorScheme === "light" ? "dark" : "light"), [setColorScheme, computedColorScheme]);
	(0, import_react.useEffect)(() => () => {
		clearStylesRef.current?.();
		window.clearTimeout(timeoutRef.current);
	}, []);
	return {
		colorScheme: ctx.colorScheme,
		setColorScheme,
		clearColorScheme,
		toggleColorScheme
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-mantine-color-scheme/use-computed-color-scheme.mjs
function useComputedColorScheme(defaultValue, options$1 = { getInitialValueInEffect: true }) {
	const osColorScheme = useColorScheme(defaultValue, options$1);
	const { colorScheme } = useMantineColorScheme();
	return colorScheme === "auto" ? osColorScheme : colorScheme;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/ColorSchemeScript/ColorSchemeScript.mjs
const getScript = ({ defaultColorScheme, localStorageKey, forceColorScheme }) => forceColorScheme ? `document.documentElement.setAttribute("data-mantine-color-scheme", '${forceColorScheme}');` : `try {
  var _colorScheme = window.localStorage.getItem("${localStorageKey}");
  var colorScheme = _colorScheme === "light" || _colorScheme === "dark" || _colorScheme === "auto" ? _colorScheme : "${defaultColorScheme}";
  var computedColorScheme = colorScheme !== "auto" ? colorScheme : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  document.documentElement.setAttribute("data-mantine-color-scheme", computedColorScheme);
} catch (e) {}
`;
function ColorSchemeScript({ defaultColorScheme = "light", localStorageKey = "mantine-color-scheme-value", forceColorScheme,...others }) {
	const _defaultColorScheme = [
		"light",
		"dark",
		"auto"
	].includes(defaultColorScheme) ? defaultColorScheme : "light";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		...others,
		"data-mantine-script": true,
		dangerouslySetInnerHTML: { __html: getScript({
			defaultColorScheme: _defaultColorScheme,
			localStorageKey,
			forceColorScheme
		}) }
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-props/use-props.mjs
function useProps(component, defaultProps$188, props) {
	const theme = useMantineTheme();
	const contextPropsPayload = theme.components[component]?.defaultProps;
	const contextProps = typeof contextPropsPayload === "function" ? contextPropsPayload(theme) : contextPropsPayload;
	return {
		...defaultProps$188,
		...contextProps,
		...filterProps(props)
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/create-theme/create-theme.mjs
function createTheme(theme) {
	return theme;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/merge-theme-overrides/merge-theme-overrides.mjs
function mergeThemeOverrides(...overrides) {
	return overrides.reduce((acc, override) => deepMerge(acc, override), {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/use-matches/use-matches.mjs
const BREAKPOINTS = [
	"xs",
	"sm",
	"md",
	"lg",
	"xl"
];
function getFirstMatchingValue(value, biggestMatch) {
	if (!biggestMatch) return value.base;
	let index$4 = BREAKPOINTS.indexOf(biggestMatch);
	while (index$4 >= 0) {
		if (BREAKPOINTS[index$4] in value) return value[BREAKPOINTS[index$4]];
		index$4 -= 1;
	}
	return value.base;
}
function getFirstMatchingBreakpoint(matches$1) {
	return matches$1.findLastIndex((v) => v);
}
function useMatches(payload, options$1) {
	const theme = useMantineTheme();
	const xsMatches = useMediaQuery(`(min-width: ${theme.breakpoints.xs})`, false, options$1);
	const smMatches = useMediaQuery(`(min-width: ${theme.breakpoints.sm})`, false, options$1);
	const mdMatches = useMediaQuery(`(min-width: ${theme.breakpoints.md})`, false, options$1);
	const lgMatches = useMediaQuery(`(min-width: ${theme.breakpoints.lg})`, false, options$1);
	const xlMatches = useMediaQuery(`(min-width: ${theme.breakpoints.xl})`, false, options$1);
	const breakpoints = [
		xsMatches,
		smMatches,
		mdMatches,
		lgMatches,
		xlMatches
	];
	const firstMatchingBreakpointIndex = getFirstMatchingBreakpoint(breakpoints);
	return getFirstMatchingValue(payload, BREAKPOINTS[firstMatchingBreakpointIndex]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/MantineProvider/mantine-html-props.mjs
const mantineHtmlProps = {
	suppressHydrationWarning: true,
	"data-mantine-color-scheme": "light"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/InlineStyles/css-object-to-string/css-object-to-string.mjs
function cssObjectToString(css) {
	return keys(css).reduce((acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc, "").trim();
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/InlineStyles/styles-to-string/styles-to-string.mjs
function stylesToString({ selector, styles, media, container }) {
	const baseStyles = styles ? cssObjectToString(styles) : "";
	const mediaQueryStyles = !Array.isArray(media) ? [] : media.map((item) => `@media${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
	const containerStyles = !Array.isArray(container) ? [] : container.map((item) => `@container ${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
	return `${baseStyles ? `${selector}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/InlineStyles/InlineStyles.mjs
function InlineStyles(props) {
	const nonce = useMantineStyleNonce();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": "inline",
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: stylesToString(props) }
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/extract-style-props/extract-style-props.mjs
function extractStyleProps(others) {
	const { m, mx, my, mt, mb, ml, mr, me, ms, p, px: px$1, py, pt, pb, pl, pr, pe, ps, bd, bg, c, opacity, ff, fz, fw, lts, ta, lh, fs, tt, td, w, miw, maw, h, mih, mah, bgsz, bgp, bgr, bga, pos, top, left, bottom, right, inset, display, flex, hiddenFrom, visibleFrom, lightHidden, darkHidden, sx,...rest } = others;
	const styleProps = filterProps({
		m,
		mx,
		my,
		mt,
		mb,
		ml,
		mr,
		me,
		ms,
		p,
		px: px$1,
		py,
		pt,
		pb,
		pl,
		pr,
		pe,
		ps,
		bd,
		bg,
		c,
		opacity,
		ff,
		fz,
		fw,
		lts,
		ta,
		lh,
		fs,
		tt,
		td,
		w,
		miw,
		maw,
		h,
		mih,
		mah,
		bgsz,
		bgp,
		bgr,
		bga,
		pos,
		top,
		left,
		bottom,
		right,
		inset,
		display,
		flex,
		hiddenFrom,
		visibleFrom,
		lightHidden,
		darkHidden,
		sx
	});
	return {
		styleProps,
		rest
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/style-props-data.mjs
const STYlE_PROPS_DATA = {
	m: {
		type: "spacing",
		property: "margin"
	},
	mt: {
		type: "spacing",
		property: "marginTop"
	},
	mb: {
		type: "spacing",
		property: "marginBottom"
	},
	ml: {
		type: "spacing",
		property: "marginLeft"
	},
	mr: {
		type: "spacing",
		property: "marginRight"
	},
	ms: {
		type: "spacing",
		property: "marginInlineStart"
	},
	me: {
		type: "spacing",
		property: "marginInlineEnd"
	},
	mx: {
		type: "spacing",
		property: "marginInline"
	},
	my: {
		type: "spacing",
		property: "marginBlock"
	},
	p: {
		type: "spacing",
		property: "padding"
	},
	pt: {
		type: "spacing",
		property: "paddingTop"
	},
	pb: {
		type: "spacing",
		property: "paddingBottom"
	},
	pl: {
		type: "spacing",
		property: "paddingLeft"
	},
	pr: {
		type: "spacing",
		property: "paddingRight"
	},
	ps: {
		type: "spacing",
		property: "paddingInlineStart"
	},
	pe: {
		type: "spacing",
		property: "paddingInlineEnd"
	},
	px: {
		type: "spacing",
		property: "paddingInline"
	},
	py: {
		type: "spacing",
		property: "paddingBlock"
	},
	bd: {
		type: "border",
		property: "border"
	},
	bg: {
		type: "color",
		property: "background"
	},
	c: {
		type: "textColor",
		property: "color"
	},
	opacity: {
		type: "identity",
		property: "opacity"
	},
	ff: {
		type: "fontFamily",
		property: "fontFamily"
	},
	fz: {
		type: "fontSize",
		property: "fontSize"
	},
	fw: {
		type: "identity",
		property: "fontWeight"
	},
	lts: {
		type: "size",
		property: "letterSpacing"
	},
	ta: {
		type: "identity",
		property: "textAlign"
	},
	lh: {
		type: "lineHeight",
		property: "lineHeight"
	},
	fs: {
		type: "identity",
		property: "fontStyle"
	},
	tt: {
		type: "identity",
		property: "textTransform"
	},
	td: {
		type: "identity",
		property: "textDecoration"
	},
	w: {
		type: "spacing",
		property: "width"
	},
	miw: {
		type: "spacing",
		property: "minWidth"
	},
	maw: {
		type: "spacing",
		property: "maxWidth"
	},
	h: {
		type: "spacing",
		property: "height"
	},
	mih: {
		type: "spacing",
		property: "minHeight"
	},
	mah: {
		type: "spacing",
		property: "maxHeight"
	},
	bgsz: {
		type: "size",
		property: "backgroundSize"
	},
	bgp: {
		type: "identity",
		property: "backgroundPosition"
	},
	bgr: {
		type: "identity",
		property: "backgroundRepeat"
	},
	bga: {
		type: "identity",
		property: "backgroundAttachment"
	},
	pos: {
		type: "identity",
		property: "position"
	},
	top: {
		type: "size",
		property: "top"
	},
	left: {
		type: "size",
		property: "left"
	},
	bottom: {
		type: "size",
		property: "bottom"
	},
	right: {
		type: "size",
		property: "right"
	},
	inset: {
		type: "size",
		property: "inset"
	},
	display: {
		type: "identity",
		property: "display"
	},
	flex: {
		type: "identity",
		property: "flex"
	}
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/color-resolver/color-resolver.mjs
function colorResolver(color, theme) {
	const parsedColor = parseThemeColor({
		color,
		theme
	});
	if (parsedColor.color === "dimmed") return "var(--mantine-color-dimmed)";
	if (parsedColor.color === "bright") return "var(--mantine-color-bright)";
	return parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color, theme) {
	const parsedColor = parseThemeColor({
		color,
		theme
	});
	if (parsedColor.isThemeColor && parsedColor.shade === void 0) return `var(--mantine-color-${parsedColor.color}-text)`;
	return colorResolver(color, theme);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/border-resolver/border-resolver.mjs
function borderResolver(value, theme) {
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") {
		const [size$3, style, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
		let result = `${rem(size$3)}`;
		style && (result += ` ${style}`);
		colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`);
		return result.trim();
	}
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-family-resolver/font-family-resolver.mjs
const values = {
	text: "var(--mantine-font-family)",
	mono: "var(--mantine-font-family-monospace)",
	monospace: "var(--mantine-font-family-monospace)",
	heading: "var(--mantine-font-family-headings)",
	headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
	if (typeof fontFamily === "string" && fontFamily in values) return values[fontFamily];
	return fontFamily;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-size-resolver/font-size-resolver.mjs
const headings$2 = [
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6"
];
function fontSizeResolver(value, theme) {
	if (typeof value === "string" && value in theme.fontSizes) return `var(--mantine-font-size-${value})`;
	if (typeof value === "string" && headings$2.includes(value)) return `var(--mantine-${value}-font-size)`;
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") return rem(value);
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/identity-resolver/identity-resolver.mjs
function identityResolver(value) {
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/line-height-resolver/line-height-resolver.mjs
const headings$1 = [
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6"
];
function lineHeightResolver(value, theme) {
	if (typeof value === "string" && value in theme.lineHeights) return `var(--mantine-line-height-${value})`;
	if (typeof value === "string" && headings$1.includes(value)) return `var(--mantine-${value}-line-height)`;
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/size-resolver/size-resolver.mjs
function sizeResolver(value) {
	if (typeof value === "number") return rem(value);
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/spacing-resolver/spacing-resolver.mjs
function spacingResolver(value, theme) {
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") {
		const mod = value.replace("-", "");
		if (!(mod in theme.spacing)) return rem(value);
		const variable = `--mantine-spacing-${mod}`;
		return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
	}
	return value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/resolvers/index.mjs
const resolvers = {
	color: colorResolver,
	textColor: textColorResolver,
	fontSize: fontSizeResolver,
	spacing: spacingResolver,
	identity: identityResolver,
	size: sizeResolver,
	lineHeight: lineHeightResolver,
	fontFamily: fontFamilyResolver,
	border: borderResolver
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/sort-media-queries.mjs
function replaceMediaQuery(query) {
	return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({ media,...props }) {
	const breakpoints = Object.keys(media);
	const sortedMedia = breakpoints.sort((a, b) => Number(replaceMediaQuery(a)) - Number(replaceMediaQuery(b))).map((query) => ({
		query,
		styles: media[query]
	}));
	return {
		...props,
		media: sortedMedia
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/parse-style-props.mjs
function hasResponsiveStyles(styleProp) {
	if (typeof styleProp !== "object" || styleProp === null) return false;
	const breakpoints = Object.keys(styleProp);
	if (breakpoints.length === 1 && breakpoints[0] === "base") return false;
	return true;
}
function getBaseValue$1(value) {
	if (typeof value === "object" && value !== null) {
		if ("base" in value) return value.base;
		return void 0;
	}
	return value;
}
function getBreakpointKeys(value) {
	if (typeof value === "object" && value !== null) return keys(value).filter((key) => key !== "base");
	return [];
}
function getBreakpointValue$1(value, breakpoint) {
	if (typeof value === "object" && value !== null && breakpoint in value) return value[breakpoint];
	return value;
}
function parseStyleProps({ styleProps, data, theme }) {
	return sortMediaQueries(keys(styleProps).reduce((acc, styleProp) => {
		if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx") return acc;
		const propertyData = data[styleProp];
		const properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property];
		const baseValue = getBaseValue$1(styleProps[styleProp]);
		if (!hasResponsiveStyles(styleProps[styleProp])) {
			properties.forEach((property) => {
				acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
			});
			return acc;
		}
		acc.hasResponsiveStyles = true;
		const breakpoints = getBreakpointKeys(styleProps[styleProp]);
		properties.forEach((property) => {
			if (baseValue) acc.styles[property] = resolvers[propertyData.type](baseValue, theme);
			breakpoints.forEach((breakpoint) => {
				const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
				acc.media[bp] = {
					...acc.media[bp],
					[property]: resolvers[propertyData.type](getBreakpointValue$1(styleProps[styleProp], breakpoint), theme)
				};
			});
		});
		return acc;
	}, {
		hasResponsiveStyles: false,
		styles: {},
		inlineStyles: {},
		media: {}
	}));
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/use-random-classname/use-random-classname.mjs
function useRandomClassName() {
	const id = (0, import_react.useId)().replace(/:/g, "");
	return `__m__-${id}`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/get-style-object/get-style-object.mjs
function getStyleObject(style, theme) {
	if (Array.isArray(style)) return [...style].reduce((acc, item) => ({
		...acc,
		...getStyleObject(item, theme)
	}), {});
	if (typeof style === "function") return style(theme);
	if (style == null) return {};
	return style;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/factory/create-polymorphic-component.mjs
function createPolymorphicComponent(component) {
	return component;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/get-box-mod/get-box-mod.mjs
function transformModKey(key) {
	return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
	return Object.keys(props).reduce((acc, key) => {
		const value = props[key];
		if (value === void 0 || value === "" || value === false || value === null) return acc;
		acc[transformModKey(key)] = props[key];
		return acc;
	}, {});
}
function getBoxMod(mod) {
	if (!mod) return null;
	if (typeof mod === "string") return { [transformModKey(mod)]: true };
	if (Array.isArray(mod)) return [...mod].reduce((acc, value) => ({
		...acc,
		...getBoxMod(value)
	}), {});
	return getMod(mod);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/get-box-style/get-box-style.mjs
function mergeStyles(styles, theme) {
	if (Array.isArray(styles)) return [...styles].reduce((acc, item) => ({
		...acc,
		...mergeStyles(item, theme)
	}), {});
	if (typeof styles === "function") return styles(theme);
	if (styles == null) return {};
	return styles;
}
function getBoxStyle({ theme, style, vars, styleProps }) {
	const _style = mergeStyles(style, theme);
	const _vars = mergeStyles(vars, theme);
	return {
		..._style,
		..._vars,
		...styleProps
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/Box/Box.mjs
const _Box = (0, import_react.forwardRef)(({ component, style, __vars, className, variant, mod, size: size$3, hiddenFrom, visibleFrom, lightHidden, darkHidden, renderRoot, __size,...others }, ref) => {
	const theme = useMantineTheme();
	const Element$1 = component || "div";
	const { styleProps, rest } = extractStyleProps(others);
	const useSxTransform = useMantineSxTransform();
	const transformedSx = useSxTransform?.()?.(styleProps.sx);
	const responsiveClassName = useRandomClassName();
	const parsedStyleProps = parseStyleProps({
		styleProps,
		theme,
		data: STYlE_PROPS_DATA
	});
	const props = {
		ref,
		style: getBoxStyle({
			theme,
			style,
			vars: __vars,
			styleProps: parsedStyleProps.inlineStyles
		}),
		className: clsx_default(className, transformedSx, {
			[responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
			"mantine-light-hidden": lightHidden,
			"mantine-dark-hidden": darkHidden,
			[`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
			[`mantine-visible-from-${visibleFrom}`]: visibleFrom
		}),
		"data-variant": variant,
		"data-size": isNumberLike(size$3) ? void 0 : size$3 || void 0,
		size: __size,
		...getBoxMod(mod),
		...rest
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		selector: `.${responsiveClassName}`,
		styles: parsedStyleProps.styles,
		media: parsedStyleProps.media
	}), typeof renderRoot === "function" ? renderRoot(props) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Element$1, { ...props })] });
});
_Box.displayName = "@mantine/core/Box";
const Box = createPolymorphicComponent(_Box);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/factory/factory.mjs
function identity(value) {
	return value;
}
function getWithProps(Component) {
	const _Component = Component;
	return (fixedProps) => {
		const Extended = (0, import_react.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(_Component, {
			...fixedProps,
			...props,
			ref
		}));
		Extended.extend = _Component.extend;
		Extended.displayName = `WithProps(${_Component.displayName})`;
		return Extended;
	};
}
function factory(ui) {
	const Component = (0, import_react.forwardRef)(ui);
	Component.extend = identity;
	Component.withProps = (fixedProps) => {
		const Extended = (0, import_react.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			...fixedProps,
			...props,
			ref
		}));
		Extended.extend = Component.extend;
		Extended.displayName = `WithProps(${Component.displayName})`;
		return Extended;
	};
	return Component;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/factory/polymorphic-factory.mjs
function polymorphicFactory(ui) {
	const Component = (0, import_react.forwardRef)(ui);
	Component.withProps = (fixedProps) => {
		const Extended = (0, import_react.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			...fixedProps,
			...props,
			ref
		}));
		Extended.extend = Component.extend;
		Extended.displayName = `WithProps(${Component.displayName})`;
		return Extended;
	};
	Component.extend = identity;
	return Component;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/core/DirectionProvider/DirectionProvider.mjs
const DirectionContext = (0, import_react.createContext)({
	dir: "ltr",
	toggleDirection: () => {},
	setDirection: () => {}
});
function useDirection() {
	return (0, import_react.useContext)(DirectionContext);
}
function DirectionProvider({ children, initialDirection = "ltr", detectDirection = true }) {
	const [dir, setDir] = (0, import_react.useState)(initialDirection);
	const setDirection = (direction) => {
		setDir(direction);
		document.documentElement.setAttribute("dir", direction);
	};
	const toggleDirection = () => setDirection(dir === "ltr" ? "rtl" : "ltr");
	useIsomorphicEffect(() => {
		if (detectDirection) {
			const direction = document.documentElement.getAttribute("dir");
			if (direction === "rtl" || direction === "ltr") setDirection(direction);
		}
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DirectionContext.Provider, {
		value: {
			dir,
			toggleDirection,
			setDirection
		},
		children
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Collapse/use-collapse.mjs
var import_react_dom$4 = __toESM(require_react_dom(), 1);
function getAutoHeightDuration(height) {
	if (!height || typeof height === "string") return 0;
	const constant = height / 36;
	return Math.round((4 + 15 * constant ** .25 + constant / 5) * 10);
}
function getElementHeight(el) {
	return el?.current ? el.current.scrollHeight : "auto";
}
const raf = typeof window !== "undefined" && window.requestAnimationFrame;
function useCollapse({ transitionDuration, transitionTimingFunction = "ease", onTransitionEnd = () => {}, opened }) {
	const el = (0, import_react.useRef)(null);
	const collapsedHeight = 0;
	const collapsedStyles = {
		height: 0,
		overflow: "hidden"
	};
	const [styles, setStylesRaw] = (0, import_react.useState)(opened ? {} : collapsedStyles);
	const setStyles = (newStyles) => {
		(0, import_react_dom$4.flushSync)(() => setStylesRaw(newStyles));
	};
	const mergeStyles$1 = (newStyles) => {
		setStyles((oldStyles) => ({
			...oldStyles,
			...newStyles
		}));
	};
	function getTransitionStyles$1(height) {
		const _duration = transitionDuration || getAutoHeightDuration(height);
		return { transition: `height ${_duration}ms ${transitionTimingFunction}, opacity ${_duration}ms ${transitionTimingFunction}` };
	}
	useDidUpdate(() => {
		if (typeof raf === "function") if (opened) raf(() => {
			mergeStyles$1({
				willChange: "height",
				display: "block",
				overflow: "hidden"
			});
			raf(() => {
				const height = getElementHeight(el);
				mergeStyles$1({
					...getTransitionStyles$1(height),
					height
				});
			});
		});
		else raf(() => {
			const height = getElementHeight(el);
			mergeStyles$1({
				...getTransitionStyles$1(height),
				willChange: "height",
				height
			});
			raf(() => mergeStyles$1({
				height: collapsedHeight,
				overflow: "hidden"
			}));
		});
	}, [opened]);
	const handleTransitionEnd = (e) => {
		if (e.target !== el.current || e.propertyName !== "height") return;
		if (opened) {
			const height = getElementHeight(el);
			if (height === styles.height) setStyles({});
			else mergeStyles$1({ height });
			onTransitionEnd();
		} else if (styles.height === collapsedHeight) {
			setStyles(collapsedStyles);
			onTransitionEnd();
		}
	};
	function getCollapseProps({ style = {}, refKey = "ref",...rest } = {}) {
		const theirRef = rest[refKey];
		const props = {
			"aria-hidden": !opened,
			inert: !opened,
			...rest,
			[refKey]: mergeRefs(el, theirRef),
			onTransitionEnd: handleTransitionEnd,
			style: {
				boxSizing: "border-box",
				...style,
				...styles
			}
		};
		if (!import_react.default.version.startsWith("18")) props.inert = !opened;
		return props;
	}
	return getCollapseProps;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Collapse/Collapse.mjs
const defaultProps$187 = {
	transitionDuration: 200,
	transitionTimingFunction: "ease",
	animateOpacity: true
};
const Collapse = factory((props, ref) => {
	const { children, in: opened, transitionDuration, transitionTimingFunction, style, onTransitionEnd, animateOpacity,...others } = useProps("Collapse", defaultProps$187, props);
	const theme = useMantineTheme();
	const shouldReduceMotion = useReducedMotion();
	const reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : false;
	const duration = reduceMotion ? 0 : transitionDuration;
	const getCollapseProps = useCollapse({
		opened,
		transitionDuration: duration,
		transitionTimingFunction,
		onTransitionEnd
	});
	if (duration === 0) return opened ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		children
	}) : null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getCollapseProps({
			style: {
				opacity: opened || !animateOpacity ? 1 : 0,
				transition: animateOpacity ? `opacity ${duration}ms ${transitionTimingFunction}` : "none",
				...getStyleObject(style, theme)
			},
			ref,
			...others
		}),
		children
	});
});
Collapse.displayName = "@mantine/core/Collapse";

//#endregion
//#region node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
	return typeof window !== "undefined";
}
function getNodeName(node) {
	if (isNode(node)) return (node.nodeName || "").toLowerCase();
	return "#document";
}
function getWindow(node) {
	var _node$ownerDocument;
	return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
	var _ref;
	return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
	if (!hasWindow()) return false;
	return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
	if (!hasWindow()) return false;
	return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
	if (!hasWindow()) return false;
	return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
	if (!hasWindow() || typeof ShadowRoot === "undefined") return false;
	return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
	const { overflow, overflowX, overflowY, display } = getComputedStyle$1(element);
	return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
	return [
		"table",
		"td",
		"th"
	].includes(getNodeName(element));
}
function isTopLayer(element) {
	return [":popover-open", ":modal"].some((selector) => {
		try {
			return element.matches(selector);
		} catch (e) {
			return false;
		}
	});
}
function isContainingBlock(elementOrCss) {
	const webkit = isWebKit();
	const css = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
	return [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective"
	].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective",
		"filter"
	].some((value) => (css.willChange || "").includes(value)) || [
		"paint",
		"layout",
		"strict",
		"content"
	].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
	let currentNode = getParentNode(element);
	while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
		if (isContainingBlock(currentNode)) return currentNode;
		else if (isTopLayer(currentNode)) return null;
		currentNode = getParentNode(currentNode);
	}
	return null;
}
function isWebKit() {
	if (typeof CSS === "undefined" || !CSS.supports) return false;
	return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
	return [
		"html",
		"body",
		"#document"
	].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
	return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
	if (isElement$1(element)) return {
		scrollLeft: element.scrollLeft,
		scrollTop: element.scrollTop
	};
	return {
		scrollLeft: element.scrollX,
		scrollTop: element.scrollY
	};
}
function getParentNode(node) {
	if (getNodeName(node) === "html") return node;
	const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
	return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
	const parentNode = getParentNode(node);
	if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
	if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
	return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
	var _node$ownerDocument2;
	if (list === void 0) list = [];
	if (traverseIframes === void 0) traverseIframes = true;
	const scrollableAncestor = getNearestOverflowAncestor(node);
	const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	const win = getWindow(scrollableAncestor);
	if (isBody) {
		const frameElement = getFrameElement(win);
		return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	}
	return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
	return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

//#endregion
//#region node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function activeElement(doc) {
	let activeElement$1 = doc.activeElement;
	while (((_activeElement = activeElement$1) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
		var _activeElement;
		activeElement$1 = activeElement$1.shadowRoot.activeElement;
	}
	return activeElement$1;
}
function contains(parent, child) {
	if (!parent || !child) return false;
	const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
	if (parent.contains(child)) return true;
	if (rootNode && isShadowRoot(rootNode)) {
		let next = child;
		while (next) {
			if (parent === next) return true;
			next = next.parentNode || next.host;
		}
	}
	return false;
}
function getPlatform() {
	const uaData = navigator.userAgentData;
	if (uaData != null && uaData.platform) return uaData.platform;
	return navigator.platform;
}
function getUserAgent() {
	const uaData = navigator.userAgentData;
	if (uaData && Array.isArray(uaData.brands)) return uaData.brands.map((_ref) => {
		let { brand, version } = _ref;
		return brand + "/" + version;
	}).join(" ");
	return navigator.userAgent;
}
function isVirtualPointerEvent(event) {
	if (isJSDOM()) return false;
	return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
	return /apple/i.test(navigator.vendor);
}
function isAndroid() {
	const re = /android/i;
	return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
	return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
	return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
	const values$1 = ["mouse", "pen"];
	if (!strict) values$1.push("", void 0);
	return values$1.includes(pointerType);
}
function isReactEvent(event) {
	return "nativeEvent" in event;
}
function isRootElement(element) {
	return element.matches("html,body");
}
function getDocument(node) {
	return (node == null ? void 0 : node.ownerDocument) || document;
}
function isEventTargetWithin(event, node) {
	if (node == null) return false;
	if ("composedPath" in event) return event.composedPath().includes(node);
	const e = event;
	return e.target != null && node.contains(e.target);
}
function getTarget(event) {
	if ("composedPath" in event) return event.composedPath()[0];
	return event.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
	return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}

//#endregion
//#region node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
/**
* Custom positioning reference element.
* @see https://floating-ui.com/docs/virtual-elements
*/
const sides = [
	"top",
	"right",
	"bottom",
	"left"
];
const min = Math.min;
const max = Math.max;
const round$1 = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
	x: v,
	y: v
});
const oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
const oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$3(start, value, end) {
	return max(start, min(value, end));
}
function evaluate(value, param) {
	return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
	return placement.split("-")[0];
}
function getAlignment(placement) {
	return placement.split("-")[1];
}
function getOppositeAxis(axis) {
	return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
	return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
	return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
	return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
	if (rtl === void 0) rtl = false;
	const alignment = getAlignment(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const length = getAxisLength(alignmentAxis);
	let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
	if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
	return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
	const oppositePlacement = getOppositePlacement(placement);
	return [
		getOppositeAlignmentPlacement(placement),
		oppositePlacement,
		getOppositeAlignmentPlacement(oppositePlacement)
	];
}
function getOppositeAlignmentPlacement(placement) {
	return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
	const lr = ["left", "right"];
	const rl = ["right", "left"];
	const tb = ["top", "bottom"];
	const bt = ["bottom", "top"];
	switch (side) {
		case "top":
		case "bottom":
			if (rtl) return isStart ? rl : lr;
			return isStart ? lr : rl;
		case "left":
		case "right": return isStart ? tb : bt;
		default: return [];
	}
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
	const alignment = getAlignment(placement);
	let list = getSideList(getSide(placement), direction === "start", rtl);
	if (alignment) {
		list = list.map((side) => side + "-" + alignment);
		if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
	}
	return list;
}
function getOppositePlacement(placement) {
	return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...padding
	};
}
function getPaddingObject(padding) {
	return typeof padding !== "number" ? expandPaddingObject(padding) : {
		top: padding,
		right: padding,
		bottom: padding,
		left: padding
	};
}
function rectToClientRect(rect) {
	const { x, y, width, height } = rect;
	return {
		width,
		height,
		top: y,
		left: x,
		right: x + width,
		bottom: y + height,
		x,
		y
	};
}

//#endregion
//#region node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
	var _element$getRootNode;
	return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
	return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

//#endregion
//#region node_modules/.pnpm/@floating-ui+core@1.7.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
	let { reference, floating } = _ref;
	const sideAxis = getSideAxis(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const alignLength = getAxisLength(alignmentAxis);
	const side = getSide(placement);
	const isVertical = sideAxis === "y";
	const commonX = reference.x + reference.width / 2 - floating.width / 2;
	const commonY = reference.y + reference.height / 2 - floating.height / 2;
	const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
	let coords;
	switch (side) {
		case "top":
			coords = {
				x: commonX,
				y: reference.y - floating.height
			};
			break;
		case "bottom":
			coords = {
				x: commonX,
				y: reference.y + reference.height
			};
			break;
		case "right":
			coords = {
				x: reference.x + reference.width,
				y: commonY
			};
			break;
		case "left":
			coords = {
				x: reference.x - floating.width,
				y: commonY
			};
			break;
		default: coords = {
			x: reference.x,
			y: reference.y
		};
	}
	switch (getAlignment(placement)) {
		case "start":
			coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
			break;
		case "end":
			coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
			break;
	}
	return coords;
}
/**
* Computes the `x` and `y` coordinates that will place the floating element
* next to a given reference element.
*
* This export does not have any `platform` interface logic. You will need to
* write one for the platform you are using Floating UI with.
*/
const computePosition$1 = async (reference, floating, config) => {
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1 } = config;
	const validMiddleware = middleware.filter(Boolean);
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating));
	let rects = await platform$1.getElementRects({
		reference,
		floating,
		strategy
	});
	let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
	let statefulPlacement = placement;
	let middlewareData = {};
	let resetCount = 0;
	for (let i = 0; i < validMiddleware.length; i++) {
		const { name, fn } = validMiddleware[i];
		const { x: nextX, y: nextY, data, reset } = await fn({
			x,
			y,
			initialPlacement: placement,
			placement: statefulPlacement,
			strategy,
			middlewareData,
			rects,
			platform: platform$1,
			elements: {
				reference,
				floating
			}
		});
		x = nextX != null ? nextX : x;
		y = nextY != null ? nextY : y;
		middlewareData = {
			...middlewareData,
			[name]: {
				...middlewareData[name],
				...data
			}
		};
		if (reset && resetCount <= 50) {
			resetCount++;
			if (typeof reset === "object") {
				if (reset.placement) statefulPlacement = reset.placement;
				if (reset.rects) rects = reset.rects === true ? await platform$1.getElementRects({
					reference,
					floating,
					strategy
				}) : reset.rects;
				({x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
			}
			i = -1;
		}
	}
	return {
		x,
		y,
		placement: statefulPlacement,
		strategy,
		middlewareData
	};
};
/**
* Resolves with an object of overflow side offsets that determine how much the
* element is overflowing a given clipping boundary on each side.
* - positive = overflowing the boundary by that number of pixels
* - negative = how many pixels left before it will overflow
* - 0 = lies flush with the boundary
* @see https://floating-ui.com/docs/detectOverflow
*/
async function detectOverflow$1(state, options$1) {
	var _await$platform$isEle;
	if (options$1 === void 0) options$1 = {};
	const { x, y, platform: platform$1, rects, elements, strategy } = state;
	const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding = 0 } = evaluate(options$1, state);
	const paddingObject = getPaddingObject(padding);
	const altContext = elementContext === "floating" ? "reference" : "floating";
	const element = elements[altBoundary ? altContext : elementContext];
	const clippingClientRect = rectToClientRect(await platform$1.getClippingRect({
		element: ((_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform$1.getDocumentElement == null ? void 0 : platform$1.getDocumentElement(elements.floating)),
		boundary,
		rootBoundary,
		strategy
	}));
	const rect = elementContext === "floating" ? {
		x,
		y,
		width: rects.floating.width,
		height: rects.floating.height
	} : rects.reference;
	const offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating));
	const offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent)) ? await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || {
		x: 1,
		y: 1
	} : {
		x: 1,
		y: 1
	};
	const elementClientRect = rectToClientRect(platform$1.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements,
		rect,
		offsetParent,
		strategy
	}) : rect);
	return {
		top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
		bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
		left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
		right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
	};
}
/**
* Provides data to position an inner element of the floating element so that it
* appears centered to the reference element.
* @see https://floating-ui.com/docs/arrow
*/
const arrow$2 = (options$1) => ({
	name: "arrow",
	options: options$1,
	async fn(state) {
		const { x, y, placement, rects, platform: platform$1, elements, middlewareData } = state;
		const { element, padding = 0 } = evaluate(options$1, state) || {};
		if (element == null) return {};
		const paddingObject = getPaddingObject(padding);
		const coords = {
			x,
			y
		};
		const axis = getAlignmentAxis(placement);
		const length = getAxisLength(axis);
		const arrowDimensions = await platform$1.getDimensions(element);
		const isYAxis = axis === "y";
		const minProp = isYAxis ? "top" : "left";
		const maxProp = isYAxis ? "bottom" : "right";
		const clientProp = isYAxis ? "clientHeight" : "clientWidth";
		const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
		const startDiff = coords[axis] - rects.reference[axis];
		const arrowOffsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(element));
		let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
		if (!clientSize || !await (platform$1.isElement == null ? void 0 : platform$1.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];
		const centerToReference = endDiff / 2 - startDiff / 2;
		const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
		const minPadding = min(paddingObject[minProp], largestPossiblePadding);
		const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
		const min$1 = minPadding;
		const max$1 = clientSize - arrowDimensions[length] - maxPadding;
		const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
		const offset$3 = clamp$3(min$1, center, max$1);
		const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset$3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
		const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max$1 : 0;
		return {
			[axis]: coords[axis] + alignmentOffset,
			data: {
				[axis]: offset$3,
				centerOffset: center - offset$3 - alignmentOffset,
				...shouldAddOffset && { alignmentOffset }
			},
			reset: shouldAddOffset
		};
	}
});
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
const flip$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "flip",
		options: options$1,
		async fn(state) {
			var _middlewareData$arrow, _middlewareData$flip;
			const { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true,...detectOverflowOptions } = evaluate(options$1, state);
			if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			const side = getSide(placement);
			const initialSideAxis = getSideAxis(initialPlacement);
			const isBasePlacement = getSide(initialPlacement) === initialPlacement;
			const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
			const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
			const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
			if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
			const placements$1 = [initialPlacement, ...fallbackPlacements];
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const overflows = [];
			let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
			if (checkMainAxis) overflows.push(overflow[side]);
			if (checkCrossAxis) {
				const sides$1 = getAlignmentSides(placement, rects, rtl);
				overflows.push(overflow[sides$1[0]], overflow[sides$1[1]]);
			}
			overflowsData = [...overflowsData, {
				placement,
				overflows
			}];
			if (!overflows.every((side$1) => side$1 <= 0)) {
				var _middlewareData$flip2, _overflowsData$filter;
				const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
				const nextPlacement = placements$1[nextIndex];
				if (nextPlacement) {
					var _overflowsData$;
					const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
					const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
					if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) return {
						data: {
							index: nextIndex,
							overflows: overflowsData
						},
						reset: { placement: nextPlacement }
					};
				}
				let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
				if (!resetPlacement) switch (fallbackStrategy) {
					case "bestFit": {
						var _overflowsData$filter2;
						const placement$1 = (_overflowsData$filter2 = overflowsData.filter((d) => {
							if (hasFallbackAxisSideDirection) {
								const currentSideAxis = getSideAxis(d.placement);
								return currentSideAxis === initialSideAxis || currentSideAxis === "y";
							}
							return true;
						}).map((d) => [d.placement, d.overflows.filter((overflow$1) => overflow$1 > 0).reduce((acc, overflow$1) => acc + overflow$1, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
						if (placement$1) resetPlacement = placement$1;
						break;
					}
					case "initialPlacement":
						resetPlacement = initialPlacement;
						break;
				}
				if (placement !== resetPlacement) return { reset: { placement: resetPlacement } };
			}
			return {};
		}
	};
};
function getSideOffsets(overflow, rect) {
	return {
		top: overflow.top - rect.height,
		right: overflow.right - rect.width,
		bottom: overflow.bottom - rect.height,
		left: overflow.left - rect.width
	};
}
function isAnySideFullyClipped(overflow) {
	return sides.some((side) => overflow[side] >= 0);
}
/**
* Provides data to hide the floating element in applicable situations, such as
* when it is not in the same clipping context as the reference element.
* @see https://floating-ui.com/docs/hide
*/
const hide$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "hide",
		options: options$1,
		async fn(state) {
			const { rects } = state;
			const { strategy = "referenceHidden",...detectOverflowOptions } = evaluate(options$1, state);
			switch (strategy) {
				case "referenceHidden": {
					const overflow = await detectOverflow$1(state, {
						...detectOverflowOptions,
						elementContext: "reference"
					});
					const offsets = getSideOffsets(overflow, rects.reference);
					return { data: {
						referenceHiddenOffsets: offsets,
						referenceHidden: isAnySideFullyClipped(offsets)
					} };
				}
				case "escaped": {
					const overflow = await detectOverflow$1(state, {
						...detectOverflowOptions,
						altBoundary: true
					});
					const offsets = getSideOffsets(overflow, rects.floating);
					return { data: {
						escapedOffsets: offsets,
						escaped: isAnySideFullyClipped(offsets)
					} };
				}
				default: return {};
			}
		}
	};
};
function getBoundingRect(rects) {
	const minX = min(...rects.map((rect) => rect.left));
	const minY = min(...rects.map((rect) => rect.top));
	const maxX = max(...rects.map((rect) => rect.right));
	const maxY = max(...rects.map((rect) => rect.bottom));
	return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY - minY
	};
}
function getRectsByLine(rects) {
	const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
	const groups = [];
	let prevRect = null;
	for (let i = 0; i < sortedRects.length; i++) {
		const rect = sortedRects[i];
		if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) groups.push([rect]);
		else groups[groups.length - 1].push(rect);
		prevRect = rect;
	}
	return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
/**
* Provides improved positioning for inline reference elements that can span
* over multiple lines, such as hyperlinks or range selections.
* @see https://floating-ui.com/docs/inline
*/
const inline$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "inline",
		options: options$1,
		async fn(state) {
			const { placement, elements, rects, platform: platform$1, strategy } = state;
			const { padding = 2, x, y } = evaluate(options$1, state);
			const nativeClientRects = Array.from(await (platform$1.getClientRects == null ? void 0 : platform$1.getClientRects(elements.reference)) || []);
			const clientRects = getRectsByLine(nativeClientRects);
			const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
			const paddingObject = getPaddingObject(padding);
			function getBoundingClientRect$1() {
				if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
				if (clientRects.length >= 2) {
					if (getSideAxis(placement) === "y") {
						const firstRect = clientRects[0];
						const lastRect = clientRects[clientRects.length - 1];
						const isTop = getSide(placement) === "top";
						const top$1 = firstRect.top;
						const bottom$1 = lastRect.bottom;
						const left$1 = isTop ? firstRect.left : lastRect.left;
						const right$1 = isTop ? firstRect.right : lastRect.right;
						const width$1 = right$1 - left$1;
						const height$1 = bottom$1 - top$1;
						return {
							top: top$1,
							bottom: bottom$1,
							left: left$1,
							right: right$1,
							width: width$1,
							height: height$1,
							x: left$1,
							y: top$1
						};
					}
					const isLeftSide = getSide(placement) === "left";
					const maxRight = max(...clientRects.map((rect) => rect.right));
					const minLeft = min(...clientRects.map((rect) => rect.left));
					const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
					const top = measureRects[0].top;
					const bottom = measureRects[measureRects.length - 1].bottom;
					const left = minLeft;
					const right = maxRight;
					const width = right - left;
					const height = bottom - top;
					return {
						top,
						bottom,
						left,
						right,
						width,
						height,
						x: left,
						y: top
					};
				}
				return fallback;
			}
			const resetRects = await platform$1.getElementRects({
				reference: { getBoundingClientRect: getBoundingClientRect$1 },
				floating: elements.floating,
				strategy
			});
			if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) return { reset: { rects: resetRects } };
			return {};
		}
	};
};
async function convertValueToCoords(state, options$1) {
	const { placement, platform: platform$1, elements } = state;
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
	const side = getSide(placement);
	const alignment = getAlignment(placement);
	const isVertical = getSideAxis(placement) === "y";
	const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
	const crossAxisMulti = rtl && isVertical ? -1 : 1;
	const rawValue = evaluate(options$1, state);
	let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
		mainAxis: rawValue,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: rawValue.mainAxis || 0,
		crossAxis: rawValue.crossAxis || 0,
		alignmentAxis: rawValue.alignmentAxis
	};
	if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
	return isVertical ? {
		x: crossAxis * crossAxisMulti,
		y: mainAxis * mainAxisMulti
	} : {
		x: mainAxis * mainAxisMulti,
		y: crossAxis * crossAxisMulti
	};
}
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
const offset$2 = function(options$1) {
	if (options$1 === void 0) options$1 = 0;
	return {
		name: "offset",
		options: options$1,
		async fn(state) {
			var _middlewareData$offse, _middlewareData$arrow;
			const { x, y, placement, middlewareData } = state;
			const diffCoords = await convertValueToCoords(state, options$1);
			if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			return {
				x: x + diffCoords.x,
				y: y + diffCoords.y,
				data: {
					...diffCoords,
					placement
				}
			};
		}
	};
};
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
const shift$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "shift",
		options: options$1,
		async fn(state) {
			const { x, y, placement } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = { fn: (_ref) => {
				let { x: x$1, y: y$1 } = _ref;
				return {
					x: x$1,
					y: y$1
				};
			} },...detectOverflowOptions } = evaluate(options$1, state);
			const coords = {
				x,
				y
			};
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const crossAxis = getSideAxis(getSide(placement));
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			if (checkMainAxis) {
				const minSide = mainAxis === "y" ? "top" : "left";
				const maxSide = mainAxis === "y" ? "bottom" : "right";
				const min$1 = mainAxisCoord + overflow[minSide];
				const max$1 = mainAxisCoord - overflow[maxSide];
				mainAxisCoord = clamp$3(min$1, mainAxisCoord, max$1);
			}
			if (checkCrossAxis) {
				const minSide = crossAxis === "y" ? "top" : "left";
				const maxSide = crossAxis === "y" ? "bottom" : "right";
				const min$1 = crossAxisCoord + overflow[minSide];
				const max$1 = crossAxisCoord - overflow[maxSide];
				crossAxisCoord = clamp$3(min$1, crossAxisCoord, max$1);
			}
			const limitedCoords = limiter.fn({
				...state,
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			});
			return {
				...limitedCoords,
				data: {
					x: limitedCoords.x - x,
					y: limitedCoords.y - y,
					enabled: {
						[mainAxis]: checkMainAxis,
						[crossAxis]: checkCrossAxis
					}
				}
			};
		}
	};
};
/**
* Built-in `limiter` that will stop `shift()` at a certain point.
*/
const limitShift$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		options: options$1,
		fn(state) {
			const { x, y, placement, rects, middlewareData } = state;
			const { offset: offset$3 = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = evaluate(options$1, state);
			const coords = {
				x,
				y
			};
			const crossAxis = getSideAxis(placement);
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			const rawOffset = evaluate(offset$3, state);
			const computedOffset = typeof rawOffset === "number" ? {
				mainAxis: rawOffset,
				crossAxis: 0
			} : {
				mainAxis: 0,
				crossAxis: 0,
				...rawOffset
			};
			if (checkMainAxis) {
				const len = mainAxis === "y" ? "height" : "width";
				const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
				const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
				if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
				else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
			}
			if (checkCrossAxis) {
				var _middlewareData$offse, _middlewareData$offse2;
				const len = mainAxis === "y" ? "width" : "height";
				const isOriginSide = ["top", "left"].includes(getSide(placement));
				const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
				const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
				if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;
				else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;
			}
			return {
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			};
		}
	};
};
/**
* Provides data that allows you to change the size of the floating element â€”
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
const size$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "size",
		options: options$1,
		async fn(state) {
			var _state$middlewareData, _state$middlewareData2;
			const { placement, rects, platform: platform$1, elements } = state;
			const { apply = () => {},...detectOverflowOptions } = evaluate(options$1, state);
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const side = getSide(placement);
			const alignment = getAlignment(placement);
			const isYAxis = getSideAxis(placement) === "y";
			const { width, height } = rects.floating;
			let heightSide;
			let widthSide;
			if (side === "top" || side === "bottom") {
				heightSide = side;
				widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
			} else {
				widthSide = side;
				heightSide = alignment === "end" ? "top" : "bottom";
			}
			const maximumClippingHeight = height - overflow.top - overflow.bottom;
			const maximumClippingWidth = width - overflow.left - overflow.right;
			const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
			const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
			const noShift = !state.middlewareData.shift;
			let availableHeight = overflowAvailableHeight;
			let availableWidth = overflowAvailableWidth;
			if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;
			if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;
			if (noShift && !alignment) {
				const xMin = max(overflow.left, 0);
				const xMax = max(overflow.right, 0);
				const yMin = max(overflow.top, 0);
				const yMax = max(overflow.bottom, 0);
				if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
				else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
			}
			await apply({
				...state,
				availableWidth,
				availableHeight
			});
			const nextDimensions = await platform$1.getDimensions(elements.floating);
			if (width !== nextDimensions.width || height !== nextDimensions.height) return { reset: { rects: true } };
			return {};
		}
	};
};

//#endregion
//#region node_modules/.pnpm/@floating-ui+dom@1.7.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
	const css = getComputedStyle$1(element);
	let width = parseFloat(css.width) || 0;
	let height = parseFloat(css.height) || 0;
	const hasOffset = isHTMLElement(element);
	const offsetWidth = hasOffset ? element.offsetWidth : width;
	const offsetHeight = hasOffset ? element.offsetHeight : height;
	const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
	if (shouldFallback) {
		width = offsetWidth;
		height = offsetHeight;
	}
	return {
		width,
		height,
		$: shouldFallback
	};
}
function unwrapElement(element) {
	return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
	const domElement = unwrapElement(element);
	if (!isHTMLElement(domElement)) return createCoords(1);
	const rect = domElement.getBoundingClientRect();
	const { width, height, $ } = getCssDimensions(domElement);
	let x = ($ ? round$1(rect.width) : rect.width) / width;
	let y = ($ ? round$1(rect.height) : rect.height) / height;
	if (!x || !Number.isFinite(x)) x = 1;
	if (!y || !Number.isFinite(y)) y = 1;
	return {
		x,
		y
	};
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
	const win = getWindow(element);
	if (!isWebKit() || !win.visualViewport) return noOffsets;
	return {
		x: win.visualViewport.offsetLeft,
		y: win.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	if (isFixed === void 0) isFixed = false;
	if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) return false;
	return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	if (includeScale === void 0) includeScale = false;
	if (isFixedStrategy === void 0) isFixedStrategy = false;
	const clientRect = element.getBoundingClientRect();
	const domElement = unwrapElement(element);
	let scale = createCoords(1);
	if (includeScale) if (offsetParent) {
		if (isElement$1(offsetParent)) scale = getScale(offsetParent);
	} else scale = getScale(element);
	const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	let x = (clientRect.left + visualOffsets.x) / scale.x;
	let y = (clientRect.top + visualOffsets.y) / scale.y;
	let width = clientRect.width / scale.x;
	let height = clientRect.height / scale.y;
	if (domElement) {
		const win = getWindow(domElement);
		const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
		let currentWin = win;
		let currentIFrame = getFrameElement(currentWin);
		while (currentIFrame && offsetParent && offsetWin !== currentWin) {
			const iframeScale = getScale(currentIFrame);
			const iframeRect = currentIFrame.getBoundingClientRect();
			const css = getComputedStyle$1(currentIFrame);
			const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
			const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
			x *= iframeScale.x;
			y *= iframeScale.y;
			width *= iframeScale.x;
			height *= iframeScale.y;
			x += left;
			y += top;
			currentWin = getWindow(currentIFrame);
			currentIFrame = getFrameElement(currentWin);
		}
	}
	return rectToClientRect({
		width,
		height,
		x,
		y
	});
}
function getWindowScrollBarX(element, rect) {
	const leftScroll = getNodeScroll(element).scrollLeft;
	if (!rect) return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
	return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
	if (ignoreScrollbarX === void 0) ignoreScrollbarX = false;
	const htmlRect = documentElement.getBoundingClientRect();
	const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : getWindowScrollBarX(documentElement, htmlRect));
	const y = htmlRect.top + scroll.scrollTop;
	return {
		x,
		y
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
	let { elements, rect, offsetParent, strategy } = _ref;
	const isFixed = strategy === "fixed";
	const documentElement = getDocumentElement(offsetParent);
	const topLayer = elements ? isTopLayer(elements.floating) : false;
	if (offsetParent === documentElement || topLayer && isFixed) return rect;
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	let scale = createCoords(1);
	const offsets = createCoords(0);
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isHTMLElement(offsetParent)) {
			const offsetRect = getBoundingClientRect(offsetParent);
			scale = getScale(offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		}
	}
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
	return {
		width: rect.width * scale.x,
		height: rect.height * scale.y,
		x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
		y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
	};
}
function getClientRects(element) {
	return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
	const html = getDocumentElement(element);
	const scroll = getNodeScroll(element);
	const body = element.ownerDocument.body;
	const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
	const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
	let x = -scroll.scrollLeft + getWindowScrollBarX(element);
	const y = -scroll.scrollTop;
	if (getComputedStyle$1(body).direction === "rtl") x += max(html.clientWidth, body.clientWidth) - width;
	return {
		width,
		height,
		x,
		y
	};
}
function getViewportRect(element, strategy) {
	const win = getWindow(element);
	const html = getDocumentElement(element);
	const visualViewport = win.visualViewport;
	let width = html.clientWidth;
	let height = html.clientHeight;
	let x = 0;
	let y = 0;
	if (visualViewport) {
		width = visualViewport.width;
		height = visualViewport.height;
		const visualViewportBased = isWebKit();
		if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
			x = visualViewport.offsetLeft;
			y = visualViewport.offsetTop;
		}
	}
	return {
		width,
		height,
		x,
		y
	};
}
function getInnerBoundingClientRect(element, strategy) {
	const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
	const top = clientRect.top + element.clientTop;
	const left = clientRect.left + element.clientLeft;
	const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
	const width = element.clientWidth * scale.x;
	const height = element.clientHeight * scale.y;
	const x = left * scale.x;
	const y = top * scale.y;
	return {
		width,
		height,
		x,
		y
	};
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
	let rect;
	if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
	else if (clippingAncestor === "document") rect = getDocumentRect(getDocumentElement(element));
	else if (isElement$1(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
	else {
		const visualOffsets = getVisualOffsets(element);
		rect = {
			x: clippingAncestor.x - visualOffsets.x,
			y: clippingAncestor.y - visualOffsets.y,
			width: clippingAncestor.width,
			height: clippingAncestor.height
		};
	}
	return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
	const parentNode = getParentNode(element);
	if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) return false;
	return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
	const cachedResult = cache.get(element);
	if (cachedResult) return cachedResult;
	let result = getOverflowAncestors(element, [], false).filter((el) => isElement$1(el) && getNodeName(el) !== "body");
	let currentContainingBlockComputedStyle = null;
	const elementIsFixed = getComputedStyle$1(element).position === "fixed";
	let currentNode = elementIsFixed ? getParentNode(element) : element;
	while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
		const computedStyle = getComputedStyle$1(currentNode);
		const currentNodeIsContaining = isContainingBlock(currentNode);
		if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
		const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
		if (shouldDropCurrentNode) result = result.filter((ancestor) => ancestor !== currentNode);
		else currentContainingBlockComputedStyle = computedStyle;
		currentNode = getParentNode(currentNode);
	}
	cache.set(element, result);
	return result;
}
function getClippingRect(_ref) {
	let { element, boundary, rootBoundary, strategy } = _ref;
	const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
	const clippingAncestors = [...elementClippingAncestors, rootBoundary];
	const firstClippingAncestor = clippingAncestors[0];
	const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
		const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
		accRect.top = max(rect.top, accRect.top);
		accRect.right = min(rect.right, accRect.right);
		accRect.bottom = min(rect.bottom, accRect.bottom);
		accRect.left = max(rect.left, accRect.left);
		return accRect;
	}, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
	return {
		width: clippingRect.right - clippingRect.left,
		height: clippingRect.bottom - clippingRect.top,
		x: clippingRect.left,
		y: clippingRect.top
	};
}
function getDimensions(element) {
	const { width, height } = getCssDimensions(element);
	return {
		width,
		height
	};
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	const documentElement = getDocumentElement(offsetParent);
	const isFixed = strategy === "fixed";
	const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	const offsets = createCoords(0);
	function setLeftRTLScrollbarOffset() {
		offsets.x = getWindowScrollBarX(documentElement);
	}
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isOffsetParentAnElement) {
			const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		} else if (documentElement) setLeftRTLScrollbarOffset();
	}
	if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
	const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
	return {
		x,
		y,
		width: rect.width,
		height: rect.height
	};
}
function isStaticPositioned(element) {
	return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
	if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") return null;
	if (polyfill) return polyfill(element);
	let rawOffsetParent = element.offsetParent;
	if (getDocumentElement(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;
	return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
	const win = getWindow(element);
	if (isTopLayer(element)) return win;
	if (!isHTMLElement(element)) {
		let svgOffsetParent = getParentNode(element);
		while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
			if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent;
			svgOffsetParent = getParentNode(svgOffsetParent);
		}
		return win;
	}
	let offsetParent = getTrueOffsetParent(element, polyfill);
	while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) offsetParent = getTrueOffsetParent(offsetParent, polyfill);
	if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) return win;
	return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
	const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
	const getDimensionsFn = this.getDimensions;
	const floatingDimensions = await getDimensionsFn(data.floating);
	return {
		reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
		floating: {
			x: 0,
			y: 0,
			width: floatingDimensions.width,
			height: floatingDimensions.height
		}
	};
};
function isRTL(element) {
	return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement: isElement$1,
	isRTL
};
function rectsAreEqual(a, b) {
	return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
	let io = null;
	let timeoutId;
	const root = getDocumentElement(element);
	function cleanup() {
		var _io;
		clearTimeout(timeoutId);
		(_io = io) == null || _io.disconnect();
		io = null;
	}
	function refresh(skip, threshold) {
		if (skip === void 0) skip = false;
		if (threshold === void 0) threshold = 1;
		cleanup();
		const elementRectForRootMargin = element.getBoundingClientRect();
		const { left, top, width, height } = elementRectForRootMargin;
		if (!skip) onMove();
		if (!width || !height) return;
		const insetTop = floor(top);
		const insetRight = floor(root.clientWidth - (left + width));
		const insetBottom = floor(root.clientHeight - (top + height));
		const insetLeft = floor(left);
		const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
		const options$1 = {
			rootMargin,
			threshold: max(0, min(1, threshold)) || 1
		};
		let isFirstUpdate = true;
		function handleObserve(entries) {
			const ratio = entries[0].intersectionRatio;
			if (ratio !== threshold) {
				if (!isFirstUpdate) return refresh();
				if (!ratio) timeoutId = setTimeout(() => {
					refresh(false, 1e-7);
				}, 1e3);
				else refresh(false, ratio);
			}
			if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) refresh();
			isFirstUpdate = false;
		}
		try {
			io = new IntersectionObserver(handleObserve, {
				...options$1,
				root: root.ownerDocument
			});
		} catch (_e) {
			io = new IntersectionObserver(handleObserve, options$1);
		}
		io.observe(element);
	}
	refresh(true);
	return cleanup;
}
/**
* Automatically updates the position of the floating element when necessary.
* Should only be called when the floating element is mounted on the DOM or
* visible on the screen.
* @returns cleanup function that should be invoked when the floating element is
* removed from the DOM or hidden from the screen.
* @see https://floating-ui.com/docs/autoUpdate
*/
function autoUpdate(reference, floating, update, options$1) {
	if (options$1 === void 0) options$1 = {};
	const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === "function", layoutShift = typeof IntersectionObserver === "function", animationFrame = false } = options$1;
	const referenceEl = unwrapElement(reference);
	const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
	ancestors.forEach((ancestor) => {
		ancestorScroll && ancestor.addEventListener("scroll", update, { passive: true });
		ancestorResize && ancestor.addEventListener("resize", update);
	});
	const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	let reobserveFrame = -1;
	let resizeObserver = null;
	if (elementResize) {
		resizeObserver = new ResizeObserver((_ref) => {
			let [firstEntry] = _ref;
			if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
				resizeObserver.unobserve(floating);
				cancelAnimationFrame(reobserveFrame);
				reobserveFrame = requestAnimationFrame(() => {
					var _resizeObserver;
					(_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
				});
			}
			update();
		});
		if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
		resizeObserver.observe(floating);
	}
	let frameId;
	let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	if (animationFrame) frameLoop();
	function frameLoop() {
		const nextRefRect = getBoundingClientRect(reference);
		if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) update();
		prevRefRect = nextRefRect;
		frameId = requestAnimationFrame(frameLoop);
	}
	update();
	return () => {
		var _resizeObserver2;
		ancestors.forEach((ancestor) => {
			ancestorScroll && ancestor.removeEventListener("scroll", update);
			ancestorResize && ancestor.removeEventListener("resize", update);
		});
		cleanupIo?.();
		(_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
		resizeObserver = null;
		if (animationFrame) cancelAnimationFrame(frameId);
	};
}
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
const offset$1 = offset$2;
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
const shift$1 = shift$2;
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
const flip$1 = flip$2;
/**
* Provides data that allows you to change the size of the floating element â€”
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
const size$1 = size$2;
/**
* Provides data to hide the floating element in applicable situations, such as
* when it is not in the same clipping context as the reference element.
* @see https://floating-ui.com/docs/hide
*/
const hide$1 = hide$2;
/**
* Provides data to position an inner element of the floating element so that it
* appears centered to the reference element.
* @see https://floating-ui.com/docs/arrow
*/
const arrow$1 = arrow$2;
/**
* Provides improved positioning for inline reference elements that can span
* over multiple lines, such as hyperlinks or range selections.
* @see https://floating-ui.com/docs/inline
*/
const inline$1 = inline$2;
/**
* Built-in `limiter` that will stop `shift()` at a certain point.
*/
const limitShift$1 = limitShift$2;
/**
* Computes the `x` and `y` coordinates that will place the floating element
* next to a given reference element.
*/
const computePosition = (reference, floating, options$1) => {
	const cache = /* @__PURE__ */ new Map();
	const mergedOptions = {
		platform,
		...options$1
	};
	const platformWithCache = {
		...mergedOptions.platform,
		_c: cache
	};
	return computePosition$1(reference, floating, {
		...mergedOptions,
		platform: platformWithCache
	});
};

//#endregion
//#region node_modules/.pnpm/@floating-ui+react-dom@2.1.2_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var import_react_dom$3 = __toESM(require_react_dom(), 1);
var index$3 = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function deepEqual(a, b) {
	if (a === b) return true;
	if (typeof a !== typeof b) return false;
	if (typeof a === "function" && a.toString() === b.toString()) return true;
	let length;
	let i;
	let keys$1;
	if (a && b && typeof a === "object") {
		if (Array.isArray(a)) {
			length = a.length;
			if (length !== b.length) return false;
			for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;
			return true;
		}
		keys$1 = Object.keys(a);
		length = keys$1.length;
		if (length !== Object.keys(b).length) return false;
		for (i = length; i-- !== 0;) if (!{}.hasOwnProperty.call(b, keys$1[i])) return false;
		for (i = length; i-- !== 0;) {
			const key = keys$1[i];
			if (key === "_owner" && a.$$typeof) continue;
			if (!deepEqual(a[key], b[key])) return false;
		}
		return true;
	}
	return a !== a && b !== b;
}
function getDPR(element) {
	if (typeof window === "undefined") return 1;
	const win = element.ownerDocument.defaultView || window;
	return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
	const dpr = getDPR(element);
	return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
	const ref = import_react.useRef(value);
	index$3(() => {
		ref.current = value;
	});
	return ref;
}
/**
* Provides data to position a floating element.
* @see https://floating-ui.com/docs/useFloating
*/
function useFloating$1(options$1) {
	if (options$1 === void 0) options$1 = {};
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options$1;
	const [data, setData] = import_react.useState({
		x: 0,
		y: 0,
		strategy,
		placement,
		middlewareData: {},
		isPositioned: false
	});
	const [latestMiddleware, setLatestMiddleware] = import_react.useState(middleware);
	if (!deepEqual(latestMiddleware, middleware)) setLatestMiddleware(middleware);
	const [_reference, _setReference] = import_react.useState(null);
	const [_floating, _setFloating] = import_react.useState(null);
	const setReference = import_react.useCallback((node) => {
		if (node !== referenceRef.current) {
			referenceRef.current = node;
			_setReference(node);
		}
	}, []);
	const setFloating = import_react.useCallback((node) => {
		if (node !== floatingRef.current) {
			floatingRef.current = node;
			_setFloating(node);
		}
	}, []);
	const referenceEl = externalReference || _reference;
	const floatingEl = externalFloating || _floating;
	const referenceRef = import_react.useRef(null);
	const floatingRef = import_react.useRef(null);
	const dataRef = import_react.useRef(data);
	const hasWhileElementsMounted = whileElementsMounted != null;
	const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
	const platformRef = useLatestRef$1(platform$1);
	const openRef = useLatestRef$1(open);
	const update = import_react.useCallback(() => {
		if (!referenceRef.current || !floatingRef.current) return;
		const config = {
			placement,
			strategy,
			middleware: latestMiddleware
		};
		if (platformRef.current) config.platform = platformRef.current;
		computePosition(referenceRef.current, floatingRef.current, config).then((data$1) => {
			const fullData = {
				...data$1,
				isPositioned: openRef.current !== false
			};
			if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
				dataRef.current = fullData;
				import_react_dom$3.flushSync(() => {
					setData(fullData);
				});
			}
		});
	}, [
		latestMiddleware,
		placement,
		strategy,
		platformRef,
		openRef
	]);
	index$3(() => {
		if (open === false && dataRef.current.isPositioned) {
			dataRef.current.isPositioned = false;
			setData((data$1) => ({
				...data$1,
				isPositioned: false
			}));
		}
	}, [open]);
	const isMountedRef = import_react.useRef(false);
	index$3(() => {
		isMountedRef.current = true;
		return () => {
			isMountedRef.current = false;
		};
	}, []);
	index$3(() => {
		if (referenceEl) referenceRef.current = referenceEl;
		if (floatingEl) floatingRef.current = floatingEl;
		if (referenceEl && floatingEl) {
			if (whileElementsMountedRef.current) return whileElementsMountedRef.current(referenceEl, floatingEl, update);
			update();
		}
	}, [
		referenceEl,
		floatingEl,
		update,
		whileElementsMountedRef,
		hasWhileElementsMounted
	]);
	const refs = import_react.useMemo(() => ({
		reference: referenceRef,
		floating: floatingRef,
		setReference,
		setFloating
	}), [setReference, setFloating]);
	const elements = import_react.useMemo(() => ({
		reference: referenceEl,
		floating: floatingEl
	}), [referenceEl, floatingEl]);
	const floatingStyles = import_react.useMemo(() => {
		const initialStyles = {
			position: strategy,
			left: 0,
			top: 0
		};
		if (!elements.floating) return initialStyles;
		const x = roundByDPR(elements.floating, data.x);
		const y = roundByDPR(elements.floating, data.y);
		if (transform) return {
			...initialStyles,
			transform: "translate(" + x + "px, " + y + "px)",
			...getDPR(elements.floating) >= 1.5 && { willChange: "transform" }
		};
		return {
			position: strategy,
			left: x,
			top: y
		};
	}, [
		strategy,
		transform,
		elements.floating,
		data.x,
		data.y
	]);
	return import_react.useMemo(() => ({
		...data,
		update,
		refs,
		elements,
		floatingStyles
	}), [
		data,
		update,
		refs,
		elements,
		floatingStyles
	]);
}
/**
* Provides data to position an inner element of the floating element so that it
* appears centered to the reference element.
* This wraps the core `arrow` middleware to allow React refs as the element.
* @see https://floating-ui.com/docs/arrow
*/
const arrow$1$1 = (options$1) => {
	function isRef(value) {
		return {}.hasOwnProperty.call(value, "current");
	}
	return {
		name: "arrow",
		options: options$1,
		fn(state) {
			const { element, padding } = typeof options$1 === "function" ? options$1(state) : options$1;
			if (element && isRef(element)) {
				if (element.current != null) return arrow$1({
					element: element.current,
					padding
				}).fn(state);
				return {};
			}
			if (element) return arrow$1({
				element,
				padding
			}).fn(state);
			return {};
		}
	};
};
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
const offset = (options$1, deps) => ({
	...offset$1(options$1),
	options: [options$1, deps]
});
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
const shift = (options$1, deps) => ({
	...shift$1(options$1),
	options: [options$1, deps]
});
/**
* Built-in `limiter` that will stop `shift()` at a certain point.
*/
const limitShift = (options$1, deps) => ({
	...limitShift$1(options$1),
	options: [options$1, deps]
});
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
const flip = (options$1, deps) => ({
	...flip$1(options$1),
	options: [options$1, deps]
});
/**
* Provides data that allows you to change the size of the floating element â€”
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
const size = (options$1, deps) => ({
	...size$1(options$1),
	options: [options$1, deps]
});
/**
* Provides data to hide the floating element in applicable situations, such as
* when it is not in the same clipping context as the reference element.
* @see https://floating-ui.com/docs/hide
*/
const hide = (options$1, deps) => ({
	...hide$1(options$1),
	options: [options$1, deps]
});
/**
* Provides improved positioning for inline reference elements that can span
* over multiple lines, such as hyperlinks or range selections.
* @see https://floating-ui.com/docs/inline
*/
const inline = (options$1, deps) => ({
	...inline$1(options$1),
	options: [options$1, deps]
});
/**
* Provides data to position an inner element of the floating element so that it
* appears centered to the reference element.
* This wraps the core `arrow` middleware to allow React refs as the element.
* @see https://floating-ui.com/docs/arrow
*/
const arrow = (options$1, deps) => ({
	...arrow$1$1(options$1),
	options: [options$1, deps]
});

//#endregion
//#region node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_react_dom$2 = __toESM(require_react_dom(), 1);
/**
* Merges an array of refs into a single memoized callback ref or `null`.
* @see https://floating-ui.com/docs/react-utils#usemergerefs
*/
function useMergeRefs(refs) {
	return import_react.useMemo(() => {
		if (refs.every((ref) => ref == null)) return null;
		return (value) => {
			refs.forEach((ref) => {
				if (typeof ref === "function") ref(value);
				else if (ref != null) ref.current = value;
			});
		};
	}, refs);
}
const SafeReact = { ...import_react };
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
	const ref = import_react.useRef(() => {
		throw new Error("Cannot call an event handler while rendering.");
	});
	useSafeInsertionEffect(() => {
		ref.current = callback;
	});
	return import_react.useCallback(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		return ref.current == null ? void 0 : ref.current(...args);
	}, []);
}
const ARROW_UP = "ArrowUp";
const ARROW_DOWN = "ArrowDown";
const ARROW_LEFT = "ArrowLeft";
const ARROW_RIGHT = "ArrowRight";
var index$2 = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
const verticalKeys = [ARROW_UP, ARROW_DOWN];
const allKeys = [...horizontalKeys, ...verticalKeys];
let serverHandoffComplete = false;
let count = 0;
const genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
	const [id, setId] = import_react.useState(() => serverHandoffComplete ? genId() : void 0);
	index$2(() => {
		if (id == null) setId(genId());
	}, []);
	import_react.useEffect(() => {
		serverHandoffComplete = true;
	}, []);
	return id;
}
const useReactId = SafeReact.useId;
/**
* Uses React 18's built-in `useId()` when available, or falls back to a
* slightly less performant (requiring a double render) implementation for
* earlier React versions.
* @see https://floating-ui.com/docs/react-utils#useid
*/
const useId$2 = useReactId || useFloatingId;
let devMessageSet;
devMessageSet = /* @__PURE__ */ new Set();
function error() {
	var _devMessageSet3;
	for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) messages[_key2] = arguments[_key2];
	const message = "Floating UI: " + messages.join(" ");
	if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
		var _devMessageSet4;
		(_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
		console.error(message);
	}
}
function createPubSub() {
	const map = /* @__PURE__ */ new Map();
	return {
		emit(event, data) {
			var _map$get;
			(_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
		},
		on(event, listener) {
			map.set(event, [...map.get(event) || [], listener]);
		},
		off(event, listener) {
			var _map$get2;
			map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
		}
	};
}
const FloatingNodeContext = /* @__PURE__ */ import_react.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ import_react.createContext(null);
/**
* Returns the parent node id for nested floating elements, if available.
* Returns `null` for top-level floating elements.
*/
const useFloatingParentNodeId = () => {
	var _React$useContext;
	return ((_React$useContext = import_react.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
/**
* Returns the nearest floating tree context, if available.
*/
const useFloatingTree = () => import_react.useContext(FloatingTreeContext);
function createAttribute(name) {
	return "data-floating-ui-" + name;
}
function useLatestRef(value) {
	const ref = (0, import_react.useRef)(value);
	index$2(() => {
		ref.current = value;
	});
	return ref;
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
	if (pointerType && !isMouseLikePointerType(pointerType)) return 0;
	if (typeof value === "number") return value;
	return value == null ? void 0 : value[prop];
}
/**
* Opens the floating element while hovering over the reference element, like
* CSS `:hover`.
* @see https://floating-ui.com/docs/useHover
*/
function useHover(context, props) {
	if (props === void 0) props = {};
	const { open, onOpenChange, dataRef, events, elements } = context;
	const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;
	const tree = useFloatingTree();
	const parentId = useFloatingParentNodeId();
	const handleCloseRef = useLatestRef(handleClose);
	const delayRef = useLatestRef(delay);
	const openRef = useLatestRef(open);
	const pointerTypeRef = import_react.useRef();
	const timeoutRef = import_react.useRef(-1);
	const handlerRef = import_react.useRef();
	const restTimeoutRef = import_react.useRef(-1);
	const blockMouseMoveRef = import_react.useRef(true);
	const performedPointerEventsMutationRef = import_react.useRef(false);
	const unbindMouseMoveRef = import_react.useRef(() => {});
	const restTimeoutPendingRef = import_react.useRef(false);
	const isHoverOpen = import_react.useCallback(() => {
		var _dataRef$current$open;
		const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
		return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
	}, [dataRef]);
	import_react.useEffect(() => {
		if (!enabled) return;
		function onOpenChange$1(_ref) {
			let { open: open$1 } = _ref;
			if (!open$1) {
				clearTimeout(timeoutRef.current);
				clearTimeout(restTimeoutRef.current);
				blockMouseMoveRef.current = true;
				restTimeoutPendingRef.current = false;
			}
		}
		events.on("openchange", onOpenChange$1);
		return () => {
			events.off("openchange", onOpenChange$1);
		};
	}, [enabled, events]);
	import_react.useEffect(() => {
		if (!enabled) return;
		if (!handleCloseRef.current) return;
		if (!open) return;
		function onLeave(event) {
			if (isHoverOpen()) onOpenChange(false, event, "hover");
		}
		const html = getDocument(elements.floating).documentElement;
		html.addEventListener("mouseleave", onLeave);
		return () => {
			html.removeEventListener("mouseleave", onLeave);
		};
	}, [
		elements.floating,
		open,
		onOpenChange,
		enabled,
		handleCloseRef,
		isHoverOpen
	]);
	const closeWithDelay = import_react.useCallback(function(event, runElseBranch, reason) {
		if (runElseBranch === void 0) runElseBranch = true;
		if (reason === void 0) reason = "hover";
		const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
		if (closeDelay && !handlerRef.current) {
			clearTimeout(timeoutRef.current);
			timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
		} else if (runElseBranch) {
			clearTimeout(timeoutRef.current);
			onOpenChange(false, event, reason);
		}
	}, [delayRef, onOpenChange]);
	const cleanupMouseMoveHandler = useEffectEvent(() => {
		unbindMouseMoveRef.current();
		handlerRef.current = void 0;
	});
	const clearPointerEvents = useEffectEvent(() => {
		if (performedPointerEventsMutationRef.current) {
			const body = getDocument(elements.floating).body;
			body.style.pointerEvents = "";
			body.removeAttribute(safePolygonIdentifier);
			performedPointerEventsMutationRef.current = false;
		}
	});
	const isClickLikeOpenEvent = useEffectEvent(() => {
		return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
	});
	import_react.useEffect(() => {
		if (!enabled) return;
		function onMouseEnter(event) {
			clearTimeout(timeoutRef.current);
			blockMouseMoveRef.current = false;
			if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open")) return;
			const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
			if (openDelay) timeoutRef.current = window.setTimeout(() => {
				if (!openRef.current) onOpenChange(true, event, "hover");
			}, openDelay);
			else if (!open) onOpenChange(true, event, "hover");
		}
		function onMouseLeave(event) {
			if (isClickLikeOpenEvent()) return;
			unbindMouseMoveRef.current();
			const doc = getDocument(elements.floating);
			clearTimeout(restTimeoutRef.current);
			restTimeoutPendingRef.current = false;
			if (handleCloseRef.current && dataRef.current.floatingContext) {
				if (!open) clearTimeout(timeoutRef.current);
				handlerRef.current = handleCloseRef.current({
					...dataRef.current.floatingContext,
					tree,
					x: event.clientX,
					y: event.clientY,
					onClose() {
						clearPointerEvents();
						cleanupMouseMoveHandler();
						if (!isClickLikeOpenEvent()) closeWithDelay(event, true, "safe-polygon");
					}
				});
				const handler = handlerRef.current;
				doc.addEventListener("mousemove", handler);
				unbindMouseMoveRef.current = () => {
					doc.removeEventListener("mousemove", handler);
				};
				return;
			}
			const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
			if (shouldClose) closeWithDelay(event);
		}
		function onScrollMouseLeave(event) {
			if (isClickLikeOpenEvent()) return;
			if (!dataRef.current.floatingContext) return;
			handleCloseRef.current == null || handleCloseRef.current({
				...dataRef.current.floatingContext,
				tree,
				x: event.clientX,
				y: event.clientY,
				onClose() {
					clearPointerEvents();
					cleanupMouseMoveHandler();
					if (!isClickLikeOpenEvent()) closeWithDelay(event);
				}
			})(event);
		}
		if (isElement$1(elements.domReference)) {
			var _elements$floating;
			const ref = elements.domReference;
			open && ref.addEventListener("mouseleave", onScrollMouseLeave);
			(_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave);
			move && ref.addEventListener("mousemove", onMouseEnter, { once: true });
			ref.addEventListener("mouseenter", onMouseEnter);
			ref.addEventListener("mouseleave", onMouseLeave);
			return () => {
				var _elements$floating2;
				open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
				(_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave);
				move && ref.removeEventListener("mousemove", onMouseEnter);
				ref.removeEventListener("mouseenter", onMouseEnter);
				ref.removeEventListener("mouseleave", onMouseLeave);
			};
		}
	}, [
		elements,
		enabled,
		context,
		mouseOnly,
		restMs,
		move,
		closeWithDelay,
		cleanupMouseMoveHandler,
		clearPointerEvents,
		onOpenChange,
		open,
		openRef,
		tree,
		delayRef,
		handleCloseRef,
		dataRef,
		isClickLikeOpenEvent
	]);
	index$2(() => {
		var _handleCloseRef$curre;
		if (!enabled) return;
		if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
			performedPointerEventsMutationRef.current = true;
			const floatingEl = elements.floating;
			if (isElement$1(elements.domReference) && floatingEl) {
				var _tree$nodesRef$curren;
				const body = getDocument(elements.floating).body;
				body.setAttribute(safePolygonIdentifier, "");
				const ref = elements.domReference;
				const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
				if (parentFloating) parentFloating.style.pointerEvents = "";
				body.style.pointerEvents = "none";
				ref.style.pointerEvents = "auto";
				floatingEl.style.pointerEvents = "auto";
				return () => {
					body.style.pointerEvents = "";
					ref.style.pointerEvents = "";
					floatingEl.style.pointerEvents = "";
				};
			}
		}
	}, [
		enabled,
		open,
		parentId,
		elements,
		tree,
		handleCloseRef,
		isHoverOpen
	]);
	index$2(() => {
		if (!open) {
			pointerTypeRef.current = void 0;
			restTimeoutPendingRef.current = false;
			cleanupMouseMoveHandler();
			clearPointerEvents();
		}
	}, [
		open,
		cleanupMouseMoveHandler,
		clearPointerEvents
	]);
	import_react.useEffect(() => {
		return () => {
			cleanupMouseMoveHandler();
			clearTimeout(timeoutRef.current);
			clearTimeout(restTimeoutRef.current);
			clearPointerEvents();
		};
	}, [
		enabled,
		elements.domReference,
		cleanupMouseMoveHandler,
		clearPointerEvents
	]);
	const reference = import_react.useMemo(() => {
		function setPointerRef(event) {
			pointerTypeRef.current = event.pointerType;
		}
		return {
			onPointerDown: setPointerRef,
			onPointerEnter: setPointerRef,
			onMouseMove(event) {
				const { nativeEvent } = event;
				function handleMouseMove() {
					if (!blockMouseMoveRef.current && !openRef.current) onOpenChange(true, nativeEvent, "hover");
				}
				if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) return;
				if (open || restMs === 0) return;
				if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) return;
				clearTimeout(restTimeoutRef.current);
				if (pointerTypeRef.current === "touch") handleMouseMove();
				else {
					restTimeoutPendingRef.current = true;
					restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
				}
			}
		};
	}, [
		mouseOnly,
		onOpenChange,
		open,
		openRef,
		restMs
	]);
	const floating = import_react.useMemo(() => ({
		onMouseEnter() {
			clearTimeout(timeoutRef.current);
		},
		onMouseLeave(event) {
			if (!isClickLikeOpenEvent()) closeWithDelay(event.nativeEvent, false);
		}
	}), [closeWithDelay, isClickLikeOpenEvent]);
	return import_react.useMemo(() => enabled ? {
		reference,
		floating
	} : {}, [
		enabled,
		reference,
		floating
	]);
}
const NOOP = () => {};
const FloatingDelayGroupContext = /* @__PURE__ */ import_react.createContext({
	delay: 0,
	initialDelay: 0,
	timeoutMs: 0,
	currentId: null,
	setCurrentId: NOOP,
	setState: NOOP,
	isInstantPhase: false
});
/**
* @deprecated
* Use the return value of `useDelayGroup()` instead.
*/
const useDelayGroupContext = () => import_react.useContext(FloatingDelayGroupContext);
/**
* Provides context for a group of floating elements that should share a
* `delay`.
* @see https://floating-ui.com/docs/FloatingDelayGroup
*/
function FloatingDelayGroup(props) {
	const { children, delay, timeoutMs = 0 } = props;
	const [state, setState] = import_react.useReducer((prev, next) => ({
		...prev,
		...next
	}), {
		delay,
		timeoutMs,
		initialDelay: delay,
		currentId: null,
		isInstantPhase: false
	});
	const initialCurrentIdRef = import_react.useRef(null);
	const setCurrentId = import_react.useCallback((currentId) => {
		setState({ currentId });
	}, []);
	index$2(() => {
		if (state.currentId) {
			if (initialCurrentIdRef.current === null) initialCurrentIdRef.current = state.currentId;
			else if (!state.isInstantPhase) setState({ isInstantPhase: true });
		} else {
			if (state.isInstantPhase) setState({ isInstantPhase: false });
			initialCurrentIdRef.current = null;
		}
	}, [state.currentId, state.isInstantPhase]);
	return /* @__PURE__ */ import_react.createElement(FloatingDelayGroupContext.Provider, { value: import_react.useMemo(() => ({
		...state,
		setState,
		setCurrentId
	}), [state, setCurrentId]) }, children);
}
/**
* Enables grouping when called inside a component that's a child of a
* `FloatingDelayGroup`.
* @see https://floating-ui.com/docs/FloatingDelayGroup
*/
function useDelayGroup(context, options$1) {
	if (options$1 === void 0) options$1 = {};
	const { open, onOpenChange, floatingId } = context;
	const { id: optionId, enabled = true } = options$1;
	const id = optionId != null ? optionId : floatingId;
	const groupContext = useDelayGroupContext();
	const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = groupContext;
	index$2(() => {
		if (!enabled) return;
		if (!currentId) return;
		setState({ delay: {
			open: 1,
			close: getDelay(initialDelay, "close")
		} });
		if (currentId !== id) onOpenChange(false);
	}, [
		enabled,
		id,
		onOpenChange,
		setState,
		currentId,
		initialDelay
	]);
	index$2(() => {
		function unset() {
			onOpenChange(false);
			setState({
				delay: initialDelay,
				currentId: null
			});
		}
		if (!enabled) return;
		if (!currentId) return;
		if (!open && currentId === id) {
			if (timeoutMs) {
				const timeout = window.setTimeout(unset, timeoutMs);
				return () => {
					clearTimeout(timeout);
				};
			}
			unset();
		}
	}, [
		enabled,
		open,
		setState,
		currentId,
		id,
		onOpenChange,
		initialDelay,
		timeoutMs
	]);
	index$2(() => {
		if (!enabled) return;
		if (setCurrentId === NOOP || !open) return;
		setCurrentId(id);
	}, [
		enabled,
		open,
		setCurrentId,
		id
	]);
	return groupContext;
}
function getChildren(nodes, id) {
	let allChildren = nodes.filter((node) => {
		var _node$context;
		return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
	});
	let currentChildren = allChildren;
	while (currentChildren.length) {
		currentChildren = nodes.filter((node) => {
			var _currentChildren;
			return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
				var _node$context2;
				return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
			});
		});
		allChildren = allChildren.concat(currentChildren);
	}
	return allChildren;
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
const bubbleHandlerKeys = {
	pointerdown: "onPointerDown",
	mousedown: "onMouseDown",
	click: "onClick"
};
const captureHandlerKeys = {
	pointerdown: "onPointerDownCapture",
	mousedown: "onMouseDownCapture",
	click: "onClickCapture"
};
const normalizeProp = (normalizable) => {
	var _normalizable$escapeK, _normalizable$outside;
	return {
		escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
		outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
	};
};
/**
* Closes the floating element when a dismissal is requested â€” by default, when
* the user presses the `escape` key or outside of the floating element.
* @see https://floating-ui.com/docs/useDismiss
*/
function useDismiss(context, props) {
	if (props === void 0) props = {};
	const { open, onOpenChange, elements, dataRef } = context;
	const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = "pointerdown", referencePress = false, referencePressEvent = "pointerdown", ancestorScroll = false, bubbles, capture } = props;
	const tree = useFloatingTree();
	const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
	const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
	const insideReactTreeRef = import_react.useRef(false);
	const endedOrStartedInsideRef = import_react.useRef(false);
	const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);
	const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);
	const isComposingRef = import_react.useRef(false);
	const closeOnEscapeKeyDown = useEffectEvent((event) => {
		var _dataRef$current$floa;
		if (!open || !enabled || !escapeKey || event.key !== "Escape") return;
		if (isComposingRef.current) return;
		const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
		const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
		if (!escapeKeyBubbles) {
			event.stopPropagation();
			if (children.length > 0) {
				let shouldDismiss = true;
				children.forEach((child) => {
					var _child$context;
					if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
						shouldDismiss = false;
						return;
					}
				});
				if (!shouldDismiss) return;
			}
		}
		onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
	});
	const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
		var _getTarget2;
		const callback = () => {
			var _getTarget;
			closeOnEscapeKeyDown(event);
			(_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
		};
		(_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
	});
	const closeOnPressOutside = useEffectEvent((event) => {
		var _dataRef$current$floa2;
		const insideReactTree = insideReactTreeRef.current;
		insideReactTreeRef.current = false;
		const endedOrStartedInside = endedOrStartedInsideRef.current;
		endedOrStartedInsideRef.current = false;
		if (outsidePressEvent === "click" && endedOrStartedInside) return;
		if (insideReactTree) return;
		if (typeof outsidePress === "function" && !outsidePress(event)) return;
		const target = getTarget(event);
		const inertSelector = "[" + createAttribute("inert") + "]";
		const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
		let targetRootAncestor = isElement$1(target) ? target : null;
		while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
			const nextParent = getParentNode(targetRootAncestor);
			if (isLastTraversableNode(nextParent) || !isElement$1(nextParent)) break;
			targetRootAncestor = nextParent;
		}
		if (markers.length && isElement$1(target) && !isRootElement(target) && !contains(target, elements.floating) && Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) return;
		if (isHTMLElement(target) && floating) {
			const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
			const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
			let xCond = canScrollY && event.offsetX > target.clientWidth;
			if (canScrollY) {
				const isRTL$1 = getComputedStyle$1(target).direction === "rtl";
				if (isRTL$1) xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
			}
			if (xCond || canScrollX && event.offsetY > target.clientHeight) return;
		}
		const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
		const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
			var _node$context;
			return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
		});
		if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) return;
		const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
		if (children.length > 0) {
			let shouldDismiss = true;
			children.forEach((child) => {
				var _child$context2;
				if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
					shouldDismiss = false;
					return;
				}
			});
			if (!shouldDismiss) return;
		}
		onOpenChange(false, event, "outside-press");
	});
	const closeOnPressOutsideCapture = useEffectEvent((event) => {
		var _getTarget4;
		const callback = () => {
			var _getTarget3;
			closeOnPressOutside(event);
			(_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
		};
		(_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
	});
	import_react.useEffect(() => {
		if (!open || !enabled) return;
		dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
		dataRef.current.__outsidePressBubbles = outsidePressBubbles;
		let compositionTimeout = -1;
		function onScroll(event) {
			onOpenChange(false, event, "ancestor-scroll");
		}
		function handleCompositionStart() {
			window.clearTimeout(compositionTimeout);
			isComposingRef.current = true;
		}
		function handleCompositionEnd() {
			compositionTimeout = window.setTimeout(() => {
				isComposingRef.current = false;
			}, isWebKit() ? 5 : 0);
		}
		const doc = getDocument(elements.floating);
		if (escapeKey) {
			doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
			doc.addEventListener("compositionstart", handleCompositionStart);
			doc.addEventListener("compositionend", handleCompositionEnd);
		}
		outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
		let ancestors = [];
		if (ancestorScroll) {
			if (isElement$1(elements.domReference)) ancestors = getOverflowAncestors(elements.domReference);
			if (isElement$1(elements.floating)) ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
			if (!isElement$1(elements.reference) && elements.reference && elements.reference.contextElement) ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
		}
		ancestors = ancestors.filter((ancestor) => {
			var _doc$defaultView;
			return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
		});
		ancestors.forEach((ancestor) => {
			ancestor.addEventListener("scroll", onScroll, { passive: true });
		});
		return () => {
			if (escapeKey) {
				doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
				doc.removeEventListener("compositionstart", handleCompositionStart);
				doc.removeEventListener("compositionend", handleCompositionEnd);
			}
			outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
			ancestors.forEach((ancestor) => {
				ancestor.removeEventListener("scroll", onScroll);
			});
			window.clearTimeout(compositionTimeout);
		};
	}, [
		dataRef,
		elements,
		escapeKey,
		outsidePress,
		outsidePressEvent,
		open,
		onOpenChange,
		ancestorScroll,
		enabled,
		escapeKeyBubbles,
		outsidePressBubbles,
		closeOnEscapeKeyDown,
		escapeKeyCapture,
		closeOnEscapeKeyDownCapture,
		closeOnPressOutside,
		outsidePressCapture,
		closeOnPressOutsideCapture
	]);
	import_react.useEffect(() => {
		insideReactTreeRef.current = false;
	}, [outsidePress, outsidePressEvent]);
	const reference = import_react.useMemo(() => ({
		onKeyDown: closeOnEscapeKeyDown,
		[bubbleHandlerKeys[referencePressEvent]]: (event) => {
			if (referencePress) onOpenChange(false, event.nativeEvent, "reference-press");
		}
	}), [
		closeOnEscapeKeyDown,
		onOpenChange,
		referencePress,
		referencePressEvent
	]);
	const floating = import_react.useMemo(() => ({
		onKeyDown: closeOnEscapeKeyDown,
		onMouseDown() {
			endedOrStartedInsideRef.current = true;
		},
		onMouseUp() {
			endedOrStartedInsideRef.current = true;
		},
		[captureHandlerKeys[outsidePressEvent]]: () => {
			insideReactTreeRef.current = true;
		}
	}), [closeOnEscapeKeyDown, outsidePressEvent]);
	return import_react.useMemo(() => enabled ? {
		reference,
		floating
	} : {}, [
		enabled,
		reference,
		floating
	]);
}
function useFloatingRootContext(options$1) {
	const { open = false, onOpenChange: onOpenChangeProp, elements: elementsProp } = options$1;
	const floatingId = useId$2();
	const dataRef = import_react.useRef({});
	const [events] = import_react.useState(() => createPubSub());
	const nested = useFloatingParentNodeId() != null;
	{
		const optionDomReference = elementsProp.reference;
		if (optionDomReference && !isElement$1(optionDomReference)) error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
	}
	const [positionReference, setPositionReference] = import_react.useState(elementsProp.reference);
	const onOpenChange = useEffectEvent((open$1, event, reason) => {
		dataRef.current.openEvent = open$1 ? event : void 0;
		events.emit("openchange", {
			open: open$1,
			event,
			reason,
			nested
		});
		onOpenChangeProp?.(open$1, event, reason);
	});
	const refs = import_react.useMemo(() => ({ setPositionReference }), []);
	const elements = import_react.useMemo(() => ({
		reference: positionReference || elementsProp.reference || null,
		floating: elementsProp.floating || null,
		domReference: elementsProp.reference
	}), [
		positionReference,
		elementsProp.reference,
		elementsProp.floating
	]);
	return import_react.useMemo(() => ({
		dataRef,
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	}), [
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	]);
}
/**
* Provides data to position a floating element and context to add interactions.
* @see https://floating-ui.com/docs/useFloating
*/
function useFloating(options$1) {
	if (options$1 === void 0) options$1 = {};
	const { nodeId } = options$1;
	const internalRootContext = useFloatingRootContext({
		...options$1,
		elements: {
			reference: null,
			floating: null,
			...options$1.elements
		}
	});
	const rootContext = options$1.rootContext || internalRootContext;
	const computedElements = rootContext.elements;
	const [_domReference, setDomReference] = import_react.useState(null);
	const [positionReference, _setPositionReference] = import_react.useState(null);
	const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
	const domReference = optionDomReference || _domReference;
	const domReferenceRef = import_react.useRef(null);
	const tree = useFloatingTree();
	index$2(() => {
		if (domReference) domReferenceRef.current = domReference;
	}, [domReference]);
	const position = useFloating$1({
		...options$1,
		elements: {
			...computedElements,
			...positionReference && { reference: positionReference }
		}
	});
	const setPositionReference = import_react.useCallback((node) => {
		const computedPositionReference = isElement$1(node) ? {
			getBoundingClientRect: () => node.getBoundingClientRect(),
			contextElement: node
		} : node;
		_setPositionReference(computedPositionReference);
		position.refs.setReference(computedPositionReference);
	}, [position.refs]);
	const setReference = import_react.useCallback((node) => {
		if (isElement$1(node) || node === null) {
			domReferenceRef.current = node;
			setDomReference(node);
		}
		if (isElement$1(position.refs.reference.current) || position.refs.reference.current === null || node !== null && !isElement$1(node)) position.refs.setReference(node);
	}, [position.refs]);
	const refs = import_react.useMemo(() => ({
		...position.refs,
		setReference,
		setPositionReference,
		domReference: domReferenceRef
	}), [
		position.refs,
		setReference,
		setPositionReference
	]);
	const elements = import_react.useMemo(() => ({
		...position.elements,
		domReference
	}), [position.elements, domReference]);
	const context = import_react.useMemo(() => ({
		...position,
		...rootContext,
		refs,
		elements,
		nodeId
	}), [
		position,
		refs,
		elements,
		nodeId,
		rootContext
	]);
	index$2(() => {
		rootContext.dataRef.current.floatingContext = context;
		const node = tree == null ? void 0 : tree.nodesRef.current.find((node$1) => node$1.id === nodeId);
		if (node) node.context = context;
	});
	return import_react.useMemo(() => ({
		...position,
		context,
		refs,
		elements
	}), [
		position,
		refs,
		elements,
		context
	]);
}
/**
* Opens the floating element while the reference element has focus, like CSS
* `:focus`.
* @see https://floating-ui.com/docs/useFocus
*/
function useFocus(context, props) {
	if (props === void 0) props = {};
	const { open, onOpenChange, events, dataRef, elements } = context;
	const { enabled = true, visibleOnly = true } = props;
	const blockFocusRef = import_react.useRef(false);
	const timeoutRef = import_react.useRef();
	const keyboardModalityRef = import_react.useRef(true);
	import_react.useEffect(() => {
		if (!enabled) return;
		const win = getWindow(elements.domReference);
		function onBlur() {
			if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) blockFocusRef.current = true;
		}
		function onKeyDown() {
			keyboardModalityRef.current = true;
		}
		win.addEventListener("blur", onBlur);
		win.addEventListener("keydown", onKeyDown, true);
		return () => {
			win.removeEventListener("blur", onBlur);
			win.removeEventListener("keydown", onKeyDown, true);
		};
	}, [
		elements.domReference,
		open,
		enabled
	]);
	import_react.useEffect(() => {
		if (!enabled) return;
		function onOpenChange$1(_ref) {
			let { reason } = _ref;
			if (reason === "reference-press" || reason === "escape-key") blockFocusRef.current = true;
		}
		events.on("openchange", onOpenChange$1);
		return () => {
			events.off("openchange", onOpenChange$1);
		};
	}, [events, enabled]);
	import_react.useEffect(() => {
		return () => {
			clearTimeout(timeoutRef.current);
		};
	}, []);
	const reference = import_react.useMemo(() => ({
		onPointerDown(event) {
			if (isVirtualPointerEvent(event.nativeEvent)) return;
			keyboardModalityRef.current = false;
		},
		onMouseLeave() {
			blockFocusRef.current = false;
		},
		onFocus(event) {
			if (blockFocusRef.current) return;
			const target = getTarget(event.nativeEvent);
			if (visibleOnly && isElement$1(target)) try {
				if (isSafari() && isMac()) throw Error();
				if (!target.matches(":focus-visible")) return;
			} catch (e) {
				if (!keyboardModalityRef.current && !isTypeableElement(target)) return;
			}
			onOpenChange(true, event.nativeEvent, "focus");
		},
		onBlur(event) {
			blockFocusRef.current = false;
			const relatedTarget = event.relatedTarget;
			const nativeEvent = event.nativeEvent;
			const movedToFocusGuard = isElement$1(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
			timeoutRef.current = window.setTimeout(() => {
				var _dataRef$current$floa;
				const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
				if (!relatedTarget && activeEl === elements.domReference) return;
				if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) return;
				onOpenChange(false, nativeEvent, "focus");
			});
		}
	}), [
		dataRef,
		elements.domReference,
		onOpenChange,
		visibleOnly
	]);
	return import_react.useMemo(() => enabled ? { reference } : {}, [enabled, reference]);
}
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
	const map = /* @__PURE__ */ new Map();
	const isItem = elementKey === "item";
	let domUserProps = userProps;
	if (isItem && userProps) {
		const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __,...validProps } = userProps;
		domUserProps = validProps;
	}
	return {
		...elementKey === "floating" && {
			tabIndex: -1,
			[FOCUSABLE_ATTRIBUTE]: ""
		},
		...domUserProps,
		...propsList.map((value) => {
			const propsOrGetProps = value ? value[elementKey] : null;
			if (typeof propsOrGetProps === "function") return userProps ? propsOrGetProps(userProps) : null;
			return propsOrGetProps;
		}).concat(userProps).reduce((acc, props) => {
			if (!props) return acc;
			Object.entries(props).forEach((_ref) => {
				let [key, value] = _ref;
				if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) return;
				if (key.indexOf("on") === 0) {
					if (!map.has(key)) map.set(key, []);
					if (typeof value === "function") {
						var _map$get;
						(_map$get = map.get(key)) == null || _map$get.push(value);
						acc[key] = function() {
							var _map$get2;
							for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
							return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
						};
					}
				} else acc[key] = value;
			});
			return acc;
		}, {})
	};
}
/**
* Merges an array of interaction hooks' props into prop getters, allowing
* event handler functions to be composed together without overwriting one
* another.
* @see https://floating-ui.com/docs/useInteractions
*/
function useInteractions(propsList) {
	if (propsList === void 0) propsList = [];
	const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
	const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
	const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
	const getReferenceProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "reference"), referenceDeps);
	const getFloatingProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "floating"), floatingDeps);
	const getItemProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "item"), itemDeps);
	return import_react.useMemo(() => ({
		getReferenceProps,
		getFloatingProps,
		getItemProps
	}), [
		getReferenceProps,
		getFloatingProps,
		getItemProps
	]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([
	["select", "listbox"],
	["combobox", "listbox"],
	["label", false]
]);
/**
* Adds base screen reader props to the reference and floating elements for a
* given floating element `role`.
* @see https://floating-ui.com/docs/useRole
*/
function useRole(context, props) {
	var _componentRoleToAriaR;
	if (props === void 0) props = {};
	const { open, floatingId } = context;
	const { enabled = true, role = "dialog" } = props;
	const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
	const referenceId = useId$2();
	const parentId = useFloatingParentNodeId();
	const isNested = parentId != null;
	const reference = import_react.useMemo(() => {
		if (ariaRole === "tooltip" || role === "label") return { ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0 };
		return {
			"aria-expanded": open ? "true" : "false",
			"aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
			"aria-controls": open ? floatingId : void 0,
			...ariaRole === "listbox" && { role: "combobox" },
			...ariaRole === "menu" && { id: referenceId },
			...ariaRole === "menu" && isNested && { role: "menuitem" },
			...role === "select" && { "aria-autocomplete": "none" },
			...role === "combobox" && { "aria-autocomplete": "list" }
		};
	}, [
		ariaRole,
		floatingId,
		isNested,
		open,
		referenceId,
		role
	]);
	const floating = import_react.useMemo(() => {
		const floatingProps = {
			id: floatingId,
			...ariaRole && { role: ariaRole }
		};
		if (ariaRole === "tooltip" || role === "label") return floatingProps;
		return {
			...floatingProps,
			...ariaRole === "menu" && { "aria-labelledby": referenceId }
		};
	}, [
		ariaRole,
		floatingId,
		referenceId,
		role
	]);
	const item = import_react.useCallback((_ref) => {
		let { active, selected } = _ref;
		const commonProps = {
			role: "option",
			...active && { id: floatingId + "-option" }
		};
		switch (role) {
			case "select": return {
				...commonProps,
				"aria-selected": active && selected
			};
			case "combobox": return {
				...commonProps,
				...active && { "aria-selected": true }
			};
		}
		return {};
	}, [floatingId, role]);
	return import_react.useMemo(() => enabled ? {
		reference,
		floating,
		item
	} : {}, [
		enabled,
		reference,
		floating,
		item
	]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.context.mjs
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext("ScrollArea.Root component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/use-resize-observer.mjs
function useResizeObserver(element, onResize) {
	const handleResize = useCallbackRef(onResize);
	useIsomorphicEffect(() => {
		let rAF = 0;
		if (element) {
			const resizeObserver = new ResizeObserver(() => {
				cancelAnimationFrame(rAF);
				rAF = window.requestAnimationFrame(handleResize);
			});
			resizeObserver.observe(element);
			return () => {
				window.cancelAnimationFrame(rAF);
				resizeObserver.unobserve(element);
			};
		}
		return void 0;
	}, [element, handleResize]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.mjs
const Corner = (0, import_react.forwardRef)((props, ref) => {
	const { style,...others } = props;
	const ctx = useScrollAreaContext();
	const [width, setWidth] = (0, import_react.useState)(0);
	const [height, setHeight] = (0, import_react.useState)(0);
	const hasSize = Boolean(width && height);
	useResizeObserver(ctx.scrollbarX, () => {
		const h = ctx.scrollbarX?.offsetHeight || 0;
		ctx.onCornerHeightChange(h);
		setHeight(h);
	});
	useResizeObserver(ctx.scrollbarY, () => {
		const w = ctx.scrollbarY?.offsetWidth || 0;
		ctx.onCornerWidthChange(w);
		setWidth(w);
	});
	return hasSize ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...others,
		ref,
		style: {
			...style,
			width,
			height
		}
	}) : null;
});
const ScrollAreaCorner = (0, import_react.forwardRef)((props, ref) => {
	const ctx = useScrollAreaContext();
	const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);
	const hasCorner = ctx.type !== "scroll" && hasBothScrollbarsVisible;
	return hasCorner ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Corner, {
		...props,
		ref
	}) : null;
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.mjs
const defaultProps$186 = {
	scrollHideDelay: 1e3,
	type: "hover"
};
const ScrollAreaRoot = (0, import_react.forwardRef)((_props, ref) => {
	const { type, scrollHideDelay, scrollbars, getStyles: getStyles$1,...others } = useProps("ScrollAreaRoot", defaultProps$186, _props);
	const [scrollArea, setScrollArea] = (0, import_react.useState)(null);
	const [viewport, setViewport] = (0, import_react.useState)(null);
	const [content, setContent] = (0, import_react.useState)(null);
	const [scrollbarX, setScrollbarX] = (0, import_react.useState)(null);
	const [scrollbarY, setScrollbarY] = (0, import_react.useState)(null);
	const [cornerWidth, setCornerWidth] = (0, import_react.useState)(0);
	const [cornerHeight, setCornerHeight] = (0, import_react.useState)(0);
	const [scrollbarXEnabled, setScrollbarXEnabled] = (0, import_react.useState)(false);
	const [scrollbarYEnabled, setScrollbarYEnabled] = (0, import_react.useState)(false);
	const rootRef = useMergedRef(ref, (node) => setScrollArea(node));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaProvider, {
		value: {
			type,
			scrollHideDelay,
			scrollArea,
			viewport,
			onViewportChange: setViewport,
			content,
			onContentChange: setContent,
			scrollbarX,
			onScrollbarXChange: setScrollbarX,
			scrollbarXEnabled,
			onScrollbarXEnabledChange: setScrollbarXEnabled,
			scrollbarY,
			onScrollbarYChange: setScrollbarY,
			scrollbarYEnabled,
			onScrollbarYEnabledChange: setScrollbarYEnabled,
			onCornerWidthChange: setCornerWidth,
			onCornerHeightChange: setCornerHeight,
			getStyles: getStyles$1
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...others,
			ref: rootRef,
			__vars: {
				"--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
				"--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
			}
		})
	});
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-ratio.mjs
function getThumbRatio(viewportSize, contentSize) {
	const ratio = viewportSize / contentSize;
	return Number.isNaN(ratio) ? 0 : ratio;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-size.mjs
function getThumbSize(sizes$1) {
	const ratio = getThumbRatio(sizes$1.viewport, sizes$1.content);
	const scrollbarPadding = sizes$1.scrollbar.paddingStart + sizes$1.scrollbar.paddingEnd;
	const thumbSize = (sizes$1.scrollbar.size - scrollbarPadding) * ratio;
	return Math.max(thumbSize, 18);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/linear-scale.mjs
function linearScale(input, output) {
	return (value) => {
		if (input[0] === input[1] || output[0] === output[1]) return output[0];
		const ratio = (output[1] - output[0]) / (input[1] - input[0]);
		return output[0] + ratio * (value - input[0]);
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-offset-from-scroll.mjs
function clamp$2(value, [min$1, max$1]) {
	return Math.min(max$1, Math.max(min$1, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes$1, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes$1);
	const scrollbarPadding = sizes$1.scrollbar.paddingStart + sizes$1.scrollbar.paddingEnd;
	const scrollbar = sizes$1.scrollbar.size - scrollbarPadding;
	const maxScrollPos = sizes$1.content - sizes$1.viewport;
	const maxThumbPos = scrollbar - thumbSizePx;
	const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
	const scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
	const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
	return interpolate(scrollWithoutMomentum);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-scroll-position-from-pointer.mjs
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes$1, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes$1);
	const thumbCenter = thumbSizePx / 2;
	const offset$3 = pointerOffset || thumbCenter;
	const thumbOffsetFromEnd = thumbSizePx - offset$3;
	const minPointerPos = sizes$1.scrollbar.paddingStart + offset$3;
	const maxPointerPos = sizes$1.scrollbar.size - sizes$1.scrollbar.paddingEnd - thumbOffsetFromEnd;
	const maxScrollPos = sizes$1.content - sizes$1.viewport;
	const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
	const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
	return interpolate(pointerPos);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.mjs
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
	return scrollPos > 0 && scrollPos < maxScrollPos;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/to-int.mjs
function toInt(value) {
	return value ? parseInt(value, 10) : 0;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/compose-event-handlers.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
	return (event) => {
		originalEventHandler?.(event);
		if (checkForDefaultPrevented === false || !event.defaultPrevented) ourEventHandler?.(event);
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.mjs
const [ScrollbarProvider, useScrollbarContext] = createSafeContext("ScrollAreaScrollbar was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.mjs
const Scrollbar = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes: sizes$1, hasThumb, onThumbChange, onThumbPointerUp, onThumbPointerDown, onThumbPositionChange, onDragScroll, onWheelScroll, onResize,...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const [scrollbar, setScrollbar] = (0, import_react.useState)(null);
	const composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node));
	const rectRef = (0, import_react.useRef)(null);
	const prevWebkitUserSelectRef = (0, import_react.useRef)("");
	const { viewport } = context;
	const maxScrollPos = sizes$1.content - sizes$1.viewport;
	const handleWheelScroll = useCallbackRef(onWheelScroll);
	const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
	const handleResize = useDebouncedCallback(onResize, 10);
	const handleDragScroll = (event) => {
		if (rectRef.current) {
			const x = event.clientX - rectRef.current.left;
			const y = event.clientY - rectRef.current.top;
			onDragScroll({
				x,
				y
			});
		}
	};
	(0, import_react.useEffect)(() => {
		const handleWheel = (event) => {
			const element = event.target;
			const isScrollbarWheel = scrollbar?.contains(element);
			if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
		};
		document.addEventListener("wheel", handleWheel, { passive: false });
		return () => document.removeEventListener("wheel", handleWheel, { passive: false });
	}, [
		viewport,
		scrollbar,
		maxScrollPos,
		handleWheelScroll
	]);
	(0, import_react.useEffect)(handleThumbPositionChange, [sizes$1, handleThumbPositionChange]);
	useResizeObserver(scrollbar, handleResize);
	useResizeObserver(context.content, handleResize);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollbarProvider, {
		value: {
			scrollbar,
			hasThumb,
			onThumbChange: useCallbackRef(onThumbChange),
			onThumbPointerUp: useCallbackRef(onThumbPointerUp),
			onThumbPositionChange: handleThumbPositionChange,
			onThumbPointerDown: useCallbackRef(onThumbPointerDown)
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...scrollbarProps,
			ref: composeRefs,
			"data-mantine-scrollbar": true,
			style: {
				position: "absolute",
				...scrollbarProps.style
			},
			onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
				event.preventDefault();
				const mainPointer = 0;
				if (event.button === mainPointer) {
					const element = event.target;
					element.setPointerCapture(event.pointerId);
					rectRef.current = scrollbar.getBoundingClientRect();
					prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
					document.body.style.webkitUserSelect = "none";
					handleDragScroll(event);
				}
			}),
			onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
			onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
				const element = event.target;
				if (element.hasPointerCapture(event.pointerId)) {
					event.preventDefault();
					element.releasePointerCapture(event.pointerId);
				}
			}),
			onLostPointerCapture: () => {
				document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
				rectRef.current = null;
			}
		})
	});
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.mjs
const ScrollAreaScrollbarX = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes: sizes$1, onSizesChange, style,...others } = props;
	const ctx = useScrollAreaContext();
	const [computedStyle, setComputedStyle] = (0, import_react.useState)();
	const ref = (0, import_react.useRef)(null);
	const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
	(0, import_react.useEffect)(() => {
		if (ref.current) setComputedStyle(getComputedStyle(ref.current));
	}, [ref]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scrollbar, {
		"data-orientation": "horizontal",
		...others,
		ref: composeRefs,
		sizes: sizes$1,
		style: {
			...style,
			["--sa-thumb-width"]: `${getThumbSize(sizes$1)}px`
		},
		onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
		onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
		onWheelScroll: (event, maxScrollPos) => {
			if (ctx.viewport) {
				const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
				props.onWheelScroll(scrollPos);
				if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();
			}
		},
		onResize: () => {
			if (ref.current && ctx.viewport && computedStyle) onSizesChange({
				content: ctx.viewport.scrollWidth,
				viewport: ctx.viewport.offsetWidth,
				scrollbar: {
					size: ref.current.clientWidth,
					paddingStart: toInt(computedStyle.paddingLeft),
					paddingEnd: toInt(computedStyle.paddingRight)
				}
			});
		}
	});
});
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.mjs
const ScrollAreaScrollbarY = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes: sizes$1, onSizesChange, style,...others } = props;
	const context = useScrollAreaContext();
	const [computedStyle, setComputedStyle] = (0, import_react.useState)();
	const ref = (0, import_react.useRef)(null);
	const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
	(0, import_react.useEffect)(() => {
		if (ref.current) setComputedStyle(window.getComputedStyle(ref.current));
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scrollbar, {
		...others,
		"data-orientation": "vertical",
		ref: composeRefs,
		sizes: sizes$1,
		style: {
			["--sa-thumb-height"]: `${getThumbSize(sizes$1)}px`,
			...style
		},
		onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
		onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
		onWheelScroll: (event, maxScrollPos) => {
			if (context.viewport) {
				const scrollPos = context.viewport.scrollTop + event.deltaY;
				props.onWheelScroll(scrollPos);
				if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();
			}
		},
		onResize: () => {
			if (ref.current && context.viewport && computedStyle) onSizesChange({
				content: context.viewport.scrollHeight,
				viewport: context.viewport.offsetHeight,
				scrollbar: {
					size: ref.current.clientHeight,
					paddingStart: toInt(computedStyle.paddingTop),
					paddingEnd: toInt(computedStyle.paddingBottom)
				}
			});
		}
	});
});
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.mjs
const ScrollAreaScrollbarVisible = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { orientation = "vertical",...scrollbarProps } = props;
	const { dir } = useDirection();
	const context = useScrollAreaContext();
	const thumbRef = (0, import_react.useRef)(null);
	const pointerOffsetRef = (0, import_react.useRef)(0);
	const [sizes$1, setSizes] = (0, import_react.useState)({
		content: 0,
		viewport: 0,
		scrollbar: {
			size: 0,
			paddingStart: 0,
			paddingEnd: 0
		}
	});
	const thumbRatio = getThumbRatio(sizes$1.viewport, sizes$1.content);
	const commonProps = {
		...scrollbarProps,
		sizes: sizes$1,
		onSizesChange: setSizes,
		hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
		onThumbChange: (thumb) => {
			thumbRef.current = thumb;
		},
		onThumbPointerUp: () => {
			pointerOffsetRef.current = 0;
		},
		onThumbPointerDown: (pointerPos) => {
			pointerOffsetRef.current = pointerPos;
		}
	};
	const getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes$1, direction);
	if (orientation === "horizontal") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarX, {
		...commonProps,
		ref: forwardedRef,
		onThumbPositionChange: () => {
			if (context.viewport && thumbRef.current) {
				const scrollPos = context.viewport.scrollLeft;
				const offset$3 = getThumbOffsetFromScroll(scrollPos, sizes$1, dir);
				thumbRef.current.style.transform = `translate3d(${offset$3}px, 0, 0)`;
			}
		},
		onWheelScroll: (scrollPos) => {
			if (context.viewport) context.viewport.scrollLeft = scrollPos;
		},
		onDragScroll: (pointerPos) => {
			if (context.viewport) context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);
		}
	});
	if (orientation === "vertical") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarY, {
		...commonProps,
		ref: forwardedRef,
		onThumbPositionChange: () => {
			if (context.viewport && thumbRef.current) {
				const scrollPos = context.viewport.scrollTop;
				const offset$3 = getThumbOffsetFromScroll(scrollPos, sizes$1);
				if (sizes$1.scrollbar.size === 0) thumbRef.current.style.setProperty("--thumb-opacity", "0");
				else thumbRef.current.style.setProperty("--thumb-opacity", "1");
				thumbRef.current.style.transform = `translate3d(0, ${offset$3}px, 0)`;
			}
		},
		onWheelScroll: (scrollPos) => {
			if (context.viewport) context.viewport.scrollTop = scrollPos;
		},
		onDragScroll: (pointerPos) => {
			if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
		}
	});
	return null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.mjs
const ScrollAreaScrollbarAuto = (0, import_react.forwardRef)((props, ref) => {
	const context = useScrollAreaContext();
	const { forceMount,...scrollbarProps } = props;
	const [visible, setVisible] = (0, import_react.useState)(false);
	const isHorizontal = props.orientation === "horizontal";
	const handleResize = useDebouncedCallback(() => {
		if (context.viewport) {
			const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
			const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
			setVisible(isHorizontal ? isOverflowX : isOverflowY);
		}
	}, 10);
	useResizeObserver(context.viewport, handleResize);
	useResizeObserver(context.content, handleResize);
	if (forceMount || visible) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		"data-state": visible ? "visible" : "hidden",
		...scrollbarProps,
		ref
	});
	return null;
});
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.mjs
const ScrollAreaScrollbarHover = (0, import_react.forwardRef)((props, ref) => {
	const { forceMount,...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const [visible, setVisible] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		const { scrollArea } = context;
		let hideTimer = 0;
		if (scrollArea) {
			const handlePointerEnter = () => {
				window.clearTimeout(hideTimer);
				setVisible(true);
			};
			const handlePointerLeave = () => {
				hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
			};
			scrollArea.addEventListener("pointerenter", handlePointerEnter);
			scrollArea.addEventListener("pointerleave", handlePointerLeave);
			return () => {
				window.clearTimeout(hideTimer);
				scrollArea.removeEventListener("pointerenter", handlePointerEnter);
				scrollArea.removeEventListener("pointerleave", handlePointerLeave);
			};
		}
		return void 0;
	}, [context.scrollArea, context.scrollHideDelay]);
	if (forceMount || visible) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, {
		"data-state": visible ? "visible" : "hidden",
		...scrollbarProps,
		ref
	});
	return null;
});
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.mjs
const ScrollAreaScrollbarScroll = (0, import_react.forwardRef)((props, red) => {
	const { forceMount,...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const isHorizontal = props.orientation === "horizontal";
	const [state, setState] = (0, import_react.useState)("hidden");
	const debounceScrollEnd = useDebouncedCallback(() => setState("idle"), 100);
	(0, import_react.useEffect)(() => {
		if (state === "idle") {
			const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
			return () => window.clearTimeout(hideTimer);
		}
		return void 0;
	}, [state, context.scrollHideDelay]);
	(0, import_react.useEffect)(() => {
		const { viewport } = context;
		const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
		if (viewport) {
			let prevScrollPos = viewport[scrollDirection];
			const handleScroll$1 = () => {
				const scrollPos = viewport[scrollDirection];
				const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
				if (hasScrollInDirectionChanged) {
					setState("scrolling");
					debounceScrollEnd();
				}
				prevScrollPos = scrollPos;
			};
			viewport.addEventListener("scroll", handleScroll$1);
			return () => viewport.removeEventListener("scroll", handleScroll$1);
		}
		return void 0;
	}, [
		context.viewport,
		isHorizontal,
		debounceScrollEnd
	]);
	if (forceMount || state !== "hidden") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		"data-state": state === "hidden" ? "hidden" : "visible",
		...scrollbarProps,
		ref: red,
		onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
		onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
	});
	return null;
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.mjs
const ScrollAreaScrollbar = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { forceMount,...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
	const isHorizontal = props.orientation === "horizontal";
	(0, import_react.useEffect)(() => {
		isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
		return () => {
			isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
		};
	}, [
		isHorizontal,
		onScrollbarXEnabledChange,
		onScrollbarYEnabledChange
	]);
	return context.type === "hover" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarHover, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "scroll" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarScroll, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "auto" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "always" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		...scrollbarProps,
		ref: forwardedRef
	}) : null;
});
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/add-unlinked-scroll-listener.mjs
function addUnlinkedScrollListener(node, handler = () => {}) {
	let prevPosition = {
		left: node.scrollLeft,
		top: node.scrollTop
	};
	let rAF = 0;
	(function loop() {
		const position = {
			left: node.scrollLeft,
			top: node.scrollTop
		};
		const isHorizontalScroll = prevPosition.left !== position.left;
		const isVerticalScroll = prevPosition.top !== position.top;
		if (isHorizontalScroll || isVerticalScroll) handler();
		prevPosition = position;
		rAF = window.requestAnimationFrame(loop);
	})();
	return () => window.cancelAnimationFrame(rAF);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.mjs
const Thumb$2 = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { style,...others } = props;
	const scrollAreaContext = useScrollAreaContext();
	const scrollbarContext = useScrollbarContext();
	const { onThumbPositionChange } = scrollbarContext;
	const composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node));
	const removeUnlinkedScrollListenerRef = (0, import_react.useRef)(void 0);
	const debounceScrollEnd = useDebouncedCallback(() => {
		if (removeUnlinkedScrollListenerRef.current) {
			removeUnlinkedScrollListenerRef.current();
			removeUnlinkedScrollListenerRef.current = void 0;
		}
	}, 100);
	(0, import_react.useEffect)(() => {
		const { viewport } = scrollAreaContext;
		if (viewport) {
			const handleScroll$1 = () => {
				debounceScrollEnd();
				if (!removeUnlinkedScrollListenerRef.current) {
					const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
					removeUnlinkedScrollListenerRef.current = listener;
					onThumbPositionChange();
				}
			};
			onThumbPositionChange();
			viewport.addEventListener("scroll", handleScroll$1);
			return () => viewport.removeEventListener("scroll", handleScroll$1);
		}
		return void 0;
	}, [
		scrollAreaContext.viewport,
		debounceScrollEnd,
		onThumbPositionChange
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
		...others,
		ref: composedRef,
		style: {
			width: "var(--sa-thumb-width)",
			height: "var(--sa-thumb-height)",
			...style
		},
		onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
			const thumb = event.target;
			const thumbRect = thumb.getBoundingClientRect();
			const x = event.clientX - thumbRect.left;
			const y = event.clientY - thumbRect.top;
			scrollbarContext.onThumbPointerDown({
				x,
				y
			});
		}),
		onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
	});
});
Thumb$2.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { forceMount,...thumbProps } = props;
	const scrollbarContext = useScrollbarContext();
	if (forceMount || scrollbarContext.hasThumb) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb$2, {
		ref: forwardedRef,
		...thumbProps
	});
	return null;
});
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.mjs
const ScrollAreaViewport = (0, import_react.forwardRef)(({ children, style,...others }, ref) => {
	const ctx = useScrollAreaContext();
	const rootRef = useMergedRef(ref, ctx.onViewportChange);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		ref: rootRef,
		style: {
			overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
			overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
			...style
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...ctx.getStyles("content"),
			ref: ctx.onContentChange,
			children
		})
	});
});
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.module.css.mjs
var classes$86 = {
	"root": "m_d57069b5",
	"viewport": "m_c0783ff9",
	"viewportInner": "m_f8f631dd",
	"scrollbar": "m_c44ba933",
	"thumb": "m_d8b5e363",
	"corner": "m_21657268",
	"content": "m_b1336c6"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.mjs
const defaultProps$185 = {
	scrollHideDelay: 1e3,
	type: "hover",
	scrollbars: "xy"
};
const varsResolver$89 = createVarsResolver((_, { scrollbarSize, overscrollBehavior }) => ({ root: {
	"--scrollarea-scrollbar-size": rem(scrollbarSize),
	"--scrollarea-over-scroll-behavior": overscrollBehavior
} }));
const ScrollArea = factory((_props, ref) => {
	const props = useProps("ScrollArea", defaultProps$185, _props);
	const { classNames, className, style, styles, unstyled, scrollbarSize, vars, type, scrollHideDelay, viewportProps, viewportRef, onScrollPositionChange, children, offsetScrollbars, scrollbars, onBottomReached, onTopReached, overscrollBehavior,...others } = props;
	const [scrollbarHovered, setScrollbarHovered] = (0, import_react.useState)(false);
	const [verticalThumbVisible, setVerticalThumbVisible] = (0, import_react.useState)(false);
	const [horizontalThumbVisible, setHorizontalThumbVisible] = (0, import_react.useState)(false);
	const getStyles$1 = useStyles({
		name: "ScrollArea",
		props,
		classes: classes$86,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$89
	});
	const localViewportRef = (0, import_react.useRef)(null);
	const combinedViewportRef = useMergeRefs([viewportRef, localViewportRef]);
	(0, import_react.useEffect)(() => {
		if (!localViewportRef.current) return;
		if (offsetScrollbars !== "present") return;
		const element = localViewportRef.current;
		const observer = new ResizeObserver(() => {
			const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
			setVerticalThumbVisible(scrollHeight > clientHeight);
			setHorizontalThumbVisible(scrollWidth > clientWidth);
		});
		observer.observe(element);
		return () => observer.disconnect();
	}, [localViewportRef, offsetScrollbars]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ScrollAreaRoot, {
		getStyles: getStyles$1,
		type: type === "never" ? "always" : type,
		scrollHideDelay,
		ref,
		scrollbars,
		...getStyles$1("root"),
		...others,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaViewport, {
				...viewportProps,
				...getStyles$1("viewport", { style: viewportProps?.style }),
				ref: combinedViewportRef,
				"data-offset-scrollbars": offsetScrollbars === true ? "xy" : offsetScrollbars || void 0,
				"data-scrollbars": scrollbars || void 0,
				"data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : void 0,
				"data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : void 0,
				onScroll: (e) => {
					viewportProps?.onScroll?.(e);
					onScrollPositionChange?.({
						x: e.currentTarget.scrollLeft,
						y: e.currentTarget.scrollTop
					});
					const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
					if (scrollTop - (scrollHeight - clientHeight) >= -.6) onBottomReached?.();
					if (scrollTop === 0) onTopReached?.();
				},
				children
			}),
			(scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbar, {
				...getStyles$1("scrollbar"),
				orientation: "horizontal",
				"data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? true : void 0,
				forceMount: true,
				onMouseEnter: () => setScrollbarHovered(true),
				onMouseLeave: () => setScrollbarHovered(false),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaThumb, { ...getStyles$1("thumb") })
			}),
			(scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbar, {
				...getStyles$1("scrollbar"),
				orientation: "vertical",
				"data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? true : void 0,
				forceMount: true,
				onMouseEnter: () => setScrollbarHovered(true),
				onMouseLeave: () => setScrollbarHovered(false),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaThumb, { ...getStyles$1("thumb") })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaCorner, {
				...getStyles$1("corner"),
				"data-hovered": scrollbarHovered || void 0,
				"data-hidden": type === "never" || void 0
			})
		]
	});
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
	const { children, classNames, styles, scrollbarSize, scrollHideDelay, type, dir, offsetScrollbars, viewportRef, onScrollPositionChange, unstyled, variant, viewportProps, scrollbars, style, vars, onBottomReached, onTopReached,...others } = useProps("ScrollAreaAutosize", defaultProps$185, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		ref,
		style: [{
			display: "flex",
			overflow: "auto"
		}, style],
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			style: {
				display: "flex",
				flexDirection: "column",
				flex: 1
			},
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollArea, {
				classNames,
				styles,
				scrollHideDelay,
				scrollbarSize,
				type,
				dir,
				offsetScrollbars,
				viewportRef,
				onScrollPositionChange,
				unstyled,
				variant,
				viewportProps,
				vars,
				scrollbars,
				onBottomReached,
				onTopReached,
				children
			})
		})
	});
});
ScrollArea.classes = classes$86;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$86;
ScrollArea.Autosize = ScrollAreaAutosize;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.module.css.mjs
var classes$85 = { "root": "m_87cf2631" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.mjs
const defaultProps$184 = { __staticSelector: "UnstyledButton" };
const UnstyledButton = polymorphicFactory((_props, ref) => {
	const props = useProps("UnstyledButton", defaultProps$184, _props);
	const { className, component = "button", __staticSelector, unstyled, classNames, styles, style,...others } = props;
	const getStyles$1 = useStyles({
		name: __staticSelector,
		props,
		classes: classes$85,
		className,
		style,
		classNames,
		styles,
		unstyled
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root", { focusable: true }),
		component,
		ref,
		type: component === "button" ? "button" : void 0,
		...others
	});
});
UnstyledButton.classes = classes$85;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/VisuallyHidden/VisuallyHidden.module.css.mjs
var classes$84 = { "root": "m_515a97f8" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/VisuallyHidden/VisuallyHidden.mjs
const defaultProps$183 = {};
const VisuallyHidden = factory((_props, ref) => {
	const props = useProps("VisuallyHidden", defaultProps$183, _props);
	const { classNames, className, style, styles, unstyled, vars,...others } = props;
	const getStyles$1 = useStyles({
		name: "VisuallyHidden",
		classes: classes$84,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "span",
		ref,
		...getStyles$1("root"),
		...others
	});
});
VisuallyHidden.classes = classes$84;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Paper/Paper.module.css.mjs
var classes$83 = { "root": "m_1b7284a3" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Paper/Paper.mjs
const defaultProps$182 = {};
const varsResolver$88 = createVarsResolver((_, { radius, shadow }) => ({ root: {
	"--paper-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--paper-shadow": getShadow(shadow)
} }));
const Paper = polymorphicFactory((_props, ref) => {
	const props = useProps("Paper", defaultProps$182, _props);
	const { classNames, className, style, styles, unstyled, withBorder, vars, radius, shadow, variant, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Paper",
		props,
		classes: classes$83,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$88
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{ "data-with-border": withBorder }, mod],
		...getStyles$1("root"),
		variant,
		...others
	});
});
Paper.classes = classes$83;
Paper.displayName = "@mantine/core/Paper";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Floating/get-floating-position/get-floating-position.mjs
function getFloatingPosition(dir, position) {
	if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
		const [side, placement] = position.split("-");
		const flippedPosition = side === "right" ? "left" : "right";
		return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
	}
	return position;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Floating/FloatingArrow/get-arrow-position-styles.mjs
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
	if (placement === "center" || arrowPosition === "center") return { top: arrowY };
	if (placement === "end") return { bottom: arrowOffset };
	if (placement === "start") return { top: arrowOffset };
	return {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
	if (placement === "center" || arrowPosition === "center") return { left: arrowX };
	if (placement === "end") return { [dir === "ltr" ? "right" : "left"]: arrowOffset };
	if (placement === "start") return { [dir === "ltr" ? "left" : "right"]: arrowOffset };
	return {};
}
const radiusByFloatingSide = {
	bottom: "borderTopLeftRadius",
	left: "borderTopRightRadius",
	right: "borderBottomLeftRadius",
	top: "borderBottomRightRadius"
};
function getArrowPositionStyles({ position, arrowSize, arrowOffset, arrowRadius, arrowPosition, arrowX, arrowY, dir }) {
	const [side, placement = "center"] = position.split("-");
	const baseStyles = {
		width: arrowSize,
		height: arrowSize,
		transform: "rotate(45deg)",
		position: "absolute",
		[radiusByFloatingSide[side]]: arrowRadius
	};
	const arrowPlacement = -arrowSize / 2;
	if (side === "left") return {
		...baseStyles,
		...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
		right: arrowPlacement,
		borderLeftColor: "transparent",
		borderBottomColor: "transparent",
		clipPath: "polygon(100% 0, 0 0, 100% 100%)"
	};
	if (side === "right") return {
		...baseStyles,
		...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
		left: arrowPlacement,
		borderRightColor: "transparent",
		borderTopColor: "transparent",
		clipPath: "polygon(0 100%, 0 0, 100% 100%)"
	};
	if (side === "top") return {
		...baseStyles,
		...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
		bottom: arrowPlacement,
		borderTopColor: "transparent",
		borderLeftColor: "transparent",
		clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
	};
	if (side === "bottom") return {
		...baseStyles,
		...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
		top: arrowPlacement,
		borderBottomColor: "transparent",
		borderRightColor: "transparent",
		clipPath: "polygon(0 100%, 0 0, 100% 0)"
	};
	return {};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Floating/FloatingArrow/FloatingArrow.mjs
const FloatingArrow = (0, import_react.forwardRef)(({ position, arrowSize, arrowOffset, arrowRadius, arrowPosition, visible, arrowX, arrowY, style,...others }, ref) => {
	const { dir } = useDirection();
	if (!visible) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...others,
		ref,
		style: {
			...style,
			...getArrowPositionStyles({
				position,
				arrowSize,
				arrowOffset,
				arrowRadius,
				arrowPosition,
				dir,
				arrowX,
				arrowY
			})
		}
	});
});
FloatingArrow.displayName = "@mantine/core/FloatingArrow";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Overlay/Overlay.module.css.mjs
var classes$82 = { "root": "m_9814e45f" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Overlay/Overlay.mjs
const defaultProps$181 = { zIndex: getDefaultZIndex("modal") };
const varsResolver$87 = createVarsResolver((_, { gradient, color, backgroundOpacity, blur, radius, zIndex }) => ({ root: {
	"--overlay-bg": gradient || (color !== void 0 || backgroundOpacity !== void 0) && rgba(color || "#000", backgroundOpacity ?? .6) || void 0,
	"--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
	"--overlay-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--overlay-z-index": zIndex?.toString()
} }));
const Overlay = polymorphicFactory((_props, ref) => {
	const props = useProps("Overlay", defaultProps$181, _props);
	const { classNames, className, style, styles, unstyled, vars, fixed, center, children, radius, zIndex, gradient, blur, color, backgroundOpacity, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Overlay",
		props,
		classes: classes$82,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$87
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		mod: [{
			center,
			fixed
		}, mod],
		...others,
		children
	});
});
Overlay.classes = classes$82;
Overlay.displayName = "@mantine/core/Overlay";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Portal/Portal.mjs
var import_react_dom$1 = __toESM(require_react_dom(), 1);
function createPortalNode(props) {
	const node = document.createElement("div");
	node.setAttribute("data-portal", "true");
	typeof props.className === "string" && node.classList.add(...props.className.split(" ").filter(Boolean));
	typeof props.style === "object" && Object.assign(node.style, props.style);
	typeof props.id === "string" && node.setAttribute("id", props.id);
	return node;
}
function getTargetNode({ target, reuseTargetNode,...others }) {
	if (target) {
		if (typeof target === "string") return document.querySelector(target) || createPortalNode(others);
		return target;
	}
	if (reuseTargetNode) {
		const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
		if (existingNode) return existingNode;
		const node = createPortalNode(others);
		node.setAttribute("data-mantine-shared-portal-node", "true");
		document.body.appendChild(node);
		return node;
	}
	return createPortalNode(others);
}
const defaultProps$180 = { reuseTargetNode: true };
const Portal = factory((props, ref) => {
	const { children, target, reuseTargetNode,...others } = useProps("Portal", defaultProps$180, props);
	const [mounted, setMounted] = (0, import_react.useState)(false);
	const nodeRef = (0, import_react.useRef)(null);
	useIsomorphicEffect(() => {
		setMounted(true);
		nodeRef.current = getTargetNode({
			target,
			reuseTargetNode,
			...others
		});
		assignRef(ref, nodeRef.current);
		if (!target && !reuseTargetNode && nodeRef.current) document.body.appendChild(nodeRef.current);
		return () => {
			if (!target && !reuseTargetNode && nodeRef.current) document.body.removeChild(nodeRef.current);
		};
	}, [target]);
	if (!mounted || !nodeRef.current) return null;
	return (0, import_react_dom$1.createPortal)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Portal/OptionalPortal.mjs
const OptionalPortal = factory(({ withinPortal = true, children,...others }, ref) => {
	const env = useMantineEnv();
	if (env === "test" || !withinPortal) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, {
		ref,
		...others,
		children
	});
});
OptionalPortal.displayName = "@mantine/core/OptionalPortal";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Transition/transitions.mjs
const popIn = (from) => ({
	in: {
		opacity: 1,
		transform: "scale(1)"
	},
	out: {
		opacity: 0,
		transform: `scale(.9) translateY(${from === "bottom" ? 10 : -10}px)`
	},
	transitionProperty: "transform, opacity"
});
const transitions$1 = {
	fade: {
		in: { opacity: 1 },
		out: { opacity: 0 },
		transitionProperty: "opacity"
	},
	"fade-up": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-down": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-left": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-right": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(-30px)"
		},
		transitionProperty: "opacity, transform"
	},
	scale: {
		in: {
			opacity: 1,
			transform: "scale(1)"
		},
		out: {
			opacity: 0,
			transform: "scale(0)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"scale-y": {
		in: {
			opacity: 1,
			transform: "scaleY(1)"
		},
		out: {
			opacity: 0,
			transform: "scaleY(0)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"scale-x": {
		in: {
			opacity: 1,
			transform: "scaleX(1)"
		},
		out: {
			opacity: 0,
			transform: "scaleX(0)"
		},
		common: { transformOrigin: "left" },
		transitionProperty: "transform, opacity"
	},
	"skew-up": {
		in: {
			opacity: 1,
			transform: "translateY(0) skew(0deg, 0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-20px) skew(-10deg, -5deg)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"skew-down": {
		in: {
			opacity: 1,
			transform: "translateY(0) skew(0deg, 0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) skew(-10deg, -5deg)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"rotate-left": {
		in: {
			opacity: 1,
			transform: "translateY(0) rotate(0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) rotate(-5deg)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"rotate-right": {
		in: {
			opacity: 1,
			transform: "translateY(0) rotate(0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) rotate(5deg)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"slide-down": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-100%)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"slide-up": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(100%)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"slide-left": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(100%)"
		},
		common: { transformOrigin: "left" },
		transitionProperty: "transform, opacity"
	},
	"slide-right": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(-100%)"
		},
		common: { transformOrigin: "right" },
		transitionProperty: "transform, opacity"
	},
	pop: {
		...popIn("bottom"),
		common: { transformOrigin: "center center" }
	},
	"pop-bottom-left": {
		...popIn("bottom"),
		common: { transformOrigin: "bottom left" }
	},
	"pop-bottom-right": {
		...popIn("bottom"),
		common: { transformOrigin: "bottom right" }
	},
	"pop-top-left": {
		...popIn("top"),
		common: { transformOrigin: "top left" }
	},
	"pop-top-right": {
		...popIn("top"),
		common: { transformOrigin: "top right" }
	}
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Transition/get-transition-styles/get-transition-styles.mjs
const transitionStatuses = {
	entering: "in",
	entered: "in",
	exiting: "out",
	exited: "out",
	"pre-exiting": "out",
	"pre-entering": "out"
};
function getTransitionStyles({ transition, state, duration, timingFunction }) {
	const shared = {
		WebkitBackfaceVisibility: "hidden",
		willChange: "transform, opacity",
		transitionDuration: `${duration}ms`,
		transitionTimingFunction: timingFunction
	};
	if (typeof transition === "string") {
		if (!(transition in transitions$1)) return {};
		return {
			transitionProperty: transitions$1[transition].transitionProperty,
			...shared,
			...transitions$1[transition].common,
			...transitions$1[transition][transitionStatuses[state]]
		};
	}
	return {
		transitionProperty: transition.transitionProperty,
		...shared,
		...transition.common,
		...transition[transitionStatuses[state]]
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Transition/use-transition.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
function useTransition({ duration, exitDuration, timingFunction, mounted, onEnter, onExit, onEntered, onExited, enterDelay, exitDelay }) {
	const theme = useMantineTheme();
	const shouldReduceMotion = useReducedMotion();
	const reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : false;
	const [transitionDuration, setTransitionDuration] = (0, import_react.useState)(reduceMotion ? 0 : duration);
	const [transitionStatus, setStatus] = (0, import_react.useState)(mounted ? "entered" : "exited");
	const transitionTimeoutRef = (0, import_react.useRef)(-1);
	const delayTimeoutRef = (0, import_react.useRef)(-1);
	const rafRef = (0, import_react.useRef)(-1);
	function clearAllTimeouts() {
		window.clearTimeout(transitionTimeoutRef.current);
		window.clearTimeout(delayTimeoutRef.current);
		cancelAnimationFrame(rafRef.current);
	}
	const handleStateChange = (shouldMount) => {
		clearAllTimeouts();
		const preHandler = shouldMount ? onEnter : onExit;
		const handler = shouldMount ? onEntered : onExited;
		const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
		setTransitionDuration(newTransitionDuration);
		if (newTransitionDuration === 0) {
			typeof preHandler === "function" && preHandler();
			typeof handler === "function" && handler();
			setStatus(shouldMount ? "entered" : "exited");
		} else rafRef.current = requestAnimationFrame(() => {
			import_react_dom.default.flushSync(() => {
				setStatus(shouldMount ? "pre-entering" : "pre-exiting");
			});
			rafRef.current = requestAnimationFrame(() => {
				typeof preHandler === "function" && preHandler();
				setStatus(shouldMount ? "entering" : "exiting");
				transitionTimeoutRef.current = window.setTimeout(() => {
					typeof handler === "function" && handler();
					setStatus(shouldMount ? "entered" : "exited");
				}, newTransitionDuration);
			});
		});
	};
	const handleTransitionWithDelay = (shouldMount) => {
		clearAllTimeouts();
		const delay = shouldMount ? enterDelay : exitDelay;
		if (typeof delay !== "number") {
			handleStateChange(shouldMount);
			return;
		}
		delayTimeoutRef.current = window.setTimeout(() => {
			handleStateChange(shouldMount);
		}, shouldMount ? enterDelay : exitDelay);
	};
	useDidUpdate(() => {
		handleTransitionWithDelay(mounted);
	}, [mounted]);
	(0, import_react.useEffect)(() => () => {
		clearAllTimeouts();
	}, []);
	return {
		transitionDuration,
		transitionStatus,
		transitionTimingFunction: timingFunction || "ease"
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Transition/Transition.mjs
function Transition({ keepMounted, transition = "fade", duration = 250, exitDuration = duration, mounted, children, timingFunction = "ease", onExit, onEntered, onEnter, onExited, enterDelay, exitDelay }) {
	const env = useMantineEnv();
	const { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
		mounted,
		exitDuration,
		duration,
		timingFunction,
		onExit,
		onEntered,
		onEnter,
		onExited,
		enterDelay,
		exitDelay
	});
	if (transitionDuration === 0 || env === "test") return mounted ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children({}) }) : keepMounted ? children({ display: "none" }) : null;
	return transitionStatus === "exited" ? keepMounted ? children({ display: "none" }) : null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(getTransitionStyles({
		transition,
		duration: transitionDuration,
		state: transitionStatus,
		timingFunction: transitionTimingFunction
	})) });
}
Transition.displayName = "@mantine/core/Transition";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/Popover.context.mjs
const [PopoverContextProvider, usePopoverContext] = createSafeContext("Popover component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FocusTrap/FocusTrap.mjs
function FocusTrap({ children, active = true, refProp = "ref", innerRef }) {
	const focusTrapRef = useFocusTrap(active);
	const ref = useMergedRef(focusTrapRef, innerRef);
	if (!isElement(children)) return children;
	return (0, import_react.cloneElement)(children, { [refProp]: ref });
}
function FocusTrapInitialFocus(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(VisuallyHidden, {
		tabIndex: -1,
		"data-autofocus": true,
		...props
	});
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/Popover.module.css.mjs
var classes$81 = {
	"dropdown": "m_38a85659",
	"arrow": "m_a31dc6c1",
	"overlay": "m_3d7bc908"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/PopoverDropdown/PopoverDropdown.mjs
const defaultProps$179 = {};
const PopoverDropdown = factory((_props, ref) => {
	const props = useProps("PopoverDropdown", defaultProps$179, _props);
	const { className, style, vars, children, onKeyDownCapture, variant, classNames, styles,...others } = props;
	const ctx = usePopoverContext();
	const returnFocus = useFocusReturn({
		opened: ctx.opened,
		shouldReturnFocus: ctx.returnFocus
	});
	const accessibleProps = ctx.withRoles ? {
		"aria-labelledby": ctx.getTargetId(),
		id: ctx.getDropdownId(),
		role: "dialog",
		tabIndex: -1
	} : {};
	const mergedRef = useMergedRef(ref, ctx.floating);
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...ctx.portalProps,
		withinPortal: ctx.withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: ctx.opened,
			...ctx.transitionProps,
			transition: ctx.transitionProps?.transition || "fade",
			duration: ctx.transitionProps?.duration ?? 150,
			keepMounted: ctx.keepMounted,
			exitDuration: typeof ctx.transitionProps?.exitDuration === "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusTrap, {
				active: ctx.trapFocus && ctx.opened,
				innerRef: mergedRef,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
					...accessibleProps,
					...others,
					variant,
					onKeyDownCapture: closeOnEscape(() => {
						ctx.onClose?.();
						ctx.onDismiss?.();
					}, {
						active: ctx.closeOnEscape,
						onTrigger: returnFocus,
						onKeyDown: onKeyDownCapture
					}),
					"data-position": ctx.placement,
					"data-fixed": ctx.floatingStrategy === "fixed" || void 0,
					...ctx.getStyles("dropdown", {
						className,
						props,
						classNames,
						styles,
						style: [
							{
								...transitionStyles,
								zIndex: ctx.zIndex,
								top: ctx.y ?? 0,
								left: ctx.x ?? 0,
								width: ctx.width === "target" ? void 0 : rem(ctx.width),
								...ctx.referenceHidden ? { display: "none" } : null
							},
							ctx.resolvedStyles.dropdown,
							styles?.dropdown,
							style
						]
					}),
					children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FloatingArrow, {
						ref: ctx.arrowRef,
						arrowX: ctx.arrowX,
						arrowY: ctx.arrowY,
						visible: ctx.withArrow,
						position: ctx.placement,
						arrowSize: ctx.arrowSize,
						arrowRadius: ctx.arrowRadius,
						arrowOffset: ctx.arrowOffset,
						arrowPosition: ctx.arrowPosition,
						...ctx.getStyles("arrow", {
							props,
							classNames,
							styles
						})
					})]
				})
			})
		})
	});
});
PopoverDropdown.classes = classes$81;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/PopoverTarget/PopoverTarget.mjs
const defaultProps$178 = {
	refProp: "ref",
	popupType: "dialog"
};
const PopoverTarget = factory((props, ref) => {
	const { children, refProp, popupType,...others } = useProps("PopoverTarget", defaultProps$178, props);
	if (!isElement(children)) throw new Error("Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const forwardedProps = others;
	const ctx = usePopoverContext();
	const targetRef = useMergedRef(ctx.reference, getRefProp(children), ref);
	const accessibleProps = ctx.withRoles ? {
		"aria-haspopup": popupType,
		"aria-expanded": ctx.opened,
		"aria-controls": ctx.getDropdownId(),
		id: ctx.getTargetId()
	} : {};
	return (0, import_react.cloneElement)(children, {
		...forwardedProps,
		...accessibleProps,
		...ctx.targetProps,
		className: clsx_default(ctx.targetProps.className, forwardedProps.className, children.props.className),
		[refProp]: targetRef,
		...!ctx.controlled ? { onClick: ctx.onToggle } : null
	});
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Floating/use-floating-auto-update.mjs
function useFloatingAutoUpdate({ opened, floating, position, positionDependencies }) {
	const [delayedUpdate, setDelayedUpdate] = (0, import_react.useState)(0);
	(0, import_react.useEffect)(() => {
		if (floating.refs.reference.current && floating.refs.floating.current && opened) return autoUpdate(floating.refs.reference.current, floating.refs.floating.current, floating.update);
		return void 0;
	}, [
		floating.refs.reference.current,
		floating.refs.floating.current,
		opened,
		delayedUpdate,
		position
	]);
	useDidUpdate(() => {
		floating.update();
	}, positionDependencies);
	useDidUpdate(() => {
		setDelayedUpdate((c) => c + 1);
	}, [opened]);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/use-popover.mjs
function getDefaultMiddlewares$1(middlewares) {
	if (middlewares === void 0) return {
		shift: true,
		flip: true
	};
	const result = { ...middlewares };
	if (middlewares.shift === void 0) result.shift = true;
	if (middlewares.flip === void 0) result.flip = true;
	return result;
}
function getPopoverMiddlewares(options$1, getFloating) {
	const middlewaresOptions = getDefaultMiddlewares$1(options$1.middlewares);
	const middlewares = [offset(options$1.offset), hide()];
	if (middlewaresOptions.shift) middlewares.push(shift(typeof middlewaresOptions.shift === "boolean" ? {
		limiter: limitShift(),
		padding: 5
	} : {
		limiter: limitShift(),
		padding: 5,
		...middlewaresOptions.shift
	}));
	if (middlewaresOptions.flip) middlewares.push(typeof middlewaresOptions.flip === "boolean" ? flip() : flip(middlewaresOptions.flip));
	if (middlewaresOptions.inline) middlewares.push(typeof middlewaresOptions.inline === "boolean" ? inline() : inline(middlewaresOptions.inline));
	middlewares.push(arrow({
		element: options$1.arrowRef,
		padding: options$1.arrowOffset
	}));
	if (middlewaresOptions.size || options$1.width === "target") middlewares.push(size({
		...typeof middlewaresOptions.size === "boolean" ? {} : middlewaresOptions.size,
		apply({ rects, availableWidth, availableHeight,...rest }) {
			const floating = getFloating();
			const styles = floating.refs.floating.current?.style ?? {};
			if (middlewaresOptions.size) if (typeof middlewaresOptions.size === "object" && !!middlewaresOptions.size.apply) middlewaresOptions.size.apply({
				rects,
				availableWidth,
				availableHeight,
				...rest
			});
			else Object.assign(styles, {
				maxWidth: `${availableWidth}px`,
				maxHeight: `${availableHeight}px`
			});
			if (options$1.width === "target") Object.assign(styles, { width: `${rects.reference.width}px` });
		}
	}));
	return middlewares;
}
function usePopover(options$1) {
	const [_opened, setOpened] = useUncontrolled({
		value: options$1.opened,
		defaultValue: options$1.defaultOpened,
		finalValue: false,
		onChange: options$1.onChange
	});
	const previouslyOpened = (0, import_react.useRef)(_opened);
	const onClose = () => {
		if (_opened && !options$1.disabled) setOpened(false);
	};
	const onToggle = () => !options$1.disabled && setOpened(!_opened);
	const floating = useFloating({
		strategy: options$1.strategy,
		placement: options$1.position,
		middleware: getPopoverMiddlewares(options$1, () => floating)
	});
	useFloatingAutoUpdate({
		opened: _opened,
		position: options$1.position,
		positionDependencies: options$1.positionDependencies || [],
		floating
	});
	useDidUpdate(() => {
		options$1.onPositionChange?.(floating.placement);
	}, [floating.placement]);
	useDidUpdate(() => {
		if (_opened !== previouslyOpened.current) if (!_opened) options$1.onClose?.();
		else options$1.onOpen?.();
		previouslyOpened.current = _opened;
	}, [
		_opened,
		options$1.onClose,
		options$1.onOpen
	]);
	return {
		floating,
		controlled: typeof options$1.opened === "boolean",
		opened: _opened,
		onClose,
		onToggle
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Popover/Popover.mjs
const defaultProps$177 = {
	position: "bottom",
	offset: 8,
	positionDependencies: [],
	transitionProps: {
		transition: "fade",
		duration: 150
	},
	middlewares: {
		flip: true,
		shift: true,
		inline: false
	},
	arrowSize: 7,
	arrowOffset: 5,
	arrowRadius: 0,
	arrowPosition: "side",
	closeOnClickOutside: true,
	withinPortal: true,
	closeOnEscape: true,
	trapFocus: false,
	withRoles: true,
	returnFocus: false,
	withOverlay: false,
	hideDetached: true,
	clickOutsideEvents: ["mousedown", "touchstart"],
	zIndex: getDefaultZIndex("popover"),
	__staticSelector: "Popover",
	width: "max-content"
};
const varsResolver$86 = createVarsResolver((_, { radius, shadow }) => ({ dropdown: {
	"--popover-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--popover-shadow": getShadow(shadow)
} }));
function Popover(_props) {
	const props = useProps("Popover", defaultProps$177, _props);
	const { children, position, offset: offset$3, onPositionChange, positionDependencies, opened, transitionProps, onExitTransitionEnd, onEnterTransitionEnd, width, middlewares, withArrow, arrowSize, arrowOffset, arrowRadius, arrowPosition, unstyled, classNames, styles, closeOnClickOutside, withinPortal, portalProps, closeOnEscape: closeOnEscape$1, clickOutsideEvents, trapFocus, onClose, onDismiss, onOpen, onChange, zIndex, radius, shadow, id, defaultOpened, __staticSelector, withRoles, disabled, returnFocus, variant, keepMounted, vars, floatingStrategy, withOverlay, overlayProps, hideDetached,...others } = props;
	const getStyles$1 = useStyles({
		name: __staticSelector,
		props,
		classes: classes$81,
		classNames,
		styles,
		unstyled,
		rootSelector: "dropdown",
		vars,
		varsResolver: varsResolver$86
	});
	const { resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const arrowRef = (0, import_react.useRef)(null);
	const [targetNode, setTargetNode] = (0, import_react.useState)(null);
	const [dropdownNode, setDropdownNode] = (0, import_react.useState)(null);
	const { dir } = useDirection();
	const env = useMantineEnv();
	const uid = useId(id);
	const popover = usePopover({
		middlewares,
		width,
		position: getFloatingPosition(dir, position),
		offset: typeof offset$3 === "number" ? offset$3 + (withArrow ? arrowSize / 2 : 0) : offset$3,
		arrowRef,
		arrowOffset,
		onPositionChange,
		positionDependencies,
		opened,
		defaultOpened,
		onChange,
		onOpen,
		onClose,
		onDismiss,
		strategy: floatingStrategy,
		disabled
	});
	useClickOutside(() => {
		if (closeOnClickOutside) {
			popover.onClose();
			onDismiss?.();
		}
	}, clickOutsideEvents, [targetNode, dropdownNode]);
	const reference = (0, import_react.useCallback)((node) => {
		setTargetNode(node);
		popover.floating.refs.setReference(node);
	}, [popover.floating.refs.setReference]);
	const floating = (0, import_react.useCallback)((node) => {
		setDropdownNode(node);
		popover.floating.refs.setFloating(node);
	}, [popover.floating.refs.setFloating]);
	const onExited = (0, import_react.useCallback)(() => {
		transitionProps?.onExited?.();
		onExitTransitionEnd?.();
	}, [transitionProps?.onExited, onExitTransitionEnd]);
	const onEntered = (0, import_react.useCallback)(() => {
		transitionProps?.onEntered?.();
		onEnterTransitionEnd?.();
	}, [transitionProps?.onEntered, onEnterTransitionEnd]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(PopoverContextProvider, {
		value: {
			returnFocus,
			disabled,
			controlled: popover.controlled,
			reference,
			floating,
			x: popover.floating.x,
			y: popover.floating.y,
			arrowX: popover.floating?.middlewareData?.arrow?.x,
			arrowY: popover.floating?.middlewareData?.arrow?.y,
			opened: popover.opened,
			arrowRef,
			transitionProps: {
				...transitionProps,
				onExited,
				onEntered
			},
			width,
			withArrow,
			arrowSize,
			arrowOffset,
			arrowRadius,
			arrowPosition,
			placement: popover.floating.placement,
			trapFocus,
			withinPortal,
			portalProps,
			zIndex,
			radius,
			shadow,
			closeOnEscape: closeOnEscape$1,
			onDismiss,
			onClose: popover.onClose,
			onToggle: popover.onToggle,
			getTargetId: () => `${uid}-target`,
			getDropdownId: () => `${uid}-dropdown`,
			withRoles,
			targetProps: others,
			__staticSelector,
			classNames,
			styles,
			unstyled,
			variant,
			keepMounted,
			getStyles: getStyles$1,
			resolvedStyles,
			floatingStrategy,
			referenceHidden: hideDetached && env !== "test" ? popover.floating.middlewareData.hide?.referenceHidden : false
		},
		children: [children, withOverlay && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			transition: "fade",
			mounted: popover.opened,
			duration: transitionProps?.duration || 250,
			exitDuration: transitionProps?.exitDuration || 250,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
				withinPortal,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
					...overlayProps,
					...getStyles$1("overlay", {
						className: overlayProps?.className,
						style: [transitionStyles, overlayProps?.style]
					})
				})
			})
		})]
	});
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Loader/Loader.module.css.mjs
var classes$80 = {
	"root": "m_5ae2e3c",
	"barsLoader": "m_7a2bd4cd",
	"bar": "m_870bb79",
	"bars-loader-animation": "m_5d2b3b9d",
	"dotsLoader": "m_4e3f22d7",
	"dot": "m_870c4af",
	"loader-dots-animation": "m_aac34a1",
	"ovalLoader": "m_b34414df",
	"oval-loader-animation": "m_f8e89c4b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Loader/loaders/Bars.mjs
const Bars = (0, import_react.forwardRef)(({ className,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
	component: "span",
	className: clsx_default(classes$80.barsLoader, className),
	...others,
	ref,
	children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.bar }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.bar }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.bar })
	]
}));
Bars.displayName = "@mantine/core/Bars";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Loader/loaders/Dots.mjs
const Dots = (0, import_react.forwardRef)(({ className,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
	component: "span",
	className: clsx_default(classes$80.dotsLoader, className),
	...others,
	ref,
	children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.dot }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.dot }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$80.dot })
	]
}));
Dots.displayName = "@mantine/core/Dots";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Loader/loaders/Oval.mjs
const Oval = (0, import_react.forwardRef)(({ className,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
	component: "span",
	className: clsx_default(classes$80.ovalLoader, className),
	...others,
	ref
}));
Oval.displayName = "@mantine/core/Oval";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Loader/Loader.mjs
const defaultLoaders = {
	bars: Bars,
	oval: Oval,
	dots: Dots
};
const defaultProps$176 = {
	loaders: defaultLoaders,
	type: "oval"
};
const varsResolver$85 = createVarsResolver((theme, { size: size$3, color }) => ({ root: {
	"--loader-size": getSize(size$3, "loader-size"),
	"--loader-color": color ? getThemeColor(color, theme) : void 0
} }));
const Loader = factory((_props, ref) => {
	const props = useProps("Loader", defaultProps$176, _props);
	const { size: size$3, color, type, vars, className, style, classNames, styles, unstyled, loaders, variant, children,...others } = props;
	const getStyles$1 = useStyles({
		name: "Loader",
		props,
		classes: classes$80,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$85
	});
	if (children) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		ref,
		...others,
		children
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		ref,
		component: loaders[type],
		variant,
		size: size$3,
		...others
	});
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$80;
Loader.displayName = "@mantine/core/Loader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.module.css.mjs
var classes$79 = {
	"root": "m_8d3f4000",
	"icon": "m_8d3afb97",
	"loader": "m_302b9fb1",
	"group": "m_1a0f1b21",
	"groupSection": "m_437b6484"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ActionIcon/ActionIconGroup/ActionIconGroup.mjs
const defaultProps$175 = { orientation: "horizontal" };
const varsResolver$84 = createVarsResolver((_, { borderWidth }) => ({ group: { "--ai-border-width": rem(borderWidth) } }));
const ActionIconGroup = factory((_props, ref) => {
	const props = useProps("ActionIconGroup", defaultProps$175, _props);
	const { className, style, classNames, styles, unstyled, orientation, vars, borderWidth, variant, mod,...others } = useProps("ActionIconGroup", defaultProps$175, _props);
	const getStyles$1 = useStyles({
		name: "ActionIconGroup",
		props,
		classes: classes$79,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$84,
		rootSelector: "group"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("group"),
		ref,
		variant,
		mod: [{ "data-orientation": orientation }, mod],
		role: "group",
		...others
	});
});
ActionIconGroup.classes = classes$79;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ActionIcon/ActionIconGroupSection/ActionIconGroupSection.mjs
const defaultProps$174 = {};
const varsResolver$83 = createVarsResolver((theme, { radius, color, gradient, variant, autoContrast, size: size$3 }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { groupSection: {
		"--section-height": getSize(size$3, "section-height"),
		"--section-padding-x": getSize(size$3, "section-padding-x"),
		"--section-fz": getFontSize(size$3),
		"--section-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--section-bg": color || variant ? colors.background : void 0,
		"--section-color": colors.color,
		"--section-bd": color || variant ? colors.border : void 0
	} };
});
const ActionIconGroupSection = factory((_props, ref) => {
	const props = useProps("ActionIconGroupSection", defaultProps$174, _props);
	const { className, style, classNames, styles, unstyled, vars, variant, gradient, radius, autoContrast,...others } = useProps("ActionIconGroupSection", defaultProps$174, _props);
	const getStyles$1 = useStyles({
		name: "ActionIconGroupSection",
		props,
		classes: classes$79,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$83,
		rootSelector: "groupSection"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("groupSection"),
		ref,
		variant,
		...others
	});
});
ActionIconGroupSection.classes = classes$79;
ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.mjs
const defaultProps$173 = {};
const varsResolver$82 = createVarsResolver((theme, { size: size$3, radius, variant, gradient, color, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--ai-size": getSize(size$3, "ai-size"),
		"--ai-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--ai-bg": color || variant ? colors.background : void 0,
		"--ai-hover": color || variant ? colors.hover : void 0,
		"--ai-hover-color": color || variant ? colors.hoverColor : void 0,
		"--ai-color": colors.color,
		"--ai-bd": color || variant ? colors.border : void 0
	} };
});
const ActionIcon = polymorphicFactory((_props, ref) => {
	const props = useProps("ActionIcon", defaultProps$173, _props);
	const { className, unstyled, variant, classNames, styles, style, loading, loaderProps, size: size$3, color, radius, __staticSelector, gradient, vars, children, disabled, "data-disabled": dataDisabled, autoContrast, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: ["ActionIcon", __staticSelector],
		props,
		className,
		style,
		classes: classes$79,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$82
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...getStyles$1("root", { active: !disabled && !loading && !dataDisabled }),
		...others,
		unstyled,
		variant,
		size: size$3,
		disabled: disabled || loading,
		ref,
		mod: [{
			loading,
			disabled: disabled || dataDisabled
		}, mod],
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: !!loading,
			transition: "slide-down",
			duration: 150,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				...getStyles$1("loader", { style: transitionStyles }),
				"aria-hidden": true,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
					color: "var(--ai-color)",
					size: "calc(var(--ai-size) * 0.55)",
					...loaderProps
				})
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			component: "span",
			mod: { loading },
			...getStyles$1("icon"),
			children
		})]
	});
});
ActionIcon.classes = classes$79;
ActionIcon.displayName = "@mantine/core/ActionIcon";
ActionIcon.Group = ActionIconGroup;
ActionIcon.GroupSection = ActionIconGroupSection;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/CloseButton/CloseIcon.mjs
const CloseIcon = (0, import_react.forwardRef)(({ size: size$3 = "var(--cb-icon-size, 70%)", style,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
	viewBox: "0 0 15 15",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	style: {
		...style,
		width: size$3,
		height: size$3
	},
	ref,
	...others,
	children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
		d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
		fill: "currentColor",
		fillRule: "evenodd",
		clipRule: "evenodd"
	})
}));
CloseIcon.displayName = "@mantine/core/CloseIcon";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/CloseButton/CloseButton.module.css.mjs
var classes$78 = {
	"root": "m_86a44da5",
	"root--subtle": "m_220c80f2"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/CloseButton/CloseButton.mjs
const defaultProps$172 = { variant: "subtle" };
const varsResolver$81 = createVarsResolver((_, { size: size$3, radius, iconSize }) => ({ root: {
	"--cb-size": getSize(size$3, "cb-size"),
	"--cb-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--cb-icon-size": rem(iconSize)
} }));
const CloseButton = polymorphicFactory((_props, ref) => {
	const props = useProps("CloseButton", defaultProps$172, _props);
	const { iconSize, children, vars, radius, className, classNames, style, styles, unstyled, "data-disabled": dataDisabled, disabled, variant, icon, mod, __staticSelector,...others } = props;
	const getStyles$1 = useStyles({
		name: __staticSelector || "CloseButton",
		props,
		className,
		style,
		classes: classes$78,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$81
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		ref,
		...others,
		unstyled,
		variant,
		disabled,
		mod: [{ disabled: disabled || dataDisabled }, mod],
		...getStyles$1("root", {
			variant,
			active: !disabled && !dataDisabled
		}),
		children: [icon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseIcon, {}), children]
	});
});
CloseButton.classes = classes$78;
CloseButton.displayName = "@mantine/core/CloseButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Group/filter-falsy-children/filter-falsy-children.mjs
function filterFalsyChildren(children) {
	return import_react.Children.toArray(children).filter(Boolean);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Group/Group.module.css.mjs
var classes$77 = { "root": "m_4081bf90" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Group/Group.mjs
const defaultProps$171 = {
	preventGrowOverflow: true,
	gap: "md",
	align: "center",
	justify: "flex-start",
	wrap: "wrap"
};
const varsResolver$80 = createVarsResolver((_, { grow, preventGrowOverflow, gap, align, justify, wrap }, { childWidth }) => ({ root: {
	"--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
	"--group-gap": getSpacing(gap),
	"--group-align": align,
	"--group-justify": justify,
	"--group-wrap": wrap
} }));
const Group = factory((_props, ref) => {
	const props = useProps("Group", defaultProps$171, _props);
	const { classNames, className, style, styles, unstyled, children, gap, align, justify, wrap, grow, preventGrowOverflow, vars, variant, __size, mod,...others } = props;
	const filteredChildren = filterFalsyChildren(children);
	const childrenCount = filteredChildren.length;
	const resolvedGap = getSpacing(gap ?? "md");
	const childWidth = `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))`;
	const stylesCtx = { childWidth };
	const getStyles$1 = useStyles({
		name: "Group",
		props,
		stylesCtx,
		className,
		style,
		classes: classes$77,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$80
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		ref,
		variant,
		mod: [{ grow }, mod],
		size: __size,
		...others,
		children: filteredChildren
	});
});
Group.classes = classes$77;
Group.displayName = "@mantine/core/Group";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBase.context.mjs
const [ModalBaseProvider, useModalBaseContext] = createSafeContext("ModalBase component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/use-lock-scroll.mjs
function useLockScroll({ opened, transitionDuration }) {
	const [shouldLockScroll, setShouldLockScroll] = (0, import_react.useState)(opened);
	const timeout = (0, import_react.useRef)(-1);
	const reduceMotion = useReducedMotion();
	const _transitionDuration = reduceMotion ? 0 : transitionDuration;
	(0, import_react.useEffect)(() => {
		if (opened) {
			setShouldLockScroll(true);
			window.clearTimeout(timeout.current);
		} else if (_transitionDuration === 0) setShouldLockScroll(false);
		else timeout.current = window.setTimeout(() => setShouldLockScroll(false), _transitionDuration);
		return () => window.clearTimeout(timeout.current);
	}, [opened, _transitionDuration]);
	return shouldLockScroll;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/use-modal.mjs
function useModal({ id, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape$1, onClose, returnFocus }) {
	const _id = useId(id);
	const [titleMounted, setTitleMounted] = (0, import_react.useState)(false);
	const [bodyMounted, setBodyMounted] = (0, import_react.useState)(false);
	const transitionDuration = typeof transitionProps?.duration === "number" ? transitionProps?.duration : 200;
	const shouldLockScroll = useLockScroll({
		opened,
		transitionDuration
	});
	useWindowEvent("keydown", (event) => {
		if (event.key === "Escape" && closeOnEscape$1 && !event.isComposing && opened) {
			const shouldTrigger = event.target?.getAttribute("data-mantine-stop-propagation") !== "true";
			shouldTrigger && onClose();
		}
	}, { capture: true });
	useFocusReturn({
		opened,
		shouldReturnFocus: trapFocus && returnFocus
	});
	return {
		_id,
		titleMounted,
		bodyMounted,
		shouldLockScroll,
		setTitleMounted,
		setBodyMounted
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBase.mjs
const ModalBase = (0, import_react.forwardRef)(({ keepMounted, opened, onClose, id, transitionProps, onExitTransitionEnd, onEnterTransitionEnd, trapFocus, closeOnEscape: closeOnEscape$1, returnFocus, closeOnClickOutside, withinPortal, portalProps, lockScroll, children, zIndex, shadow, padding, __vars, unstyled, removeScrollProps,...others }, ref) => {
	const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({
		id,
		transitionProps,
		opened,
		trapFocus,
		closeOnEscape: closeOnEscape$1,
		onClose,
		returnFocus
	});
	const { key: removeScrollKey,...otherRemoveScrollProps } = removeScrollProps || {};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...portalProps,
		withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseProvider, {
			value: {
				opened,
				onClose,
				closeOnClickOutside,
				onExitTransitionEnd,
				onEnterTransitionEnd,
				transitionProps: {
					...transitionProps,
					keepMounted
				},
				getTitleId: () => `${_id}-title`,
				getBodyId: () => `${_id}-body`,
				titleMounted,
				bodyMounted,
				setTitleMounted,
				setBodyMounted,
				trapFocus,
				closeOnEscape: closeOnEscape$1,
				zIndex,
				unstyled
			},
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combination_default, {
				enabled: shouldLockScroll && lockScroll,
				...otherRemoveScrollProps,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					ref,
					...others,
					__vars: {
						...__vars,
						"--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
						"--mb-shadow": getShadow(shadow),
						"--mb-padding": getSpacing(padding)
					},
					children
				})
			}, removeScrollKey)
		})
	});
});
ModalBase.displayName = "@mantine/core/ModalBase";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/use-modal-body-id.mjs
function useModalBodyId() {
	const ctx = useModalBaseContext();
	(0, import_react.useEffect)(() => {
		ctx.setBodyMounted(true);
		return () => ctx.setBodyMounted(false);
	}, []);
	return ctx.getBodyId();
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBase.module.css.mjs
var classes$76 = {
	"title": "m_615af6c9",
	"header": "m_b5489c3c",
	"inner": "m_60c222c7",
	"content": "m_fd1ab0aa",
	"close": "m_606cb269",
	"body": "m_5df29311"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseBody.mjs
const ModalBaseBody = (0, import_react.forwardRef)(({ className,...others }, ref) => {
	const bodyId = useModalBodyId();
	const ctx = useModalBaseContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...others,
		id: bodyId,
		className: clsx_default({ [classes$76.body]: !ctx.unstyled }, className)
	});
});
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseCloseButton.mjs
const ModalBaseCloseButton = (0, import_react.forwardRef)(({ className, onClick,...others }, ref) => {
	const ctx = useModalBaseContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
		ref,
		...others,
		onClick: (event) => {
			ctx.onClose();
			onClick?.(event);
		},
		className: clsx_default({ [classes$76.close]: !ctx.unstyled }, className),
		unstyled: ctx.unstyled
	});
});
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseContent.mjs
const ModalBaseContent = (0, import_react.forwardRef)(({ transitionProps, className, innerProps, onKeyDown, style,...others }, ref) => {
	const ctx = useModalBaseContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
		mounted: ctx.opened,
		transition: "pop",
		...ctx.transitionProps,
		onExited: () => {
			ctx.onExitTransitionEnd?.();
			ctx.transitionProps?.onExited?.();
		},
		onEntered: () => {
			ctx.onEnterTransitionEnd?.();
			ctx.transitionProps?.onEntered?.();
		},
		...transitionProps,
		children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...innerProps,
			className: clsx_default({ [classes$76.inner]: !ctx.unstyled }, innerProps.className),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusTrap, {
				active: ctx.opened && ctx.trapFocus,
				innerRef: ref,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Paper, {
					...others,
					component: "section",
					role: "dialog",
					tabIndex: -1,
					"aria-modal": true,
					"aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : void 0,
					"aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : void 0,
					style: [style, transitionStyles],
					className: clsx_default({ [classes$76.content]: !ctx.unstyled }, className),
					unstyled: ctx.unstyled,
					children: others.children
				})
			})
		})
	});
});
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseHeader.mjs
const ModalBaseHeader = (0, import_react.forwardRef)(({ className,...others }, ref) => {
	const ctx = useModalBaseContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "header",
		ref,
		className: clsx_default({ [classes$76.header]: !ctx.unstyled }, className),
		...others
	});
});
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/use-modal-transition.mjs
const DEFAULT_TRANSITION = {
	duration: 200,
	timingFunction: "ease",
	transition: "fade"
};
function useModalTransition(transitionOverride) {
	const ctx = useModalBaseContext();
	return {
		...DEFAULT_TRANSITION,
		...ctx.transitionProps,
		...transitionOverride
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseOverlay.mjs
const ModalBaseOverlay = (0, import_react.forwardRef)(({ onClick, transitionProps, style, visible,...others }, ref) => {
	const ctx = useModalBaseContext();
	const transition = useModalTransition(transitionProps);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
		mounted: visible !== void 0 ? visible : ctx.opened,
		...transition,
		transition: "fade",
		children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
			ref,
			fixed: true,
			style: [style, transitionStyles],
			zIndex: ctx.zIndex,
			unstyled: ctx.unstyled,
			onClick: (event) => {
				onClick?.(event);
				ctx.closeOnClickOutside && ctx.onClose();
			},
			...others
		})
	});
});
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/use-modal-title-id.mjs
function useModalTitle() {
	const ctx = useModalBaseContext();
	(0, import_react.useEffect)(() => {
		ctx.setTitleMounted(true);
		return () => ctx.setTitleMounted(false);
	}, []);
	return ctx.getTitleId();
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/ModalBaseTitle.mjs
const ModalBaseTitle = (0, import_react.forwardRef)(({ className,...others }, ref) => {
	const id = useModalTitle();
	const ctx = useModalBaseContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "h2",
		ref,
		className: clsx_default({ [classes$76.title]: !ctx.unstyled }, className),
		...others,
		id
	});
});
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ModalBase/NativeScrollArea.mjs
function NativeScrollArea({ children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/Input.context.mjs
const [InputContext, useInputContext] = createOptionalContext({ size: "sm" });

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputClearButton/InputClearButton.mjs
const defaultProps$170 = {};
const InputClearButton = factory((_props, ref) => {
	const props = useProps("InputClearButton", defaultProps$170, _props);
	const { size: size$3, variant, vars, classNames, styles,...others } = props;
	const ctx = useInputContext();
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
		variant: variant || "transparent",
		ref,
		size: size$3 || ctx?.size || "sm",
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		__staticSelector: "InputClearButton",
		...others
	});
});
InputClearButton.displayName = "@mantine/core/InputClearButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputWrapper.context.mjs
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
	offsetBottom: false,
	offsetTop: false,
	describedBy: void 0,
	getStyles: null,
	inputId: void 0,
	labelId: void 0
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/Input.module.css.mjs
var classes$75 = {
	"wrapper": "m_6c018570",
	"input": "m_8fb7ebe7",
	"section": "m_82577fc2",
	"placeholder": "m_88bacfd0",
	"root": "m_46b77525",
	"label": "m_8fdc1311",
	"required": "m_78a94662",
	"error": "m_8f816625",
	"description": "m_fe47ce59"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputDescription/InputDescription.mjs
const defaultProps$169 = {};
const varsResolver$79 = createVarsResolver((_, { size: size$3 }) => ({ description: { "--input-description-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` } }));
const InputDescription = factory((_props, ref) => {
	const props = useProps("InputDescription", defaultProps$169, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, __staticSelector, __inheritStyles = true, variant,...others } = useProps("InputDescription", defaultProps$169, props);
	const ctx = useInputWrapperContext();
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "description",
		vars,
		varsResolver: varsResolver$79
	});
	const getStyles$1 = __inheritStyles && ctx?.getStyles || _getStyles;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "p",
		ref,
		variant,
		size: size$3,
		...getStyles$1("description", ctx?.getStyles ? {
			className,
			style
		} : void 0),
		...others
	});
});
InputDescription.classes = classes$75;
InputDescription.displayName = "@mantine/core/InputDescription";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputError/InputError.mjs
const defaultProps$168 = {};
const varsResolver$78 = createVarsResolver((_, { size: size$3 }) => ({ error: { "--input-error-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` } }));
const InputError = factory((_props, ref) => {
	const props = useProps("InputError", defaultProps$168, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, __staticSelector, __inheritStyles = true, variant,...others } = props;
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "error",
		vars,
		varsResolver: varsResolver$78
	});
	const ctx = useInputWrapperContext();
	const getStyles$1 = __inheritStyles && ctx?.getStyles || _getStyles;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "p",
		ref,
		variant,
		size: size$3,
		...getStyles$1("error", ctx?.getStyles ? {
			className,
			style
		} : void 0),
		...others
	});
});
InputError.classes = classes$75;
InputError.displayName = "@mantine/core/InputError";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputLabel/InputLabel.mjs
const defaultProps$167 = { labelElement: "label" };
const varsResolver$77 = createVarsResolver((_, { size: size$3 }) => ({ label: {
	"--input-label-size": getFontSize(size$3),
	"--input-asterisk-color": void 0
} }));
const InputLabel = factory((_props, ref) => {
	const props = useProps("InputLabel", defaultProps$167, _props);
	const { classNames, className, style, styles, unstyled, vars, labelElement, size: size$3, required, htmlFor, onMouseDown, children, __staticSelector, variant, mod,...others } = useProps("InputLabel", defaultProps$167, props);
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "label",
		vars,
		varsResolver: varsResolver$77
	});
	const ctx = useInputWrapperContext();
	const getStyles$1 = ctx?.getStyles || _getStyles;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("label", ctx?.getStyles ? {
			className,
			style
		} : void 0),
		component: labelElement,
		variant,
		size: size$3,
		ref,
		htmlFor: labelElement === "label" ? htmlFor : void 0,
		mod: [{ required }, mod],
		onMouseDown: (event) => {
			onMouseDown?.(event);
			if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
		},
		...others,
		children: [children, required && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			...getStyles$1("required"),
			"aria-hidden": true,
			children: " *"
		})]
	});
});
InputLabel.classes = classes$75;
InputLabel.displayName = "@mantine/core/InputLabel";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputPlaceholder/InputPlaceholder.mjs
const defaultProps$166 = {};
const InputPlaceholder = factory((_props, ref) => {
	const props = useProps("InputPlaceholder", defaultProps$166, _props);
	const { classNames, className, style, styles, unstyled, vars, __staticSelector, variant, error: error$1, mod,...others } = useProps("InputPlaceholder", defaultProps$166, props);
	const getStyles$1 = useStyles({
		name: ["InputPlaceholder", __staticSelector],
		props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "placeholder"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("placeholder"),
		mod: [{ error: !!error$1 }, mod],
		component: "span",
		variant,
		ref,
		...others
	});
});
InputPlaceholder.classes = classes$75;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputWrapper/get-input-offsets/get-input-offsets.mjs
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
	const inputIndex = inputWrapperOrder.findIndex((part) => part === "input");
	const aboveInput = inputWrapperOrder.slice(0, inputIndex);
	const belowInput = inputWrapperOrder.slice(inputIndex + 1);
	const offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
	const offsetBottom = hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error");
	return {
		offsetBottom,
		offsetTop
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/InputWrapper/InputWrapper.mjs
const defaultProps$165 = {
	labelElement: "label",
	inputContainer: (children) => children,
	inputWrapperOrder: [
		"label",
		"description",
		"input",
		"error"
	]
};
const varsResolver$76 = createVarsResolver((_, { size: size$3 }) => ({
	label: {
		"--input-label-size": getFontSize(size$3),
		"--input-asterisk-color": void 0
	},
	error: { "--input-error-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` },
	description: { "--input-description-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` }
}));
const InputWrapper = factory((_props, ref) => {
	const props = useProps("InputWrapper", defaultProps$165, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, variant, __staticSelector, inputContainer, inputWrapperOrder, label, error: error$1, description, labelProps, descriptionProps, errorProps, labelElement, children, withAsterisk, id, required, __stylesApiProps, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: ["InputWrapper", __staticSelector],
		props: __stylesApiProps || props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$76
	});
	const sharedProps = {
		size: size$3,
		variant,
		__staticSelector
	};
	const idBase = useId(id);
	const isRequired = typeof withAsterisk === "boolean" ? withAsterisk : required;
	const errorId = errorProps?.id || `${idBase}-error`;
	const descriptionId = descriptionProps?.id || `${idBase}-description`;
	const inputId = idBase;
	const hasError = !!error$1 && typeof error$1 !== "boolean";
	const hasDescription = !!description;
	const _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`;
	const describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0;
	const labelId = labelProps?.id || `${idBase}-label`;
	const _label = label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputLabel, {
		labelElement,
		id: labelId,
		htmlFor: inputId,
		required: isRequired,
		...sharedProps,
		...labelProps,
		children: label
	}, "label");
	const _description = hasDescription && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputDescription, {
		...descriptionProps,
		...sharedProps,
		size: descriptionProps?.size || sharedProps.size,
		id: descriptionProps?.id || descriptionId,
		children: description
	}, "description");
	const _input = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: inputContainer(children) }, "input");
	const _error = hasError && /* @__PURE__ */ (0, import_react.createElement)(InputError, {
		...errorProps,
		...sharedProps,
		size: errorProps?.size || sharedProps.size,
		key: "error",
		id: errorProps?.id || errorId
	}, error$1);
	const content = inputWrapperOrder.map((part) => {
		switch (part) {
			case "label": return _label;
			case "input": return _input;
			case "description": return _description;
			case "error": return _error;
			default: return null;
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputWrapperProvider, {
		value: {
			getStyles: getStyles$1,
			describedBy,
			inputId,
			labelId,
			...getInputOffsets(inputWrapperOrder, {
				hasDescription,
				hasError
			})
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			variant,
			size: size$3,
			mod: [{ error: !!error$1 }, mod],
			...getStyles$1("root"),
			...others,
			children: content
		})
	});
});
InputWrapper.classes = classes$75;
InputWrapper.displayName = "@mantine/core/InputWrapper";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/Input.mjs
const defaultProps$164 = {
	variant: "default",
	leftSectionPointerEvents: "none",
	rightSectionPointerEvents: "none",
	withAria: true,
	withErrorStyles: true
};
const varsResolver$75 = createVarsResolver((_, props, ctx) => ({ wrapper: {
	"--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
	"--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
	"--input-height": getSize(props.size, "input-height"),
	"--input-fz": getFontSize(props.size),
	"--input-radius": props.radius === void 0 ? void 0 : getRadius(props.radius),
	"--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
	"--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
	"--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
	"--input-left-section-pointer-events": props.leftSectionPointerEvents,
	"--input-right-section-pointer-events": props.rightSectionPointerEvents
} }));
const Input = polymorphicFactory((_props, ref) => {
	const props = useProps("Input", defaultProps$164, _props);
	const { classNames, className, style, styles, unstyled, required, __staticSelector, __stylesApiProps, size: size$3, wrapperProps, error: error$1, disabled, leftSection, leftSectionProps, leftSectionWidth, rightSection, rightSectionProps, rightSectionWidth, rightSectionPointerEvents, leftSectionPointerEvents, variant, vars, pointer, multiline, radius, id, withAria, withErrorStyles, mod, inputSize, __clearSection, __clearable, __defaultRightSection,...others } = props;
	const { styleProps, rest } = extractStyleProps(others);
	const ctx = useInputWrapperContext();
	const stylesCtx = {
		offsetBottom: ctx?.offsetBottom,
		offsetTop: ctx?.offsetTop
	};
	const getStyles$1 = useStyles({
		name: ["Input", __staticSelector],
		props: __stylesApiProps || props,
		classes: classes$75,
		className,
		style,
		classNames,
		styles,
		unstyled,
		stylesCtx,
		rootSelector: "wrapper",
		vars,
		varsResolver: varsResolver$75
	});
	const ariaAttributes = withAria ? {
		required,
		disabled,
		"aria-invalid": !!error$1,
		"aria-describedby": ctx?.describedBy,
		id: ctx?.inputId || id
	} : {};
	const _rightSection = rightSection || __clearable && __clearSection || __defaultRightSection;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputContext, {
		value: { size: size$3 || "sm" },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("wrapper"),
			...styleProps,
			...wrapperProps,
			mod: [{
				error: !!error$1 && withErrorStyles,
				pointer,
				disabled,
				multiline,
				"data-with-right-section": !!_rightSection,
				"data-with-left-section": !!leftSection
			}, mod],
			variant,
			size: size$3,
			children: [
				leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...leftSectionProps,
					"data-position": "left",
					...getStyles$1("section", {
						className: leftSectionProps?.className,
						style: leftSectionProps?.style
					}),
					children: leftSection
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "input",
					...rest,
					...ariaAttributes,
					ref,
					required,
					mod: {
						disabled,
						error: !!error$1 && withErrorStyles
					},
					variant,
					__size: inputSize,
					...getStyles$1("input")
				}),
				_rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...rightSectionProps,
					"data-position": "right",
					...getStyles$1("section", {
						className: rightSectionProps?.className,
						style: rightSectionProps?.style
					}),
					children: _rightSection
				})
			]
		})
	});
});
Input.classes = classes$75;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Input/use-input-props.mjs
function useInputProps(component, defaultProps$188, _props) {
	const props = useProps(component, defaultProps$188, _props);
	const { label, description, error: error$1, required, classNames, styles, className, unstyled, __staticSelector, __stylesApiProps, errorProps, labelProps, descriptionProps, wrapperProps: _wrapperProps, id, size: size$3, style, inputContainer, inputWrapperOrder, withAsterisk, variant, vars, mod,...others } = props;
	const { styleProps, rest } = extractStyleProps(others);
	const wrapperProps = {
		label,
		description,
		error: error$1,
		required,
		classNames,
		className,
		__staticSelector,
		__stylesApiProps: __stylesApiProps || props,
		errorProps,
		labelProps,
		descriptionProps,
		unstyled,
		styles,
		size: size$3,
		style,
		inputContainer,
		inputWrapperOrder,
		withAsterisk,
		variant,
		id,
		mod,
		..._wrapperProps
	};
	return {
		...rest,
		classNames,
		styles,
		unstyled,
		wrapperProps: {
			...wrapperProps,
			...styleProps
		},
		inputProps: {
			required,
			classNames,
			styles,
			unstyled,
			size: size$3,
			__staticSelector,
			__stylesApiProps: __stylesApiProps || props,
			error: error$1,
			variant,
			id
		}
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/InputBase/InputBase.mjs
const defaultProps$163 = {
	__staticSelector: "InputBase",
	withAria: true
};
const InputBase = polymorphicFactory((props, ref) => {
	const { inputProps, wrapperProps,...others } = useInputProps("InputBase", defaultProps$163, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
		...wrapperProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
			...inputProps,
			...others,
			ref
		})
	});
});
InputBase.classes = {
	...Input.classes,
	...Input.Wrapper.classes
};
InputBase.displayName = "@mantine/core/InputBase";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Flex/flex-props.mjs
const FLEX_STYLE_PROPS_DATA = {
	gap: {
		type: "spacing",
		property: "gap"
	},
	rowGap: {
		type: "spacing",
		property: "rowGap"
	},
	columnGap: {
		type: "spacing",
		property: "columnGap"
	},
	align: {
		type: "identity",
		property: "alignItems"
	},
	justify: {
		type: "identity",
		property: "justifyContent"
	},
	wrap: {
		type: "identity",
		property: "flexWrap"
	},
	direction: {
		type: "identity",
		property: "flexDirection"
	}
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Flex/Flex.module.css.mjs
var classes$74 = { "root": "m_8bffd616" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Flex/Flex.mjs
const defaultProps$162 = {};
const Flex = polymorphicFactory((_props, ref) => {
	const props = useProps("Flex", defaultProps$162, _props);
	const { classNames, className, style, styles, unstyled, vars, gap, rowGap, columnGap, align, justify, wrap, direction,...others } = props;
	const getStyles$1 = useStyles({
		name: "Flex",
		classes: classes$74,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars
	});
	const theme = useMantineTheme();
	const responsiveClassName = useRandomClassName();
	const parsedStyleProps = parseStyleProps({
		styleProps: {
			gap,
			rowGap,
			columnGap,
			align,
			justify,
			wrap,
			direction
		},
		theme,
		data: FLEX_STYLE_PROPS_DATA
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		selector: `.${responsiveClassName}`,
		styles: parsedStyleProps.styles,
		media: parsedStyleProps.media
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root", {
			className: responsiveClassName,
			style: filterProps(parsedStyleProps.inlineStyles)
		}),
		...others
	})] });
});
Flex.classes = classes$74;
Flex.displayName = "@mantine/core/Flex";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FloatingIndicator/use-floating-indicator.mjs
function isParent(parentElement, childElement) {
	if (!childElement || !parentElement) return false;
	let parent = childElement.parentNode;
	while (parent != null) {
		if (parent === parentElement) return true;
		parent = parent.parentNode;
	}
	return false;
}
function useFloatingIndicator({ target, parent, ref, displayAfterTransitionEnd }) {
	const transitionTimeout = (0, import_react.useRef)(-1);
	const [initialized, setInitialized] = (0, import_react.useState)(false);
	const [hidden, setHidden] = (0, import_react.useState)(typeof displayAfterTransitionEnd === "boolean" ? displayAfterTransitionEnd : false);
	const updatePosition = () => {
		if (!target || !parent || !ref.current) return;
		const targetRect = target.getBoundingClientRect();
		const parentRect = parent.getBoundingClientRect();
		const targetComputedStyle = window.getComputedStyle(target);
		const parentComputedStyle = window.getComputedStyle(parent);
		const borderTopWidth = toInt(targetComputedStyle.borderTopWidth) + toInt(parentComputedStyle.borderTopWidth);
		const borderLeftWidth = toInt(targetComputedStyle.borderLeftWidth) + toInt(parentComputedStyle.borderLeftWidth);
		const position = {
			top: targetRect.top - parentRect.top - borderTopWidth,
			left: targetRect.left - parentRect.left - borderLeftWidth,
			width: targetRect.width,
			height: targetRect.height
		};
		ref.current.style.transform = `translateY(${position.top}px) translateX(${position.left}px)`;
		ref.current.style.width = `${position.width}px`;
		ref.current.style.height = `${position.height}px`;
	};
	const updatePositionWithoutAnimation = () => {
		window.clearTimeout(transitionTimeout.current);
		if (ref.current) ref.current.style.transitionDuration = "0ms";
		updatePosition();
		transitionTimeout.current = window.setTimeout(() => {
			if (ref.current) ref.current.style.transitionDuration = "";
		}, 30);
	};
	const targetResizeObserver = (0, import_react.useRef)(null);
	const parentResizeObserver = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		updatePosition();
		if (target) {
			targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation);
			targetResizeObserver.current.observe(target);
			if (parent) {
				parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation);
				parentResizeObserver.current.observe(parent);
			}
			return () => {
				targetResizeObserver.current?.disconnect();
				parentResizeObserver.current?.disconnect();
			};
		}
		return void 0;
	}, [parent, target]);
	(0, import_react.useEffect)(() => {
		if (parent) {
			const handleTransitionEnd = (event) => {
				if (isParent(event.target, parent)) {
					updatePositionWithoutAnimation();
					setHidden(false);
				}
			};
			parent.addEventListener("transitionend", handleTransitionEnd);
			return () => {
				parent.removeEventListener("transitionend", handleTransitionEnd);
			};
		}
		return void 0;
	}, [parent]);
	useTimeout(() => {
		if (getEnv() !== "test") setInitialized(true);
	}, 20, { autoInvoke: true });
	useMutationObserver((mutations) => {
		mutations.forEach((mutation) => {
			if (mutation.type === "attributes" && mutation.attributeName === "dir") updatePositionWithoutAnimation();
		});
	}, {
		attributes: true,
		attributeFilter: ["dir"]
	}, () => document.documentElement);
	return {
		initialized,
		hidden
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FloatingIndicator/FloatingIndicator.module.css.mjs
var classes$73 = { "root": "m_96b553a6" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FloatingIndicator/FloatingIndicator.mjs
const defaultProps$161 = {};
const varsResolver$74 = createVarsResolver((_theme, { transitionDuration }) => ({ root: { "--transition-duration": typeof transitionDuration === "number" ? `${transitionDuration}ms` : transitionDuration } }));
const FloatingIndicator = factory((_props, ref) => {
	const props = useProps("FloatingIndicator", defaultProps$161, _props);
	const { classNames, className, style, styles, unstyled, vars, target, parent, transitionDuration, mod, displayAfterTransitionEnd,...others } = props;
	const getStyles$1 = useStyles({
		name: "FloatingIndicator",
		classes: classes$73,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$74
	});
	const innerRef = (0, import_react.useRef)(null);
	const { initialized, hidden } = useFloatingIndicator({
		target,
		parent,
		ref: innerRef,
		displayAfterTransitionEnd
	});
	const mergedRef = useMergedRef(ref, innerRef);
	if (!target || !parent) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref: mergedRef,
		mod: [{
			initialized,
			hidden
		}, mod],
		...getStyles$1("root"),
		...others
	});
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$73;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/Accordion.context.mjs
const [AccordionProvider, useAccordionContext] = createSafeContext("Accordion component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/AccordionChevron.mjs
function AccordionChevron({ style, size: size$3 = 16,...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		style: {
			...style,
			width: rem(size$3),
			height: rem(size$3),
			display: "block"
		},
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}
AccordionChevron.displayName = "@mantine/core/AccordionChevron";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/AccordionItem.context.mjs
const [AccordionItemProvider, useAccordionItemContext] = createSafeContext("Accordion.Item component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/Accordion.module.css.mjs
var classes$72 = {
	"root": "m_9bdbb667",
	"panel": "m_df78851f",
	"content": "m_4ba554d4",
	"itemTitle": "m_8fa820a0",
	"control": "m_4ba585b8",
	"control--default": "m_6939a5e9",
	"control--contained": "m_4271d21b",
	"label": "m_df3ffa0f",
	"chevron": "m_3f35ae96",
	"icon": "m_9bd771fe",
	"item": "m_9bd7b098",
	"item--default": "m_fe19b709",
	"item--contained": "m_1f921b3b",
	"item--filled": "m_2cdf939a",
	"item--separated": "m_9f59b069"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/AccordionControl/AccordionControl.mjs
const defaultProps$160 = {};
const AccordionControl = factory((props, ref) => {
	const { classNames, className, style, styles, vars, chevron, icon, onClick, onKeyDown, children, disabled, mod,...others } = useProps("AccordionControl", defaultProps$160, props);
	const { value } = useAccordionItemContext();
	const ctx = useAccordionContext();
	const isActive = ctx.isItemActive(value);
	const shouldWrapWithHeading = typeof ctx.order === "number";
	const Heading = `h${ctx.order}`;
	const content = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...others,
		...ctx.getStyles("control", {
			className,
			classNames,
			style,
			styles,
			variant: ctx.variant
		}),
		unstyled: ctx.unstyled,
		mod: [
			"accordion-control",
			{
				active: isActive,
				"chevron-position": ctx.chevronPosition,
				disabled
			},
			mod
		],
		ref,
		onClick: (event) => {
			onClick?.(event);
			ctx.onChange(value);
		},
		type: "button",
		disabled,
		"aria-expanded": isActive,
		"aria-controls": ctx.getRegionId(value),
		id: ctx.getControlId(value),
		onKeyDown: createScopedKeydownHandler({
			siblingSelector: "[data-accordion-control]",
			parentSelector: "[data-accordion]",
			activateOnFocus: false,
			loop: ctx.loop,
			orientation: "vertical",
			onKeyDown
		}),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				mod: {
					rotate: !ctx.disableChevronRotation && isActive,
					position: ctx.chevronPosition
				},
				...ctx.getStyles("chevron", {
					classNames,
					styles
				}),
				children: chevron || ctx.chevron
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("label", {
					classNames,
					styles
				}),
				children
			}),
			icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				mod: { "chevron-position": ctx.chevronPosition },
				...ctx.getStyles("icon", {
					classNames,
					styles
				}),
				children: icon
			})
		]
	});
	return shouldWrapWithHeading ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Heading, {
		...ctx.getStyles("itemTitle", {
			classNames,
			styles
		}),
		children: content
	}) : content;
});
AccordionControl.displayName = "@mantine/core/AccordionControl";
AccordionControl.classes = classes$72;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/AccordionItem/AccordionItem.mjs
const defaultProps$159 = {};
const AccordionItem = factory((props, ref) => {
	const { classNames, className, style, styles, vars, value, mod,...others } = useProps("AccordionItem", defaultProps$159, props);
	const ctx = useAccordionContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionItemProvider, {
		value: { value },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			mod: [{ active: ctx.isItemActive(value) }, mod],
			...ctx.getStyles("item", {
				className,
				classNames,
				styles,
				style,
				variant: ctx.variant
			}),
			...others
		})
	});
});
AccordionItem.displayName = "@mantine/core/AccordionItem";
AccordionItem.classes = classes$72;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/AccordionPanel/AccordionPanel.mjs
const defaultProps$158 = {};
const AccordionPanel = factory((props, ref) => {
	const { classNames, className, style, styles, vars, children,...others } = useProps("AccordionPanel", defaultProps$158, props);
	const { value } = useAccordionItemContext();
	const ctx = useAccordionContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collapse, {
		ref,
		...ctx.getStyles("panel", {
			className,
			classNames,
			style,
			styles
		}),
		...others,
		in: ctx.isItemActive(value),
		transitionDuration: ctx.transitionDuration ?? 200,
		role: "region",
		id: ctx.getRegionId(value),
		"aria-labelledby": ctx.getControlId(value),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...ctx.getStyles("content", {
				classNames,
				styles
			}),
			children
		})
	});
});
AccordionPanel.displayName = "@mantine/core/AccordionPanel";
AccordionPanel.classes = classes$72;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Accordion/Accordion.mjs
const defaultProps$157 = {
	multiple: false,
	disableChevronRotation: false,
	chevronPosition: "right",
	variant: "default",
	chevron: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionChevron, {})
};
const varsResolver$73 = createVarsResolver((_, { transitionDuration, chevronSize, radius }) => ({ root: {
	"--accordion-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
	"--accordion-chevron-size": chevronSize === void 0 ? void 0 : rem(chevronSize),
	"--accordion-radius": radius === void 0 ? void 0 : getRadius(radius)
} }));
function Accordion(_props) {
	const props = useProps("Accordion", defaultProps$157, _props);
	const { classNames, className, style, styles, unstyled, vars, children, multiple, value, defaultValue, onChange, id, loop, transitionDuration, disableChevronRotation, chevronPosition, chevronSize, order, chevron, variant, radius,...others } = props;
	const uid = useId(id);
	const [_value, handleChange] = useUncontrolled({
		value,
		defaultValue,
		finalValue: multiple ? [] : null,
		onChange
	});
	const isItemActive = (itemValue) => Array.isArray(_value) ? _value.includes(itemValue) : itemValue === _value;
	const handleItemChange = (itemValue) => {
		const nextValue = Array.isArray(_value) ? _value.includes(itemValue) ? _value.filter((selectedValue) => selectedValue !== itemValue) : [..._value, itemValue] : itemValue === _value ? null : itemValue;
		handleChange(nextValue);
	};
	const getStyles$1 = useStyles({
		name: "Accordion",
		classes: classes$72,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$73
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionProvider, {
		value: {
			isItemActive,
			onChange: handleItemChange,
			getControlId: getSafeId(`${uid}-control`, "Accordion.Item component was rendered with invalid value or without value"),
			getRegionId: getSafeId(`${uid}-panel`, "Accordion.Item component was rendered with invalid value or without value"),
			transitionDuration,
			disableChevronRotation,
			chevronPosition,
			order,
			chevron,
			loop,
			getStyles: getStyles$1,
			variant,
			unstyled
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...getStyles$1("root"),
			id: uid,
			...others,
			variant,
			"data-accordion": true,
			children
		})
	});
}
const extendAccordion = (c) => c;
Accordion.extend = extendAccordion;
Accordion.withProps = getWithProps(Accordion);
Accordion.classes = classes$72;
Accordion.displayName = "@mantine/core/Accordion";
Accordion.Item = AccordionItem;
Accordion.Panel = AccordionPanel;
Accordion.Control = AccordionControl;
Accordion.Chevron = AccordionChevron;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Affix/Affix.module.css.mjs
var classes$71 = { "root": "m_7f854edf" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Affix/Affix.mjs
const defaultProps$156 = {
	position: {
		bottom: 0,
		right: 0
	},
	zIndex: getDefaultZIndex("modal"),
	withinPortal: true
};
const varsResolver$72 = createVarsResolver((_, { zIndex, position }) => ({ root: {
	"--affix-z-index": zIndex?.toString(),
	"--affix-top": getSpacing(position?.top),
	"--affix-left": getSpacing(position?.left),
	"--affix-bottom": getSpacing(position?.bottom),
	"--affix-right": getSpacing(position?.right)
} }));
const Affix = factory((_props, ref) => {
	const props = useProps("Affix", defaultProps$156, _props);
	const { classNames, className, style, styles, unstyled, vars, portalProps, zIndex, withinPortal, position,...others } = props;
	const getStyles$1 = useStyles({
		name: "Affix",
		classes: classes$71,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$72
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...portalProps,
		withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root"),
			...others
		})
	});
});
Affix.classes = classes$71;
Affix.displayName = "@mantine/core/Affix";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Alert/Alert.module.css.mjs
var classes$70 = {
	"root": "m_66836ed3",
	"wrapper": "m_a5d60502",
	"body": "m_667c2793",
	"title": "m_6a03f287",
	"label": "m_698f4f23",
	"icon": "m_667f2a6a",
	"message": "m_7fa78076",
	"closeButton": "m_87f54839"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Alert/Alert.mjs
const defaultProps$155 = {};
const varsResolver$71 = createVarsResolver((theme, { radius, color, variant, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		variant: variant || "light",
		autoContrast
	});
	return { root: {
		"--alert-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--alert-bg": color || variant ? colors.background : void 0,
		"--alert-color": colors.color,
		"--alert-bd": color || variant ? colors.border : void 0
	} };
});
const Alert = factory((_props, ref) => {
	const props = useProps("Alert", defaultProps$155, _props);
	const { classNames, className, style, styles, unstyled, vars, radius, color, title, children, id, icon, withCloseButton, onClose, closeButtonLabel, variant, autoContrast,...others } = props;
	const getStyles$1 = useStyles({
		name: "Alert",
		classes: classes$70,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$71
	});
	const rootId = useId(id);
	const titleId = title && `${rootId}-title` || void 0;
	const bodyId = `${rootId}-body`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		id: rootId,
		...getStyles$1("root", { variant }),
		variant,
		ref,
		...others,
		role: "alert",
		"aria-describedby": bodyId,
		"aria-labelledby": titleId,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			...getStyles$1("wrapper"),
			children: [
				icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...getStyles$1("icon"),
					children: icon
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					...getStyles$1("body"),
					children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						...getStyles$1("title"),
						"data-with-close-button": withCloseButton || void 0,
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							id: titleId,
							...getStyles$1("label"),
							children: title
						})
					}), children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						id: bodyId,
						...getStyles$1("message"),
						"data-variant": variant,
						children
					})]
				}),
				withCloseButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
					...getStyles$1("closeButton"),
					onClick: onClose,
					variant: "transparent",
					size: 16,
					iconSize: 16,
					"aria-label": closeButtonLabel,
					unstyled
				})
			]
		})
	});
});
Alert.classes = classes$70;
Alert.displayName = "@mantine/core/Alert";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Text/Text.module.css.mjs
var classes$69 = { "root": "m_b6d8b162" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Text/Text.mjs
function getTextTruncate(truncate) {
	if (truncate === "start") return "start";
	if (truncate === "end" || truncate) return "end";
	return void 0;
}
const defaultProps$154 = { inherit: false };
const varsResolver$70 = createVarsResolver((theme, { variant, lineClamp, gradient, size: size$3, color }) => ({ root: {
	"--text-fz": getFontSize(size$3),
	"--text-lh": getLineHeight(size$3),
	"--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : void 0,
	"--text-line-clamp": typeof lineClamp === "number" ? lineClamp.toString() : void 0,
	"--text-color": color ? getThemeColor(color, theme) : void 0
} }));
const Text = polymorphicFactory((_props, ref) => {
	const props = useProps("Text", defaultProps$154, _props);
	const { lineClamp, truncate, inline: inline$3, inherit, gradient, span, __staticSelector, vars, className, style, classNames, styles, unstyled, variant, mod, size: size$3,...others } = props;
	const getStyles$1 = useStyles({
		name: ["Text", __staticSelector],
		props,
		classes: classes$69,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$70
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root", { focusable: true }),
		ref,
		component: span ? "span" : "p",
		variant,
		mod: [{
			"data-truncate": getTextTruncate(truncate),
			"data-line-clamp": typeof lineClamp === "number",
			"data-inline": inline$3,
			"data-inherit": inherit
		}, mod],
		size: size$3,
		...others
	});
});
Text.classes = classes$69;
Text.displayName = "@mantine/core/Text";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Anchor/Anchor.module.css.mjs
var classes$68 = { "root": "m_849cf0da" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Anchor/Anchor.mjs
const defaultProps$153 = { underline: "hover" };
const Anchor = polymorphicFactory((props, ref) => {
	const { underline, className, unstyled, mod,...others } = useProps("Anchor", defaultProps$153, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
		component: "a",
		ref,
		className: clsx_default({ [classes$68.root]: !unstyled }, className),
		...others,
		mod: [{ underline }, mod],
		__staticSelector: "Anchor",
		unstyled
	});
});
Anchor.classes = classes$68;
Anchor.displayName = "@mantine/core/Anchor";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AngleSlider/AngleSlider.module.css.mjs
var classes$67 = {
	"root": "m_48204f9b",
	"marks": "m_bb9cdbad",
	"mark": "m_481dd586",
	"thumb": "m_bc02ba3d",
	"label": "m_bb8e875b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AngleSlider/AngleSlider.mjs
const defaultProps$152 = {
	step: 1,
	withLabel: true
};
const varsResolver$69 = createVarsResolver((_, { size: size$3, thumbSize }) => ({ root: {
	"--slider-size": rem(size$3),
	"--thumb-size": rem(thumbSize)
} }));
const AngleSlider = factory((_props, ref) => {
	const props = useProps("AngleSlider", defaultProps$152, _props);
	const { classNames, className, style, styles, unstyled, vars, step, value, defaultValue, onChange, onMouseDown, withLabel, marks, thumbSize, restrictToMarks, formatLabel, onChangeEnd, disabled, onTouchStart, name, hiddenInputProps, "aria-label": ariaLabel, tabIndex, onScrubStart, onScrubEnd,...others } = props;
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: 0,
		onChange
	});
	const update = (val) => {
		if (rootRef.current) {
			const newValue = restrictToMarks && Array.isArray(marks) ? findClosestNumber(val, marks.map((mark) => mark.value)) : val;
			setValue(newValue);
		}
	};
	const { ref: rootRef } = useRadialMove(update, {
		step,
		onChangeEnd,
		onScrubStart,
		onScrubEnd
	});
	const getStyles$1 = useStyles({
		name: "AngleSlider",
		classes: classes$67,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$69
	});
	const handleKeyDown = (event) => {
		if (disabled) return;
		let newValue = _value;
		if (event.key === "ArrowLeft" || event.key === "ArrowDown") newValue = normalizeRadialValue(_value - step, step);
		if (event.key === "ArrowRight" || event.key === "ArrowUp") newValue = normalizeRadialValue(_value + step, step);
		if (event.key === "Home") newValue = 0;
		if (event.key === "End") newValue = 359;
		if (restrictToMarks && Array.isArray(marks)) {
			const markValues = marks.map((mark) => mark.value);
			const currentIndex = markValues.indexOf(_value);
			if (currentIndex !== -1) if (event.key === "ArrowLeft" || event.key === "ArrowDown") newValue = markValues[Math.max(0, currentIndex - 1)];
			else if (event.key === "ArrowRight" || event.key === "ArrowUp") newValue = markValues[Math.min(markValues.length - 1, currentIndex + 1)];
			else newValue = findClosestNumber(newValue, markValues);
			else newValue = findClosestNumber(newValue, markValues);
		}
		setValue(newValue);
		onChangeEnd?.(newValue);
	};
	const marksItems = marks?.map((mark, index$4) => /* @__PURE__ */ (0, import_react.createElement)("div", {
		...getStyles$1("mark", { style: { "--angle": `${mark.value}deg` } }),
		"data-label": mark.label || void 0,
		key: index$4
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref: useMergedRef(ref, rootRef),
		...getStyles$1("root", { focusable: true }),
		...others,
		children: [
			marksItems && marksItems.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("marks"),
				children: marksItems
			}),
			withLabel && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("label"),
				children: typeof formatLabel === "function" ? formatLabel(_value) : _value
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				tabIndex: tabIndex ?? (disabled ? -1 : 0),
				role: "slider",
				"aria-valuemax": 360,
				"aria-valuemin": 0,
				"aria-valuenow": _value,
				onKeyDown: handleKeyDown,
				"aria-label": ariaLabel,
				...getStyles$1("thumb", { style: { transform: `rotate(${_value}deg)` } })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
				type: "hidden",
				name,
				value: _value,
				...hiddenInputProps
			})
		]
	});
});
AngleSlider.displayName = "@mantine/core/AngleSlider";
AngleSlider.classes = classes$67;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShell.context.mjs
const [AppShellProvider, useAppShellContext] = createSafeContext("AppShell was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShell.module.css.mjs
var classes$66 = {
	"root": "m_89ab340",
	"navbar": "m_45252eee",
	"aside": "m_9cdde9a",
	"header": "m_3b16f56b",
	"main": "m_8983817",
	"footer": "m_3840c879",
	"section": "m_6dcfc7c7"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellAside/AppShellAside.mjs
const defaultProps$151 = {};
const AppShellAside = factory((_props, ref) => {
	const props = useProps("AppShellAside", defaultProps$151, _props);
	const { classNames, className, style, styles, unstyled, vars, withBorder, zIndex, mod,...others } = props;
	const ctx = useAppShellContext();
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "aside",
		ref,
		mod: [{ "with-border": withBorder ?? ctx.withBorder }, mod],
		...ctx.getStyles("aside", {
			className,
			classNames,
			styles,
			style
		}),
		...others,
		__vars: { "--app-shell-aside-z-index": `calc(${zIndex ?? ctx.zIndex} + 1)` }
	});
});
AppShellAside.classes = classes$66;
AppShellAside.displayName = "@mantine/core/AppShellAside";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellFooter/AppShellFooter.mjs
const defaultProps$150 = {};
const AppShellFooter = factory((_props, ref) => {
	const props = useProps("AppShellFooter", defaultProps$150, _props);
	const { classNames, className, style, styles, unstyled, vars, withBorder, zIndex, mod,...others } = props;
	const ctx = useAppShellContext();
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "footer",
		ref,
		mod: [{ "with-border": withBorder ?? ctx.withBorder }, mod],
		...ctx.getStyles("footer", {
			className: clsx_default({ [Combination_default.classNames.zeroRight]: ctx.offsetScrollbars }, className),
			classNames,
			styles,
			style
		}),
		...others,
		__vars: { "--app-shell-footer-z-index": (zIndex ?? ctx.zIndex)?.toString() }
	});
});
AppShellFooter.classes = classes$66;
AppShellFooter.displayName = "@mantine/core/AppShellFooter";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellHeader/AppShellHeader.mjs
const defaultProps$149 = {};
const AppShellHeader = factory((_props, ref) => {
	const props = useProps("AppShellHeader", defaultProps$149, _props);
	const { classNames, className, style, styles, unstyled, vars, withBorder, zIndex, mod,...others } = props;
	const ctx = useAppShellContext();
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "header",
		ref,
		mod: [{ "with-border": withBorder ?? ctx.withBorder }, mod],
		...ctx.getStyles("header", {
			className: clsx_default({ [Combination_default.classNames.zeroRight]: ctx.offsetScrollbars }, className),
			classNames,
			styles,
			style
		}),
		...others,
		__vars: { "--app-shell-header-z-index": (zIndex ?? ctx.zIndex)?.toString() }
	});
});
AppShellHeader.classes = classes$66;
AppShellHeader.displayName = "@mantine/core/AppShellHeader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMain/AppShellMain.mjs
const defaultProps$148 = {};
const AppShellMain = factory((_props, ref) => {
	const props = useProps("AppShellMain", defaultProps$148, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useAppShellContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "main",
		ref,
		...ctx.getStyles("main", {
			className,
			style,
			classNames,
			styles
		}),
		...others
	});
});
AppShellMain.classes = classes$66;
AppShellMain.displayName = "@mantine/core/AppShellMain";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/get-base-size/get-base-size.mjs
function getBaseSize(size$3) {
	if (typeof size$3 === "object") return size$3.base;
	return size$3;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/is-primitive-size/is-primitive-size.mjs
function isPrimitiveSize(size$3) {
	const isBaseSize = typeof size$3 === "object" && size$3 !== null && typeof size$3.base !== "undefined" && Object.keys(size$3).length === 1;
	return typeof size$3 === "number" || typeof size$3 === "string" || isBaseSize;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/is-responsive-size/is-responsive-size.mjs
function isResponsiveSize(size$3) {
	if (typeof size$3 !== "object" || size$3 === null) return false;
	if (Object.keys(size$3).length === 1 && "base" in size$3) return false;
	return true;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/assign-aside-variables/assign-aside-variables.mjs
function assignAsideVariables({ baseStyles, minMediaStyles, maxMediaStyles, aside, theme }) {
	const asideWidth = aside?.width;
	const collapsedAsideTransform = "translateX(var(--app-shell-aside-width))";
	const collapsedAsideTransformRtl = "translateX(calc(var(--app-shell-aside-width) * -1))";
	if (aside?.breakpoint && !aside?.collapsed?.mobile) {
		maxMediaStyles[aside?.breakpoint] = maxMediaStyles[aside?.breakpoint] || {};
		maxMediaStyles[aside?.breakpoint]["--app-shell-aside-width"] = "100%";
		maxMediaStyles[aside?.breakpoint]["--app-shell-aside-offset"] = "0px";
	}
	if (isPrimitiveSize(asideWidth)) {
		const baseSize = rem(getBaseSize(asideWidth));
		baseStyles["--app-shell-aside-width"] = baseSize;
		baseStyles["--app-shell-aside-offset"] = baseSize;
	}
	if (isResponsiveSize(asideWidth)) {
		if (typeof asideWidth.base !== "undefined") {
			baseStyles["--app-shell-aside-width"] = rem(asideWidth.base);
			baseStyles["--app-shell-aside-offset"] = rem(asideWidth.base);
		}
		keys(asideWidth).forEach((key) => {
			if (key !== "base") {
				minMediaStyles[key] = minMediaStyles[key] || {};
				minMediaStyles[key]["--app-shell-aside-width"] = rem(asideWidth[key]);
				minMediaStyles[key]["--app-shell-aside-offset"] = rem(asideWidth[key]);
			}
		});
	}
	if (aside?.collapsed?.desktop) {
		const breakpointValue = aside.breakpoint;
		minMediaStyles[breakpointValue] = minMediaStyles[breakpointValue] || {};
		minMediaStyles[breakpointValue]["--app-shell-aside-transform"] = collapsedAsideTransform;
		minMediaStyles[breakpointValue]["--app-shell-aside-transform-rtl"] = collapsedAsideTransformRtl;
		minMediaStyles[breakpointValue]["--app-shell-aside-offset"] = "0px !important";
	}
	if (aside?.collapsed?.mobile) {
		const breakpointValue = getBreakpointValue(aside.breakpoint, theme.breakpoints) - .1;
		maxMediaStyles[breakpointValue] = maxMediaStyles[breakpointValue] || {};
		maxMediaStyles[breakpointValue]["--app-shell-aside-width"] = "100%";
		maxMediaStyles[breakpointValue]["--app-shell-aside-offset"] = "0px";
		maxMediaStyles[breakpointValue]["--app-shell-aside-transform"] = collapsedAsideTransform;
		maxMediaStyles[breakpointValue]["--app-shell-aside-transform-rtl"] = collapsedAsideTransformRtl;
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/assign-footer-variables/assign-footer-variables.mjs
function assignFooterVariables({ baseStyles, minMediaStyles, footer }) {
	const footerHeight = footer?.height;
	const collapsedFooterTransform = "translateY(var(--app-shell-footer-height))";
	const shouldOffset = footer?.offset ?? true;
	if (isPrimitiveSize(footerHeight)) {
		const baseSize = rem(getBaseSize(footerHeight));
		baseStyles["--app-shell-footer-height"] = baseSize;
		if (shouldOffset) baseStyles["--app-shell-footer-offset"] = baseSize;
	}
	if (isResponsiveSize(footerHeight)) {
		if (typeof footerHeight.base !== "undefined") {
			baseStyles["--app-shell-footer-height"] = rem(footerHeight.base);
			if (shouldOffset) baseStyles["--app-shell-footer-offset"] = rem(footerHeight.base);
		}
		keys(footerHeight).forEach((key) => {
			if (key !== "base") {
				minMediaStyles[key] = minMediaStyles[key] || {};
				minMediaStyles[key]["--app-shell-footer-height"] = rem(footerHeight[key]);
				if (shouldOffset) minMediaStyles[key]["--app-shell-footer-offset"] = rem(footerHeight[key]);
			}
		});
	}
	if (footer?.collapsed) {
		baseStyles["--app-shell-footer-transform"] = collapsedFooterTransform;
		baseStyles["--app-shell-footer-offset"] = "0px !important";
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/assign-header-variables/assign-header-variables.mjs
function assignHeaderVariables({ baseStyles, minMediaStyles, header }) {
	const headerHeight = header?.height;
	const collapsedHeaderTransform = "translateY(calc(var(--app-shell-header-height) * -1))";
	const shouldOffset = header?.offset ?? true;
	if (isPrimitiveSize(headerHeight)) {
		const baseSize = rem(getBaseSize(headerHeight));
		baseStyles["--app-shell-header-height"] = baseSize;
		if (shouldOffset) baseStyles["--app-shell-header-offset"] = baseSize;
	}
	if (isResponsiveSize(headerHeight)) {
		if (typeof headerHeight.base !== "undefined") {
			baseStyles["--app-shell-header-height"] = rem(headerHeight.base);
			if (shouldOffset) baseStyles["--app-shell-header-offset"] = rem(headerHeight.base);
		}
		keys(headerHeight).forEach((key) => {
			if (key !== "base") {
				minMediaStyles[key] = minMediaStyles[key] || {};
				minMediaStyles[key]["--app-shell-header-height"] = rem(headerHeight[key]);
				if (shouldOffset) minMediaStyles[key]["--app-shell-header-offset"] = rem(headerHeight[key]);
			}
		});
	}
	if (header?.collapsed) {
		baseStyles["--app-shell-header-transform"] = collapsedHeaderTransform;
		baseStyles["--app-shell-header-offset"] = "0px !important";
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/assign-navbar-variables/assign-navbar-variables.mjs
function assignNavbarVariables({ baseStyles, minMediaStyles, maxMediaStyles, navbar, theme }) {
	const navbarWidth = navbar?.width;
	const collapsedNavbarTransform = "translateX(calc(var(--app-shell-navbar-width) * -1))";
	const collapsedNavbarTransformRtl = "translateX(var(--app-shell-navbar-width))";
	if (navbar?.breakpoint && !navbar?.collapsed?.mobile) {
		maxMediaStyles[navbar?.breakpoint] = maxMediaStyles[navbar?.breakpoint] || {};
		maxMediaStyles[navbar?.breakpoint]["--app-shell-navbar-width"] = "100%";
		maxMediaStyles[navbar?.breakpoint]["--app-shell-navbar-offset"] = "0px";
	}
	if (isPrimitiveSize(navbarWidth)) {
		const baseSize = rem(getBaseSize(navbarWidth));
		baseStyles["--app-shell-navbar-width"] = baseSize;
		baseStyles["--app-shell-navbar-offset"] = baseSize;
	}
	if (isResponsiveSize(navbarWidth)) {
		if (typeof navbarWidth.base !== "undefined") {
			baseStyles["--app-shell-navbar-width"] = rem(navbarWidth.base);
			baseStyles["--app-shell-navbar-offset"] = rem(navbarWidth.base);
		}
		keys(navbarWidth).forEach((key) => {
			if (key !== "base") {
				minMediaStyles[key] = minMediaStyles[key] || {};
				minMediaStyles[key]["--app-shell-navbar-width"] = rem(navbarWidth[key]);
				minMediaStyles[key]["--app-shell-navbar-offset"] = rem(navbarWidth[key]);
			}
		});
	}
	if (navbar?.collapsed?.desktop) {
		const breakpointValue = navbar.breakpoint;
		minMediaStyles[breakpointValue] = minMediaStyles[breakpointValue] || {};
		minMediaStyles[breakpointValue]["--app-shell-navbar-transform"] = collapsedNavbarTransform;
		minMediaStyles[breakpointValue]["--app-shell-navbar-transform-rtl"] = collapsedNavbarTransformRtl;
		minMediaStyles[breakpointValue]["--app-shell-navbar-offset"] = "0px !important";
	}
	if (navbar?.collapsed?.mobile) {
		const breakpointValue = getBreakpointValue(navbar.breakpoint, theme.breakpoints) - .1;
		maxMediaStyles[breakpointValue] = maxMediaStyles[breakpointValue] || {};
		maxMediaStyles[breakpointValue]["--app-shell-navbar-width"] = "100%";
		maxMediaStyles[breakpointValue]["--app-shell-navbar-offset"] = "0px";
		maxMediaStyles[breakpointValue]["--app-shell-navbar-transform"] = collapsedNavbarTransform;
		maxMediaStyles[breakpointValue]["--app-shell-navbar-transform-rtl"] = collapsedNavbarTransformRtl;
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/get-padding-value/get-padding-value.mjs
function getPaddingValue(padding) {
	return Number(padding) === 0 ? "0px" : getSpacing(padding);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/assign-padding-variables/assign-padding-variables.mjs
function assignPaddingVariables({ padding, baseStyles, minMediaStyles }) {
	if (isPrimitiveSize(padding)) baseStyles["--app-shell-padding"] = getPaddingValue(getBaseSize(padding));
	if (isResponsiveSize(padding)) {
		if (padding.base) baseStyles["--app-shell-padding"] = getPaddingValue(padding.base);
		keys(padding).forEach((key) => {
			if (key !== "base") {
				minMediaStyles[key] = minMediaStyles[key] || {};
				minMediaStyles[key]["--app-shell-padding"] = getPaddingValue(padding[key]);
			}
		});
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/get-variables/get-variables.mjs
function getVariables({ navbar, header, footer, aside, padding, theme }) {
	const minMediaStyles = {};
	const maxMediaStyles = {};
	const baseStyles = {};
	assignNavbarVariables({
		baseStyles,
		minMediaStyles,
		maxMediaStyles,
		navbar,
		theme
	});
	assignAsideVariables({
		baseStyles,
		minMediaStyles,
		maxMediaStyles,
		aside,
		theme
	});
	assignHeaderVariables({
		baseStyles,
		minMediaStyles,
		header
	});
	assignFooterVariables({
		baseStyles,
		minMediaStyles,
		footer
	});
	assignPaddingVariables({
		baseStyles,
		minMediaStyles,
		padding
	});
	const minMedia = getSortedBreakpoints(keys(minMediaStyles), theme.breakpoints).map((breakpoint) => ({
		query: `(min-width: ${em(breakpoint.px)})`,
		styles: minMediaStyles[breakpoint.value]
	}));
	const maxMedia = getSortedBreakpoints(keys(maxMediaStyles), theme.breakpoints).map((breakpoint) => ({
		query: `(max-width: ${em(breakpoint.px)})`,
		styles: maxMediaStyles[breakpoint.value]
	}));
	const media = [...minMedia, ...maxMedia];
	return {
		baseStyles,
		media
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellMediaStyles/AppShellMediaStyles.mjs
function AppShellMediaStyles({ navbar, header, aside, footer, padding }) {
	const theme = useMantineTheme();
	const ctx = useMantineContext();
	const { media, baseStyles } = getVariables({
		navbar,
		header,
		footer,
		aside,
		padding,
		theme
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		media,
		styles: baseStyles,
		selector: ctx.cssVariablesSelector
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellNavbar/AppShellNavbar.mjs
const defaultProps$147 = {};
const AppShellNavbar = factory((_props, ref) => {
	const props = useProps("AppShellNavbar", defaultProps$147, _props);
	const { classNames, className, style, styles, unstyled, vars, withBorder, zIndex, mod,...others } = props;
	const ctx = useAppShellContext();
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "nav",
		ref,
		mod: [{ "with-border": withBorder ?? ctx.withBorder }, mod],
		...ctx.getStyles("navbar", {
			className,
			classNames,
			styles,
			style
		}),
		...others,
		__vars: { "--app-shell-navbar-z-index": `calc(${zIndex ?? ctx.zIndex} + 1)` }
	});
});
AppShellNavbar.classes = classes$66;
AppShellNavbar.displayName = "@mantine/core/AppShellNavbar";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShellSection/AppShellSection.mjs
const defaultProps$146 = {};
const AppShellSection = polymorphicFactory((_props, ref) => {
	const props = useProps("AppShellSection", defaultProps$146, _props);
	const { classNames, className, style, styles, vars, grow, mod,...others } = props;
	const ctx = useAppShellContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{ grow }, mod],
		...ctx.getStyles("section", {
			className,
			style,
			classNames,
			styles
		}),
		...others
	});
});
AppShellSection.classes = classes$66;
AppShellSection.displayName = "@mantine/core/AppShellSection";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/use-resizing/use-resizing.mjs
function useResizing({ transitionDuration, disabled }) {
	const [resizing, setResizing] = (0, import_react.useState)(true);
	const resizingTimeout = (0, import_react.useRef)(-1);
	const disabledTimeout = (0, import_react.useRef)(-1);
	useWindowEvent("resize", () => {
		setResizing(true);
		clearTimeout(resizingTimeout.current);
		resizingTimeout.current = window.setTimeout(() => (0, import_react.startTransition)(() => {
			setResizing(false);
		}), 200);
	});
	useIsomorphicEffect(() => {
		setResizing(true);
		clearTimeout(disabledTimeout.current);
		disabledTimeout.current = window.setTimeout(() => (0, import_react.startTransition)(() => {
			setResizing(false);
		}), transitionDuration || 0);
	}, [disabled, transitionDuration]);
	return resizing;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AppShell/AppShell.mjs
const defaultProps$145 = {
	withBorder: true,
	padding: 0,
	transitionDuration: 200,
	transitionTimingFunction: "ease",
	zIndex: getDefaultZIndex("app")
};
const varsResolver$68 = createVarsResolver((_, { transitionDuration, transitionTimingFunction }) => ({ root: {
	"--app-shell-transition-duration": `${transitionDuration}ms`,
	"--app-shell-transition-timing-function": transitionTimingFunction
} }));
const AppShell = factory((_props, ref) => {
	const props = useProps("AppShell", defaultProps$145, _props);
	const { classNames, className, style, styles, unstyled, vars, navbar, withBorder, padding, transitionDuration, transitionTimingFunction, header, zIndex, layout, disabled, aside, footer, offsetScrollbars = layout !== "alt", mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "AppShell",
		classes: classes$66,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$68
	});
	const resizing = useResizing({
		disabled,
		transitionDuration
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(AppShellProvider, {
		value: {
			getStyles: getStyles$1,
			withBorder,
			zIndex,
			disabled,
			offsetScrollbars
		},
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(AppShellMediaStyles, {
			navbar,
			header,
			aside,
			footer,
			padding
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root"),
			mod: [{
				resizing,
				layout,
				disabled
			}, mod],
			...others
		})]
	});
});
AppShell.classes = classes$66;
AppShell.displayName = "@mantine/core/AppShell";
AppShell.Navbar = AppShellNavbar;
AppShell.Header = AppShellHeader;
AppShell.Main = AppShellMain;
AppShell.Aside = AppShellAside;
AppShell.Footer = AppShellFooter;
AppShell.Section = AppShellSection;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AspectRatio/AspectRatio.module.css.mjs
var classes$65 = { "root": "m_71ac47fc" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/AspectRatio/AspectRatio.mjs
const defaultProps$144 = {};
const varsResolver$67 = createVarsResolver((_, { ratio }) => ({ root: { "--ar-ratio": ratio?.toString() } }));
const AspectRatio = factory((_props, ref) => {
	const props = useProps("AspectRatio", defaultProps$144, _props);
	const { classNames, className, style, styles, unstyled, vars, ratio,...others } = props;
	const getStyles$1 = useStyles({
		name: "AspectRatio",
		classes: classes$65,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$67
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		...others
	});
});
AspectRatio.classes = classes$65;
AspectRatio.displayName = "@mantine/core/AspectRatio";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/get-parsed-combobox-data/get-parsed-combobox-data.mjs
function parseItem(item) {
	if (typeof item === "string") return {
		value: item,
		label: item
	};
	if ("value" in item && !("label" in item)) return {
		value: item.value,
		label: item.value,
		disabled: item.disabled
	};
	if (typeof item === "number") return {
		value: item.toString(),
		label: item.toString()
	};
	if ("group" in item) return {
		group: item.group,
		items: item.items.map((i) => parseItem(i))
	};
	return item;
}
function getParsedComboboxData(data) {
	if (!data) return [];
	return data.map((item) => parseItem(item));
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/get-options-lockup/get-options-lockup.mjs
function getOptionsLockup(options$1) {
	return options$1.reduce((acc, item) => {
		if ("group" in item) return {
			...acc,
			...getOptionsLockup(item.items)
		};
		acc[item.value] = item;
		return acc;
	}, {});
}
function getLabelsLockup(options$1) {
	return options$1.reduce((acc, item) => {
		if ("group" in item) return {
			...acc,
			...getLabelsLockup(item.items)
		};
		acc[item.label] = item;
		return acc;
	}, {});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/Combobox.module.css.mjs
var classes$60 = {
	"dropdown": "m_88b62a41",
	"search": "m_985517d8",
	"options": "m_b2821a6e",
	"option": "m_92253aa5",
	"empty": "m_2530cd1d",
	"header": "m_858f94bd",
	"footer": "m_82b967cb",
	"group": "m_254f3e4f",
	"groupLabel": "m_2bb2e9e5",
	"chevron": "m_2943220b",
	"optionsDropdownOption": "m_390b5f4",
	"optionsDropdownCheckIcon": "m_8ee53fc2"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxChevron/ComboboxChevron.mjs
const defaultProps$143 = { error: null };
const varsResolver$66 = createVarsResolver((theme, { size: size$3, color }) => ({ chevron: {
	"--combobox-chevron-size": getSize(size$3, "combobox-chevron-size"),
	"--combobox-chevron-color": color ? getThemeColor(color, theme) : void 0
} }));
const ComboboxChevron = factory((_props, ref) => {
	const props = useProps("ComboboxChevron", defaultProps$143, _props);
	const { size: size$3, error: error$1, style, className, classNames, styles, unstyled, vars, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "ComboboxChevron",
		classes: classes$60,
		props,
		style,
		className,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$66,
		rootSelector: "chevron"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "svg",
		...others,
		...getStyles$1("chevron"),
		size: size$3,
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		mod: [
			"combobox-chevron",
			{ error: error$1 },
			mod
		],
		ref,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
});
ComboboxChevron.classes = classes$60;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/Combobox.context.mjs
const [ComboboxProvider, useComboboxContext] = createSafeContext("Combobox component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxClearButton/ComboboxClearButton.mjs
const ComboboxClearButton = (0, import_react.forwardRef)(({ size: size$3, onMouseDown, onClick, onClear,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.ClearButton, {
	ref,
	tabIndex: -1,
	"aria-hidden": true,
	...others,
	onMouseDown: (event) => {
		event.preventDefault();
		onMouseDown?.(event);
	},
	onClick: (event) => {
		onClear();
		onClick?.(event);
	}
}));
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxDropdown/ComboboxDropdown.mjs
const defaultProps$142 = {};
const ComboboxDropdown = factory((props, ref) => {
	const { classNames, styles, className, style, hidden,...others } = useProps("ComboboxDropdown", defaultProps$142, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Dropdown, {
		...others,
		ref,
		role: "presentation",
		"data-hidden": hidden || void 0,
		...ctx.getStyles("dropdown", {
			className,
			style,
			classNames,
			styles
		})
	});
});
ComboboxDropdown.classes = classes$60;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxDropdownTarget/ComboboxDropdownTarget.mjs
const defaultProps$141 = { refProp: "ref" };
const ComboboxDropdownTarget = factory((props, ref) => {
	const { children, refProp } = useProps("ComboboxDropdownTarget", defaultProps$141, props);
	useComboboxContext();
	if (!isElement(children)) throw new Error("Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		ref,
		refProp,
		children
	});
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxEmpty/ComboboxEmpty.mjs
const defaultProps$140 = {};
const ComboboxEmpty = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("ComboboxEmpty", defaultProps$140, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("empty", {
			className,
			classNames,
			styles,
			style
		}),
		...others
	});
});
ComboboxEmpty.classes = classes$60;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/use-combobox-target-props/use-combobox-target-props.mjs
function useComboboxTargetProps({ onKeyDown, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete }) {
	const ctx = useComboboxContext();
	const [selectedOptionId, setSelectedOptionId] = (0, import_react.useState)(null);
	const handleKeyDown = (event) => {
		onKeyDown?.(event);
		if (ctx.readOnly) return;
		if (withKeyboardNavigation) {
			if (event.nativeEvent.isComposing) return;
			if (event.nativeEvent.code === "ArrowDown") {
				event.preventDefault();
				if (!ctx.store.dropdownOpened) {
					ctx.store.openDropdown("keyboard");
					setSelectedOptionId(ctx.store.selectActiveOption());
					ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
				} else setSelectedOptionId(ctx.store.selectNextOption());
			}
			if (event.nativeEvent.code === "ArrowUp") {
				event.preventDefault();
				if (!ctx.store.dropdownOpened) {
					ctx.store.openDropdown("keyboard");
					setSelectedOptionId(ctx.store.selectActiveOption());
					ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
				} else setSelectedOptionId(ctx.store.selectPreviousOption());
			}
			if (event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
				if (event.nativeEvent.keyCode === 229) return;
				const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
				if (ctx.store.dropdownOpened && selectedOptionIndex !== -1) {
					event.preventDefault();
					ctx.store.clickSelectedOption();
				} else if (targetType === "button") {
					event.preventDefault();
					ctx.store.openDropdown("keyboard");
				}
			}
			if (event.key === "Escape") ctx.store.closeDropdown("keyboard");
			if (event.nativeEvent.code === "Space") {
				if (targetType === "button") {
					event.preventDefault();
					ctx.store.toggleDropdown("keyboard");
				}
			}
		}
	};
	const ariaAttributes = withAriaAttributes ? {
		"aria-haspopup": "listbox",
		"aria-expanded": withExpandedAttribute && !!(ctx.store.listId && ctx.store.dropdownOpened) || void 0,
		"aria-controls": ctx.store.dropdownOpened ? ctx.store.listId : void 0,
		"aria-activedescendant": ctx.store.dropdownOpened ? selectedOptionId || void 0 : void 0,
		autoComplete,
		"data-expanded": ctx.store.dropdownOpened || void 0,
		"data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
	} : {};
	return {
		...ariaAttributes,
		onKeyDown: handleKeyDown
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxEventsTarget/ComboboxEventsTarget.mjs
const defaultProps$139 = {
	refProp: "ref",
	targetType: "input",
	withKeyboardNavigation: true,
	withAriaAttributes: true,
	withExpandedAttribute: false,
	autoComplete: "off"
};
const ComboboxEventsTarget = factory((props, ref) => {
	const { children, refProp, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete,...others } = useProps("ComboboxEventsTarget", defaultProps$139, props);
	if (!isElement(children)) throw new Error("Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useComboboxContext();
	const targetProps = useComboboxTargetProps({
		targetType,
		withAriaAttributes,
		withKeyboardNavigation,
		withExpandedAttribute,
		onKeyDown: children.props.onKeyDown,
		autoComplete
	});
	return (0, import_react.cloneElement)(children, {
		...targetProps,
		...others,
		[refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(children))
	});
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxFooter/ComboboxFooter.mjs
const defaultProps$138 = {};
const ComboboxFooter = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("ComboboxFooter", defaultProps$138, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("footer", {
			className,
			classNames,
			style,
			styles
		}),
		...others,
		onMouseDown: (event) => {
			event.preventDefault();
		}
	});
});
ComboboxFooter.classes = classes$60;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxGroup/ComboboxGroup.mjs
const defaultProps$137 = {};
const ComboboxGroup = factory((props, ref) => {
	const { classNames, className, style, styles, vars, children, label,...others } = useProps("ComboboxGroup", defaultProps$137, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref,
		...ctx.getStyles("group", {
			className,
			classNames,
			style,
			styles
		}),
		...others,
		children: [label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...ctx.getStyles("groupLabel", {
				classNames,
				styles
			}),
			children: label
		}), children]
	});
});
ComboboxGroup.classes = classes$60;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxHeader/ComboboxHeader.mjs
const defaultProps$136 = {};
const ComboboxHeader = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("ComboboxHeader", defaultProps$136, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("header", {
			className,
			classNames,
			style,
			styles
		}),
		...others,
		onMouseDown: (event) => {
			event.preventDefault();
		}
	});
});
ComboboxHeader.classes = classes$60;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxHiddenInput/ComboboxHiddenInput.mjs
function ComboboxHiddenInput({ value, valuesDivider = ",",...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		type: "hidden",
		value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
		...others
	});
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxOption/ComboboxOption.mjs
const defaultProps$135 = {};
const ComboboxOption = factory((_props, ref) => {
	const props = useProps("ComboboxOption", defaultProps$135, _props);
	const { classNames, className, style, styles, vars, onClick, id, active, onMouseDown, onMouseOver, disabled, selected, mod,...others } = props;
	const ctx = useComboboxContext();
	const uuid = (0, import_react.useId)();
	const _id = id || uuid;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...ctx.getStyles("option", {
			className,
			classNames,
			styles,
			style
		}),
		...others,
		ref,
		id: _id,
		mod: [
			"combobox-option",
			{
				"combobox-active": active,
				"combobox-disabled": disabled,
				"combobox-selected": selected
			},
			mod
		],
		role: "option",
		onClick: (event) => {
			if (!disabled) {
				ctx.onOptionSubmit?.(props.value, props);
				onClick?.(event);
			} else event.preventDefault();
		},
		onMouseDown: (event) => {
			event.preventDefault();
			onMouseDown?.(event);
		},
		onMouseOver: (event) => {
			if (ctx.resetSelectionOnOptionHover) ctx.store.resetSelectedOption();
			onMouseOver?.(event);
		}
	});
});
ComboboxOption.classes = classes$60;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxOptions/ComboboxOptions.mjs
const defaultProps$134 = {};
const ComboboxOptions = factory((_props, ref) => {
	const props = useProps("ComboboxOptions", defaultProps$134, _props);
	const { classNames, className, style, styles, id, onMouseDown, labelledBy,...others } = props;
	const ctx = useComboboxContext();
	const _id = useId(id);
	(0, import_react.useEffect)(() => {
		ctx.store.setListId(_id);
	}, [_id]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("options", {
			className,
			style,
			classNames,
			styles
		}),
		...others,
		id: _id,
		role: "listbox",
		"aria-labelledby": labelledBy,
		onMouseDown: (event) => {
			event.preventDefault();
			onMouseDown?.(event);
		}
	});
});
ComboboxOptions.classes = classes$60;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxSearch/ComboboxSearch.mjs
const defaultProps$133 = {
	withAriaAttributes: true,
	withKeyboardNavigation: true
};
const ComboboxSearch = factory((_props, ref) => {
	const props = useProps("ComboboxSearch", defaultProps$133, _props);
	const { classNames, styles, unstyled, vars, withAriaAttributes, onKeyDown, withKeyboardNavigation, size: size$3,...others } = props;
	const ctx = useComboboxContext();
	const _styles = ctx.getStyles("search");
	const targetProps = useComboboxTargetProps({
		targetType: "input",
		withAriaAttributes,
		withKeyboardNavigation,
		withExpandedAttribute: false,
		onKeyDown,
		autoComplete: "off"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
		ref: useMergedRef(ref, ctx.store.searchRef),
		classNames: [{ input: _styles.className }, classNames],
		styles: [{ input: _styles.style }, styles],
		size: size$3 || ctx.size,
		...targetProps,
		...others,
		__staticSelector: "Combobox"
	});
});
ComboboxSearch.classes = classes$60;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/ComboboxTarget/ComboboxTarget.mjs
const defaultProps$132 = {
	refProp: "ref",
	targetType: "input",
	withKeyboardNavigation: true,
	withAriaAttributes: true,
	withExpandedAttribute: false,
	autoComplete: "off"
};
const ComboboxTarget = factory((props, ref) => {
	const { children, refProp, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete,...others } = useProps("ComboboxTarget", defaultProps$132, props);
	if (!isElement(children)) throw new Error("Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useComboboxContext();
	const targetProps = useComboboxTargetProps({
		targetType,
		withAriaAttributes,
		withKeyboardNavigation,
		withExpandedAttribute,
		onKeyDown: children.props.onKeyDown,
		autoComplete
	});
	const clonedElement = (0, import_react.cloneElement)(children, {
		...targetProps,
		...others
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		ref: useMergedRef(ref, ctx.store.targetRef),
		children: clonedElement
	});
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/use-combobox/get-index/get-index.mjs
function getPreviousIndex$1(currentIndex, elements, loop) {
	for (let i = currentIndex - 1; i >= 0; i -= 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	if (loop) {
		for (let i = elements.length - 1; i > -1; i -= 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	}
	return currentIndex;
}
function getNextIndex$1(currentIndex, elements, loop) {
	for (let i = currentIndex + 1; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	if (loop) {
		for (let i = 0; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	}
	return currentIndex;
}
function getFirstIndex$1(elements) {
	for (let i = 0; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	return -1;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/use-combobox/use-combobox.mjs
function useCombobox({ defaultOpened, opened, onOpenedChange, onDropdownClose, onDropdownOpen, loop = true, scrollBehavior = "instant" } = {}) {
	const [dropdownOpened, setDropdownOpened] = useUncontrolled({
		value: opened,
		defaultValue: defaultOpened,
		finalValue: false,
		onChange: onOpenedChange
	});
	const listId = (0, import_react.useRef)(null);
	const selectedOptionIndex = (0, import_react.useRef)(-1);
	const searchRef = (0, import_react.useRef)(null);
	const targetRef = (0, import_react.useRef)(null);
	const focusSearchTimeout = (0, import_react.useRef)(-1);
	const focusTargetTimeout = (0, import_react.useRef)(-1);
	const selectedIndexUpdateTimeout = (0, import_react.useRef)(-1);
	const openDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (!dropdownOpened) {
			setDropdownOpened(true);
			onDropdownOpen?.(eventSource);
		}
	}, [
		setDropdownOpened,
		onDropdownOpen,
		dropdownOpened
	]);
	const closeDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (dropdownOpened) {
			setDropdownOpened(false);
			onDropdownClose?.(eventSource);
		}
	}, [
		setDropdownOpened,
		onDropdownClose,
		dropdownOpened
	]);
	const toggleDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (dropdownOpened) closeDropdown(eventSource);
		else openDropdown(eventSource);
	}, [
		closeDropdown,
		openDropdown,
		dropdownOpened
	]);
	const clearSelectedItem = (0, import_react.useCallback)(() => {
		const selected = document.querySelector(`#${listId.current} [data-combobox-selected]`);
		selected?.removeAttribute("data-combobox-selected");
		selected?.removeAttribute("aria-selected");
	}, []);
	const selectOption = (0, import_react.useCallback)((index$4) => {
		const list = document.getElementById(listId.current);
		const items = list?.querySelectorAll("[data-combobox-option]");
		if (!items) return null;
		const nextIndex = index$4 >= items.length ? 0 : index$4 < 0 ? items.length - 1 : index$4;
		selectedOptionIndex.current = nextIndex;
		if (items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled")) {
			clearSelectedItem();
			items[nextIndex].setAttribute("data-combobox-selected", "true");
			items[nextIndex].setAttribute("aria-selected", "true");
			items[nextIndex].scrollIntoView({
				block: "nearest",
				behavior: scrollBehavior
			});
			return items[nextIndex].id;
		}
		return null;
	}, [scrollBehavior, clearSelectedItem]);
	const selectActiveOption = (0, import_react.useCallback)(() => {
		const activeOption = document.querySelector(`#${listId.current} [data-combobox-active]`);
		if (activeOption) {
			const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
			const index$4 = Array.from(items).findIndex((option) => option === activeOption);
			return selectOption(index$4);
		}
		return selectOption(0);
	}, [selectOption]);
	const selectNextOption = (0, import_react.useCallback)(() => selectOption(getNextIndex$1(selectedOptionIndex.current, document.querySelectorAll(`#${listId.current} [data-combobox-option]`), loop)), [selectOption, loop]);
	const selectPreviousOption = (0, import_react.useCallback)(() => selectOption(getPreviousIndex$1(selectedOptionIndex.current, document.querySelectorAll(`#${listId.current} [data-combobox-option]`), loop)), [selectOption, loop]);
	const selectFirstOption = (0, import_react.useCallback)(() => selectOption(getFirstIndex$1(document.querySelectorAll(`#${listId.current} [data-combobox-option]`))), [selectOption]);
	const updateSelectedOptionIndex = (0, import_react.useCallback)((target = "selected", options$1) => {
		selectedIndexUpdateTimeout.current = window.setTimeout(() => {
			const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
			const index$4 = Array.from(items).findIndex((option) => option.hasAttribute(`data-combobox-${target}`));
			selectedOptionIndex.current = index$4;
			if (options$1?.scrollIntoView) items[index$4]?.scrollIntoView({
				block: "nearest",
				behavior: scrollBehavior
			});
		}, 0);
	}, []);
	const resetSelectedOption = (0, import_react.useCallback)(() => {
		selectedOptionIndex.current = -1;
		clearSelectedItem();
	}, [clearSelectedItem]);
	const clickSelectedOption = (0, import_react.useCallback)(() => {
		const items = document.querySelectorAll(`#${listId.current} [data-combobox-option]`);
		const item = items?.[selectedOptionIndex.current];
		item?.click();
	}, []);
	const setListId = (0, import_react.useCallback)((id) => {
		listId.current = id;
	}, []);
	const focusSearchInput = (0, import_react.useCallback)(() => {
		focusSearchTimeout.current = window.setTimeout(() => searchRef.current.focus(), 0);
	}, []);
	const focusTarget = (0, import_react.useCallback)(() => {
		focusTargetTimeout.current = window.setTimeout(() => targetRef.current.focus(), 0);
	}, []);
	const getSelectedOptionIndex = (0, import_react.useCallback)(() => selectedOptionIndex.current, []);
	(0, import_react.useEffect)(() => () => {
		window.clearTimeout(focusSearchTimeout.current);
		window.clearTimeout(focusTargetTimeout.current);
		window.clearTimeout(selectedIndexUpdateTimeout.current);
	}, []);
	return {
		dropdownOpened,
		openDropdown,
		closeDropdown,
		toggleDropdown,
		selectedOptionIndex: selectedOptionIndex.current,
		getSelectedOptionIndex,
		selectOption,
		selectFirstOption,
		selectActiveOption,
		selectNextOption,
		selectPreviousOption,
		resetSelectedOption,
		updateSelectedOptionIndex,
		listId: listId.current,
		setListId,
		clickSelectedOption,
		searchRef,
		focusSearchInput,
		targetRef,
		focusTarget
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/Combobox.mjs
const defaultProps$131 = {
	keepMounted: true,
	withinPortal: true,
	resetSelectionOnOptionHover: false,
	width: "target",
	transitionProps: {
		transition: "fade",
		duration: 0
	}
};
const varsResolver$65 = createVarsResolver((_, { size: size$3, dropdownPadding }) => ({
	options: {
		"--combobox-option-fz": getFontSize(size$3),
		"--combobox-option-padding": getSize(size$3, "combobox-option-padding")
	},
	dropdown: {
		"--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
		"--combobox-option-fz": getFontSize(size$3),
		"--combobox-option-padding": getSize(size$3, "combobox-option-padding")
	}
}));
function Combobox(_props) {
	const props = useProps("Combobox", defaultProps$131, _props);
	const { classNames, styles, unstyled, children, store: controlledStore, vars, onOptionSubmit, onClose, size: size$3, dropdownPadding, resetSelectionOnOptionHover, __staticSelector, readOnly,...others } = props;
	const uncontrolledStore = useCombobox();
	const store = controlledStore || uncontrolledStore;
	const getStyles$1 = useStyles({
		name: __staticSelector || "Combobox",
		classes: classes$60,
		props,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$65
	});
	const onDropdownClose = () => {
		onClose?.();
		store.closeDropdown();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ComboboxProvider, {
		value: {
			getStyles: getStyles$1,
			store,
			onOptionSubmit,
			size: size$3,
			resetSelectionOnOptionHover,
			readOnly
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover, {
			opened: store.dropdownOpened,
			...others,
			onChange: (_opened) => !_opened && onDropdownClose(),
			withRoles: false,
			unstyled,
			children
		})
	});
}
const extendCombobox = (c) => c;
Combobox.extend = extendCombobox;
Combobox.classes = classes$60;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/InlineInput/InlineInput.module.css.mjs
var classes$64 = {
	"root": "m_5f75b09e",
	"body": "m_5f6e695e",
	"labelWrapper": "m_d3ea56bb",
	"label": "m_8ee546b8",
	"description": "m_328f68c0",
	"error": "m_8e8a99cc"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/InlineInput/InlineInput.mjs
const InlineInputClasses = classes$64;
const InlineInput = (0, import_react.forwardRef)(({ __staticSelector, __stylesApiProps, className, classNames, styles, unstyled, children, label, description, id, disabled, error: error$1, size: size$3, labelPosition = "left", bodyElement = "div", labelElement = "label", variant, style, vars, mod,...others }, ref) => {
	const getStyles$1 = useStyles({
		name: __staticSelector,
		props: __stylesApiProps,
		className,
		style,
		classes: classes$64,
		classNames,
		styles,
		unstyled
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		ref,
		__vars: {
			"--label-fz": getFontSize(size$3),
			"--label-lh": getSize(size$3, "label-lh")
		},
		mod: [{ "label-position": labelPosition }, mod],
		variant,
		size: size$3,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			component: bodyElement,
			htmlFor: bodyElement === "label" ? id : void 0,
			...getStyles$1("body"),
			children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				...getStyles$1("labelWrapper"),
				"data-disabled": disabled || void 0,
				children: [
					label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
						component: labelElement,
						htmlFor: labelElement === "label" ? id : void 0,
						...getStyles$1("label"),
						"data-disabled": disabled || void 0,
						children: label
					}),
					description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Description, {
						size: size$3,
						__inheritStyles: false,
						...getStyles$1("description"),
						children: description
					}),
					error$1 && typeof error$1 !== "boolean" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Error, {
						size: size$3,
						__inheritStyles: false,
						...getStyles$1("error"),
						children: error$1
					})
				]
			})]
		})
	});
});
InlineInput.displayName = "@mantine/core/InlineInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxGroup.context.mjs
const CheckboxGroupContext = (0, import_react.createContext)(null);
const CheckboxGroupProvider = CheckboxGroupContext.Provider;
const useCheckboxGroupContext = () => (0, import_react.useContext)(CheckboxGroupContext);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.context.mjs
const [CheckboxCardProvider, useCheckboxCardContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.module.css.mjs
var classes$63 = { "card": "m_26775b0a" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxCard/CheckboxCard.mjs
const defaultProps$130 = { withBorder: true };
const varsResolver$64 = createVarsResolver((_, { radius }) => ({ card: { "--card-radius": getRadius(radius) } }));
const CheckboxCard = factory((_props, ref) => {
	const props = useProps("CheckboxCard", defaultProps$130, _props);
	const { classNames, className, style, styles, unstyled, vars, checked, mod, withBorder, value, onClick, defaultChecked, onChange,...others } = props;
	const getStyles$1 = useStyles({
		name: "CheckboxCard",
		classes: classes$63,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$64,
		rootSelector: "card"
	});
	const ctx = useCheckboxGroupContext();
	const _checked = typeof checked === "boolean" ? checked : ctx ? ctx.value.includes(value || "") : void 0;
	const [_value, setValue] = useUncontrolled({
		value: _checked,
		defaultValue: defaultChecked,
		finalValue: false,
		onChange
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckboxCardProvider, {
		value: { checked: _value },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			ref,
			mod: [{
				"with-border": withBorder,
				checked: _value
			}, mod],
			...getStyles$1("card"),
			...others,
			role: "checkbox",
			"aria-checked": _value,
			onClick: (event) => {
				onClick?.(event);
				ctx?.onChange(value || "");
				setValue(!_value);
			}
		})
	});
});
CheckboxCard.displayName = "@mantine/core/CheckboxCard";
CheckboxCard.classes = classes$63;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/InputsGroupFieldset/InputsGroupFieldset.mjs
function InputsGroupFieldset({ children, role }) {
	const ctx = useInputWrapperContext();
	if (!ctx) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		role,
		"aria-labelledby": ctx.labelId,
		"aria-describedby": ctx.describedBy,
		children
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxGroup/CheckboxGroup.mjs
const defaultProps$129 = {};
const CheckboxGroup = factory((props, ref) => {
	const { value, defaultValue, onChange, size: size$3, wrapperProps, children, readOnly,...others } = useProps("CheckboxGroup", defaultProps$129, props);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [],
		onChange
	});
	const handleChange = (event) => {
		const itemValue = typeof event === "string" ? event : event.currentTarget.value;
		!readOnly && setValue(_value.includes(itemValue) ? _value.filter((item) => item !== itemValue) : [..._value, itemValue]);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckboxGroupProvider, {
		value: {
			value: _value,
			onChange: handleChange,
			size: size$3
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
			size: size$3,
			ref,
			...wrapperProps,
			...others,
			labelElement: "div",
			__staticSelector: "CheckboxGroup",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputsGroupFieldset, {
				role: "group",
				children
			})
		})
	});
});
CheckboxGroup.classes = Input.Wrapper.classes;
CheckboxGroup.displayName = "@mantine/core/CheckboxGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckIcon.mjs
function CheckIcon({ size: size$3, style,...others }) {
	const _style = size$3 !== void 0 ? {
		width: rem(size$3),
		height: rem(size$3),
		...style
	} : style;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		viewBox: "0 0 10 7",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		style: _style,
		"aria-hidden": true,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}
function CheckboxIcon({ indeterminate,...others }) {
	if (indeterminate) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "none",
		viewBox: "0 0 32 6",
		"aria-hidden": true,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("rect", {
			width: "32",
			height: "6",
			fill: "currentColor",
			rx: "3"
		})
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, { ...others });
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxIndicator/CheckboxIndicator.module.css.mjs
var classes$62 = {
	"indicator": "m_5e5256ee",
	"icon": "m_1b1c543a",
	"indicator--outline": "m_76e20374"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/CheckboxIndicator/CheckboxIndicator.mjs
const defaultProps$128 = { icon: CheckboxIcon };
const varsResolver$63 = createVarsResolver((theme, { radius, color, size: size$3, iconColor, variant, autoContrast }) => {
	const parsedColor = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	const outlineColor = parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
	return { indicator: {
		"--checkbox-size": getSize(size$3, "checkbox-size"),
		"--checkbox-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--checkbox-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
		"--checkbox-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({
			color,
			theme,
			autoContrast
		}) : void 0
	} };
});
const CheckboxIndicator = factory((_props, ref) => {
	const props = useProps("CheckboxIndicator", defaultProps$128, _props);
	const { classNames, className, style, styles, unstyled, vars, icon, indeterminate, radius, color, iconColor, autoContrast, checked, mod, variant, disabled,...others } = props;
	const Icon = icon;
	const getStyles$1 = useStyles({
		name: "CheckboxIndicator",
		classes: classes$62,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$63,
		rootSelector: "indicator"
	});
	const ctx = useCheckboxCardContext();
	const _checked = typeof checked === "boolean" || typeof indeterminate === "boolean" ? checked || indeterminate : ctx?.checked || false;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("indicator", { variant }),
		variant,
		mod: [{
			checked: _checked,
			disabled
		}, mod],
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
			indeterminate,
			...getStyles$1("icon")
		})
	});
});
CheckboxIndicator.displayName = "@mantine/core/CheckboxIndicator";
CheckboxIndicator.classes = classes$62;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/Checkbox.module.css.mjs
var classes$61 = {
	"root": "m_bf2d988c",
	"inner": "m_26062bec",
	"input": "m_26063560",
	"icon": "m_bf295423",
	"input--outline": "m_215c4542"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Checkbox/Checkbox.mjs
const defaultProps$127 = {
	labelPosition: "right",
	icon: CheckboxIcon
};
const varsResolver$62 = createVarsResolver((theme, { radius, color, size: size$3, iconColor, variant, autoContrast }) => {
	const parsedColor = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	const outlineColor = parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
	return { root: {
		"--checkbox-size": getSize(size$3, "checkbox-size"),
		"--checkbox-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--checkbox-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
		"--checkbox-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({
			color,
			theme,
			autoContrast
		}) : void 0
	} };
});
const Checkbox = factory((_props, forwardedRef) => {
	const props = useProps("Checkbox", defaultProps$127, _props);
	const { classNames, className, style, styles, unstyled, vars, color, label, id, size: size$3, radius, wrapperProps, checked, labelPosition, description, error: error$1, disabled, variant, indeterminate, icon, rootRef, iconColor, onChange, autoContrast, mod,...others } = props;
	const ctx = useCheckboxGroupContext();
	const _size = size$3 || ctx?.size;
	const Icon = icon;
	const getStyles$1 = useStyles({
		name: "Checkbox",
		props,
		classes: classes$61,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$62
	});
	const { styleProps, rest } = extractStyleProps(others);
	const uuid = useId(id);
	const contextProps = ctx ? {
		checked: ctx.value.includes(rest.value),
		onChange: (event) => {
			ctx.onChange(event);
			onChange?.(event);
		}
	} : {};
	const fallbackRef = (0, import_react.useRef)(null);
	const ref = forwardedRef || fallbackRef;
	(0, import_react.useEffect)(() => {
		if (ref && "current" in ref && ref.current) ref.current.indeterminate = indeterminate || false;
	}, [indeterminate, ref]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineInput, {
		...getStyles$1("root"),
		__staticSelector: "Checkbox",
		__stylesApiProps: props,
		id: uuid,
		size: _size,
		labelPosition,
		label,
		description,
		error: error$1,
		disabled,
		classNames,
		styles,
		unstyled,
		"data-checked": contextProps.checked || checked || void 0,
		variant,
		ref: rootRef,
		mod,
		...styleProps,
		...wrapperProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("inner"),
			mod: { "data-label-position": labelPosition },
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "input",
				id: uuid,
				ref,
				checked,
				disabled,
				mod: {
					error: !!error$1,
					indeterminate
				},
				...getStyles$1("input", {
					focusable: true,
					variant
				}),
				onChange,
				...rest,
				...contextProps,
				type: "checkbox"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
				indeterminate,
				...getStyles$1("icon")
			})]
		})
	});
});
Checkbox.classes = {
	...classes$61,
	...InlineInputClasses
};
Checkbox.displayName = "@mantine/core/Checkbox";
Checkbox.Group = CheckboxGroup;
Checkbox.Indicator = CheckboxIndicator;
Checkbox.Card = CheckboxCard;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/is-options-group.mjs
function isOptionsGroup(item) {
	return "group" in item;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/default-options-filter.mjs
function defaultOptionsFilter({ options: options$1, search, limit }) {
	const parsedSearch = search.trim().toLowerCase();
	const result = [];
	for (let i = 0; i < options$1.length; i += 1) {
		const item = options$1[i];
		if (result.length === limit) return result;
		if (isOptionsGroup(item)) result.push({
			group: item.group,
			items: defaultOptionsFilter({
				options: item.items,
				search,
				limit: limit - result.length
			})
		});
		if (!isOptionsGroup(item)) {
			if (item.label.toLowerCase().includes(parsedSearch)) result.push(item);
		}
	}
	return result;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/is-empty-combobox-data.mjs
function isEmptyComboboxData(data) {
	if (data.length === 0) return true;
	for (const item of data) {
		if (!("group" in item)) return false;
		if (item.items.length > 0) return false;
	}
	return true;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/validate-options.mjs
function validateOptions(options$1, valuesSet = /* @__PURE__ */ new Set()) {
	if (!Array.isArray(options$1)) return;
	for (const option of options$1) if (isOptionsGroup(option)) validateOptions(option.items, valuesSet);
	else {
		if (typeof option.value === "undefined") throw new Error("[@mantine/core] Each option must have value property");
		if (typeof option.value !== "string") throw new Error(`[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`);
		if (valuesSet.has(option.value)) throw new Error(`[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`);
		valuesSet.add(option.value);
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/OptionsDropdown/OptionsDropdown.mjs
function isValueChecked(value, optionValue) {
	return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({ data, withCheckIcon, value, checkIconPosition, unstyled, renderOption }) {
	if (!isOptionsGroup(data)) {
		const checked = isValueChecked(value, data.value);
		const check = withCheckIcon && checked && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, { className: classes$60.optionsDropdownCheckIcon });
		const defaultContent = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
			checkIconPosition === "left" && check,
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: data.label }),
			checkIconPosition === "right" && check
		] });
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Option, {
			value: data.value,
			disabled: data.disabled,
			className: clsx_default({ [classes$60.optionsDropdownOption]: !unstyled }),
			"data-reverse": checkIconPosition === "right" || void 0,
			"data-checked": checked || void 0,
			"aria-selected": checked,
			active: checked,
			children: typeof renderOption === "function" ? renderOption({
				option: data,
				checked
			}) : defaultContent
		});
	}
	const options$1 = data.items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Option, {
		data: item,
		value,
		unstyled,
		withCheckIcon,
		checkIconPosition,
		renderOption
	}, item.value));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Group, {
		label: data.group,
		children: options$1
	});
}
function OptionsDropdown({ data, hidden, hiddenWhenEmpty, filter, search, limit, maxDropdownHeight, withScrollArea = true, filterOptions = true, withCheckIcon = false, value, checkIconPosition, nothingFoundMessage, unstyled, labelId, renderOption, scrollAreaProps, "aria-label": ariaLabel }) {
	validateOptions(data);
	const shouldFilter = typeof search === "string";
	const filteredData = shouldFilter ? (filter || defaultOptionsFilter)({
		options: data,
		search: filterOptions ? search : "",
		limit: limit ?? Infinity
	}) : data;
	const isEmpty = isEmptyComboboxData(filteredData);
	const options$1 = filteredData.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Option, {
		data: item,
		withCheckIcon,
		value,
		checkIconPosition,
		unstyled,
		renderOption
	}, isOptionsGroup(item) ? item.group : item.value));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Dropdown, {
		hidden: hidden || hiddenWhenEmpty && isEmpty,
		"data-composed": true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox.Options, {
			labelledBy: labelId,
			"aria-label": ariaLabel,
			children: [withScrollArea ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollArea.Autosize, {
				mah: maxDropdownHeight ?? 220,
				type: "scroll",
				scrollbarSize: "var(--combobox-padding)",
				offsetScrollbars: "y",
				...scrollAreaProps,
				children: options$1
			}) : options$1, isEmpty && nothingFoundMessage && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Empty, { children: nothingFoundMessage })]
		})
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Autocomplete/Autocomplete.mjs
const defaultProps$126 = {};
const Autocomplete = factory((_props, ref) => {
	const props = useProps("Autocomplete", defaultProps$126, _props);
	const { classNames, styles, unstyled, vars, dropdownOpened, defaultDropdownOpened, onDropdownClose, onDropdownOpen, onFocus, onBlur, onClick, onChange, data, value, defaultValue, selectFirstOptionOnChange, onOptionSubmit, comboboxProps, readOnly, disabled, filter, limit, withScrollArea, maxDropdownHeight, size: size$3, id, renderOption, autoComplete, scrollAreaProps, onClear, clearButtonProps, error: error$1, clearable, rightSection,...others } = props;
	const _id = useId(id);
	const parsedData = getParsedComboboxData(data);
	const optionsLockup = getOptionsLockup(parsedData);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const combobox = useCombobox({
		opened: dropdownOpened,
		defaultOpened: defaultDropdownOpened,
		onDropdownOpen,
		onDropdownClose: () => {
			onDropdownClose?.();
			combobox.resetSelectedOption();
		}
	});
	const handleValueChange = (value2) => {
		setValue(value2);
		combobox.resetSelectedOption();
	};
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		props,
		styles,
		classNames
	});
	(0, import_react.useEffect)(() => {
		if (selectFirstOptionOnChange) combobox.selectFirstOption();
	}, [selectFirstOptionOnChange, _value]);
	const clearButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.ClearButton, {
		...clearButtonProps,
		onClear: () => {
			handleValueChange("");
			onClear?.();
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox, {
		store: combobox,
		__staticSelector: "Autocomplete",
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		readOnly,
		onOptionSubmit: (val) => {
			onOptionSubmit?.(val);
			handleValueChange(optionsLockup[val].label);
			combobox.closeDropdown();
		},
		size: size$3,
		...comboboxProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Target, {
			autoComplete,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
				ref,
				...others,
				size: size$3,
				__staticSelector: "Autocomplete",
				__clearSection: clearButton,
				__clearable: clearable && !!_value && !disabled && !readOnly,
				rightSection,
				disabled,
				readOnly,
				value: _value,
				error: error$1,
				onChange: (event) => {
					handleValueChange(event.currentTarget.value);
					combobox.openDropdown();
					selectFirstOptionOnChange && combobox.selectFirstOption();
				},
				onFocus: (event) => {
					combobox.openDropdown();
					onFocus?.(event);
				},
				onBlur: (event) => {
					combobox.closeDropdown();
					onBlur?.(event);
				},
				onClick: (event) => {
					combobox.openDropdown();
					onClick?.(event);
				},
				classNames: resolvedClassNames,
				styles: resolvedStyles,
				unstyled,
				id: _id
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionsDropdown, {
			data: parsedData,
			hidden: readOnly || disabled,
			filter,
			search: _value,
			limit,
			hiddenWhenEmpty: true,
			withScrollArea,
			maxDropdownHeight,
			unstyled,
			labelId: others.label ? `${_id}-label` : void 0,
			"aria-label": others.label ? void 0 : others["aria-label"],
			renderOption,
			scrollAreaProps
		})]
	});
});
Autocomplete.classes = {
	...InputBase.classes,
	...Combobox.classes
};
Autocomplete.displayName = "@mantine/core/Autocomplete";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/AvatarGroup/AvatarGroup.context.mjs
const AvatarGroupContext = (0, import_react.createContext)(null);
const AvatarGroupProvider = AvatarGroupContext.Provider;
function useAvatarGroupContext() {
	const ctx = (0, import_react.useContext)(AvatarGroupContext);
	return { withinGroup: !!ctx };
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/Avatar.module.css.mjs
var classes$59 = {
	"group": "m_11def92b",
	"root": "m_f85678b6",
	"image": "m_11f8ac07",
	"placeholder": "m_104cd71f"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/AvatarGroup/AvatarGroup.mjs
const defaultProps$125 = {};
const varsResolver$61 = createVarsResolver((_, { spacing }) => ({ group: { "--ag-spacing": getSpacing(spacing) } }));
const AvatarGroup = factory((_props, ref) => {
	const props = useProps("AvatarGroup", defaultProps$125, _props);
	const { classNames, className, style, styles, unstyled, vars, spacing,...others } = props;
	const getStyles$1 = useStyles({
		name: "AvatarGroup",
		classes: classes$59,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$61,
		rootSelector: "group"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AvatarGroupProvider, {
		value: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("group"),
			...others
		})
	});
});
AvatarGroup.classes = classes$59;
AvatarGroup.displayName = "@mantine/core/AvatarGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/AvatarPlaceholderIcon.mjs
function AvatarPlaceholderIcon(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		...props,
		"data-avatar-placeholder-icon": true,
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M0.877014 7.49988C0.877014 3.84219 3.84216 0.877045 7.49985 0.877045C11.1575 0.877045 14.1227 3.84219 14.1227 7.49988C14.1227 11.1575 11.1575 14.1227 7.49985 14.1227C3.84216 14.1227 0.877014 11.1575 0.877014 7.49988ZM7.49985 1.82704C4.36683 1.82704 1.82701 4.36686 1.82701 7.49988C1.82701 8.97196 2.38774 10.3131 3.30727 11.3213C4.19074 9.94119 5.73818 9.02499 7.50023 9.02499C9.26206 9.02499 10.8093 9.94097 11.6929 11.3208C12.6121 10.3127 13.1727 8.97172 13.1727 7.49988C13.1727 4.36686 10.6328 1.82704 7.49985 1.82704ZM10.9818 11.9787C10.2839 10.7795 8.9857 9.97499 7.50023 9.97499C6.01458 9.97499 4.71624 10.7797 4.01845 11.9791C4.97952 12.7272 6.18765 13.1727 7.49985 13.1727C8.81227 13.1727 10.0206 12.727 10.9818 11.9787ZM5.14999 6.50487C5.14999 5.207 6.20212 4.15487 7.49999 4.15487C8.79786 4.15487 9.84999 5.207 9.84999 6.50487C9.84999 7.80274 8.79786 8.85487 7.49999 8.85487C6.20212 8.85487 5.14999 7.80274 5.14999 6.50487ZM7.49999 5.10487C6.72679 5.10487 6.09999 5.73167 6.09999 6.50487C6.09999 7.27807 6.72679 7.90487 7.49999 7.90487C8.27319 7.90487 8.89999 7.27807 8.89999 6.50487C8.89999 5.73167 8.27319 5.10487 7.49999 5.10487Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/get-initials-color/get-initials-color.mjs
function hashCode(input) {
	let hash = 0;
	for (let i = 0; i < input.length; i += 1) {
		const char = input.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash |= 0;
	}
	return hash;
}
const defaultColors = [
	"blue",
	"cyan",
	"grape",
	"green",
	"indigo",
	"lime",
	"orange",
	"pink",
	"red",
	"teal",
	"violet"
];
function getInitialsColor(name, colors = defaultColors) {
	const hash = hashCode(name);
	const index$4 = Math.abs(hash) % colors.length;
	return colors[index$4];
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/get-initials/get-initials.mjs
function getInitials(name, limit = 2) {
	const splitted = name.split(" ");
	if (splitted.length === 1) return name.slice(0, limit).toUpperCase();
	return splitted.map((word) => word[0]).slice(0, limit).join("").toUpperCase();
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Avatar/Avatar.mjs
const defaultProps$124 = {};
const varsResolver$60 = createVarsResolver((theme, { size: size$3, radius, variant, gradient, color, autoContrast, name, allowedInitialsColors }) => {
	const _color = color === "initials" && typeof name === "string" ? getInitialsColor(name, allowedInitialsColors) : color;
	const colors = theme.variantColorResolver({
		color: _color || "gray",
		theme,
		gradient,
		variant: variant || "light",
		autoContrast
	});
	return { root: {
		"--avatar-size": getSize(size$3, "avatar-size"),
		"--avatar-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--avatar-bg": _color || variant ? colors.background : void 0,
		"--avatar-color": _color || variant ? colors.color : void 0,
		"--avatar-bd": _color || variant ? colors.border : void 0
	} };
});
const Avatar = polymorphicFactory((_props, ref) => {
	const props = useProps("Avatar", defaultProps$124, _props);
	const { classNames, className, style, styles, unstyled, vars, src, alt, radius, color, gradient, imageProps, children, autoContrast, mod, name, allowedInitialsColors,...others } = props;
	const ctx = useAvatarGroupContext();
	const [error$1, setError] = (0, import_react.useState)(!src);
	const getStyles$1 = useStyles({
		name: "Avatar",
		props,
		classes: classes$59,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$60
	});
	(0, import_react.useEffect)(() => setError(!src), [src]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		mod: [{ "within-group": ctx.withinGroup }, mod],
		ref,
		...others,
		children: error$1 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			...getStyles$1("placeholder"),
			title: alt,
			children: children || typeof name === "string" && getInitials(name) || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AvatarPlaceholderIcon, {})
		}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
			...imageProps,
			...getStyles$1("image"),
			src,
			alt,
			onError: (event) => {
				setError(true);
				imageProps?.onError?.(event);
			}
		})
	});
});
Avatar.classes = classes$59;
Avatar.displayName = "@mantine/core/Avatar";
Avatar.Group = AvatarGroup;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/BackgroundImage/BackgroundImage.module.css.mjs
var classes$58 = { "root": "m_2ce0de02" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/BackgroundImage/BackgroundImage.mjs
const defaultProps$123 = {};
const varsResolver$59 = createVarsResolver((_, { radius }) => ({ root: { "--bi-radius": radius === void 0 ? void 0 : getRadius(radius) } }));
const BackgroundImage = polymorphicFactory((_props, ref) => {
	const props = useProps("BackgroundImage", defaultProps$123, _props);
	const { classNames, className, style, styles, unstyled, vars, radius, src, variant,...others } = props;
	const getStyles$1 = useStyles({
		name: "BackgroundImage",
		props,
		classes: classes$58,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$59
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		variant,
		...getStyles$1("root", { style: { backgroundImage: `url(${src})` } }),
		...others
	});
});
BackgroundImage.classes = classes$58;
BackgroundImage.displayName = "@mantine/core/BackgroundImage";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Badge/Badge.module.css.mjs
var classes$57 = {
	"root": "m_347db0ec",
	"root--dot": "m_fbd81e3d",
	"label": "m_5add502a",
	"section": "m_91fdda9b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Badge/Badge.mjs
const defaultProps$122 = {};
const varsResolver$58 = createVarsResolver((theme, { radius, color, gradient, variant, size: size$3, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--badge-height": getSize(size$3, "badge-height"),
		"--badge-padding-x": getSize(size$3, "badge-padding-x"),
		"--badge-fz": getSize(size$3, "badge-fz"),
		"--badge-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--badge-bg": color || variant ? colors.background : void 0,
		"--badge-color": color || variant ? colors.color : void 0,
		"--badge-bd": color || variant ? colors.border : void 0,
		"--badge-dot-color": variant === "dot" ? getThemeColor(color, theme) : void 0
	} };
});
const Badge = polymorphicFactory((_props, ref) => {
	const props = useProps("Badge", defaultProps$122, _props);
	const { classNames, className, style, styles, unstyled, vars, radius, color, gradient, leftSection, rightSection, children, variant, fullWidth, autoContrast, circle, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Badge",
		props,
		classes: classes$57,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$58
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		variant,
		mod: [{
			block: fullWidth,
			circle,
			"with-right-section": !!rightSection,
			"with-left-section": !!leftSection
		}, mod],
		...getStyles$1("root", { variant }),
		ref,
		...others,
		children: [
			leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("section"),
				"data-position": "left",
				children: leftSection
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("label"),
				children
			}),
			rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("section"),
				"data-position": "right",
				children: rightSection
			})
		]
	});
});
Badge.classes = classes$57;
Badge.displayName = "@mantine/core/Badge";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Blockquote/Blockquote.module.css.mjs
var classes$56 = {
	"root": "m_ddec01c0",
	"icon": "m_dde7bd57",
	"cite": "m_dde51a35"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Blockquote/Blockquote.mjs
const defaultProps$121 = { iconSize: 48 };
const varsResolver$57 = createVarsResolver((theme, { color, iconSize, radius }) => {
	const darkParsed = parseThemeColor({
		color: color || theme.primaryColor,
		theme,
		colorScheme: "dark"
	});
	const lightParsed = parseThemeColor({
		color: color || theme.primaryColor,
		theme,
		colorScheme: "light"
	});
	return { root: {
		"--bq-bg-light": rgba(lightParsed.value, .07),
		"--bq-bg-dark": rgba(darkParsed.value, .06),
		"--bq-bd": getThemeColor(color, theme),
		"--bq-icon-size": rem(iconSize),
		"--bq-radius": getRadius(radius)
	} };
});
const Blockquote = factory((_props, ref) => {
	const props = useProps("Blockquote", defaultProps$121, _props);
	const { classNames, className, style, styles, unstyled, vars, children, icon, iconSize, cite,...others } = props;
	const getStyles$1 = useStyles({
		name: "Blockquote",
		classes: classes$56,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$57
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		component: "blockquote",
		ref,
		...getStyles$1("root"),
		...others,
		children: [
			icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("icon"),
				children: icon
			}),
			children,
			cite && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("cite", {
				...getStyles$1("cite"),
				children: cite
			})
		]
	});
});
Blockquote.classes = classes$56;
Blockquote.displayName = "@mantine/core/Blockquote";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Breadcrumbs/Breadcrumbs.module.css.mjs
var classes$55 = {
	"root": "m_8b3717df",
	"breadcrumb": "m_f678d540",
	"separator": "m_3b8f2208"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Breadcrumbs/Breadcrumbs.mjs
const defaultProps$120 = { separator: "/" };
const varsResolver$56 = createVarsResolver((_, { separatorMargin }) => ({ root: { "--bc-separator-margin": getSpacing(separatorMargin) } }));
const Breadcrumbs = factory((_props, ref) => {
	const props = useProps("Breadcrumbs", defaultProps$120, _props);
	const { classNames, className, style, styles, unstyled, vars, children, separator, separatorMargin,...others } = props;
	const getStyles$1 = useStyles({
		name: "Breadcrumbs",
		classes: classes$55,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$56
	});
	const items = import_react.Children.toArray(children).reduce((acc, child, index$4, array) => {
		const item = isElement(child) ? (0, import_react.cloneElement)(child, {
			...getStyles$1("breadcrumb", { className: child.props?.className }),
			key: index$4
		}) : /* @__PURE__ */ (0, import_react.createElement)("div", {
			...getStyles$1("breadcrumb"),
			key: index$4
		}, child);
		acc.push(item);
		if (index$4 !== array.length - 1) acc.push(/* @__PURE__ */ (0, import_react.createElement)(Box, {
			...getStyles$1("separator"),
			key: `separator-${index$4}`
		}, separator));
		return acc;
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		...others,
		children: items
	});
});
Breadcrumbs.classes = classes$55;
Breadcrumbs.displayName = "@mantine/core/Breadcrumbs";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Burger/Burger.module.css.mjs
var classes$54 = {
	"root": "m_fea6bf1a",
	"burger": "m_d4fb9cad"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Burger/Burger.mjs
const defaultProps$119 = {};
const varsResolver$55 = createVarsResolver((theme, { color, size: size$3, lineSize, transitionDuration, transitionTimingFunction }) => ({ root: {
	"--burger-color": color ? getThemeColor(color, theme) : void 0,
	"--burger-size": getSize(size$3, "burger-size"),
	"--burger-line-size": lineSize ? rem(lineSize) : void 0,
	"--burger-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
	"--burger-transition-timing-function": transitionTimingFunction
} }));
const Burger = factory((_props, ref) => {
	const props = useProps("Burger", defaultProps$119, _props);
	const { classNames, className, style, styles, unstyled, vars, opened, children, transitionDuration, transitionTimingFunction, lineSize,...others } = props;
	const getStyles$1 = useStyles({
		name: "Burger",
		classes: classes$54,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$55
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...getStyles$1("root"),
		ref,
		...others,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			mod: ["reduce-motion", { opened }],
			...getStyles$1("burger")
		}), children]
	});
});
Burger.classes = classes$54;
Burger.displayName = "@mantine/core/Burger";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Button/Button.module.css.mjs
var classes$53 = {
	"root": "m_77c9d27d",
	"inner": "m_80f1301b",
	"label": "m_811560b9",
	"section": "m_a74036a",
	"loader": "m_a25b86ee",
	"group": "m_80d6d844",
	"groupSection": "m_70be2a01"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Button/ButtonGroup/ButtonGroup.mjs
const defaultProps$118 = { orientation: "horizontal" };
const varsResolver$54 = createVarsResolver((_, { borderWidth }) => ({ group: { "--button-border-width": rem(borderWidth) } }));
const ButtonGroup = factory((_props, ref) => {
	const props = useProps("ButtonGroup", defaultProps$118, _props);
	const { className, style, classNames, styles, unstyled, orientation, vars, borderWidth, variant, mod,...others } = useProps("ButtonGroup", defaultProps$118, _props);
	const getStyles$1 = useStyles({
		name: "ButtonGroup",
		props,
		classes: classes$53,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$54,
		rootSelector: "group"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("group"),
		ref,
		variant,
		mod: [{ "data-orientation": orientation }, mod],
		role: "group",
		...others
	});
});
ButtonGroup.classes = classes$53;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Button/ButtonGroupSection/ButtonGroupSection.mjs
const defaultProps$117 = {};
const varsResolver$53 = createVarsResolver((theme, { radius, color, gradient, variant, autoContrast, size: size$3 }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { groupSection: {
		"--section-height": getSize(size$3, "section-height"),
		"--section-padding-x": getSize(size$3, "section-padding-x"),
		"--section-fz": size$3?.includes("compact") ? getFontSize(size$3.replace("compact-", "")) : getFontSize(size$3),
		"--section-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--section-bg": color || variant ? colors.background : void 0,
		"--section-color": colors.color,
		"--section-bd": color || variant ? colors.border : void 0
	} };
});
const ButtonGroupSection = factory((_props, ref) => {
	const props = useProps("ButtonGroupSection", defaultProps$117, _props);
	const { className, style, classNames, styles, unstyled, vars, variant, gradient, radius, autoContrast,...others } = useProps("ButtonGroupSection", defaultProps$117, _props);
	const getStyles$1 = useStyles({
		name: "ButtonGroupSection",
		props,
		classes: classes$53,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$53,
		rootSelector: "groupSection"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("groupSection"),
		ref,
		variant,
		...others
	});
});
ButtonGroupSection.classes = classes$53;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Button/Button.mjs
const loaderTransition = {
	in: {
		opacity: 1,
		transform: `translate(-50%, calc(-50% + ${rem(1)}))`
	},
	out: {
		opacity: 0,
		transform: "translate(-50%, -200%)"
	},
	common: { transformOrigin: "center" },
	transitionProperty: "transform, opacity"
};
const defaultProps$116 = {};
const varsResolver$52 = createVarsResolver((theme, { radius, color, gradient, variant, size: size$3, justify, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--button-justify": justify,
		"--button-height": getSize(size$3, "button-height"),
		"--button-padding-x": getSize(size$3, "button-padding-x"),
		"--button-fz": size$3?.includes("compact") ? getFontSize(size$3.replace("compact-", "")) : getFontSize(size$3),
		"--button-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--button-bg": color || variant ? colors.background : void 0,
		"--button-hover": color || variant ? colors.hover : void 0,
		"--button-color": colors.color,
		"--button-bd": color || variant ? colors.border : void 0,
		"--button-hover-color": color || variant ? colors.hoverColor : void 0
	} };
});
const Button = polymorphicFactory((_props, ref) => {
	const props = useProps("Button", defaultProps$116, _props);
	const { style, vars, className, color, disabled, children, leftSection, rightSection, fullWidth, variant, radius, loading, loaderProps, gradient, classNames, styles, unstyled, "data-disabled": dataDisabled, autoContrast, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Button",
		props,
		classes: classes$53,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$52
	});
	const hasLeftSection = !!leftSection;
	const hasRightSection = !!rightSection;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		ref,
		...getStyles$1("root", { active: !disabled && !loading && !dataDisabled }),
		unstyled,
		variant,
		disabled: disabled || loading,
		mod: [{
			disabled: disabled || dataDisabled,
			loading,
			block: fullWidth,
			"with-left-section": hasLeftSection,
			"with-right-section": hasRightSection
		}, mod],
		...others,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: !!loading,
			transition: loaderTransition,
			duration: 150,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				...getStyles$1("loader", { style: transitionStyles }),
				"aria-hidden": true,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
					color: "var(--button-color)",
					size: "calc(var(--button-height) / 1.8)",
					...loaderProps
				})
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
			...getStyles$1("inner"),
			children: [
				leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					...getStyles$1("section"),
					mod: { position: "left" },
					children: leftSection
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					mod: { loading },
					...getStyles$1("label"),
					children
				}),
				rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					...getStyles$1("section"),
					mod: { position: "right" },
					children: rightSection
				})
			]
		})]
	});
});
Button.classes = classes$53;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Card/Card.context.mjs
const [CardProvider, useCardContext] = createSafeContext("Card component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Card/Card.module.css.mjs
var classes$52 = {
	"root": "m_e615b15f",
	"section": "m_599a2148"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Card/CardSection/CardSection.mjs
const defaultProps$115 = {};
const CardSection = polymorphicFactory((_props, ref) => {
	const props = useProps("CardSection", defaultProps$115, _props);
	const { classNames, className, style, styles, vars, withBorder, inheritPadding, mod,...others } = props;
	const ctx = useCardContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{
			"with-border": withBorder,
			"inherit-padding": inheritPadding
		}, mod],
		...ctx.getStyles("section", {
			className,
			style,
			styles,
			classNames
		}),
		...others
	});
});
CardSection.classes = classes$52;
CardSection.displayName = "@mantine/core/CardSection";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Card/Card.mjs
const defaultProps$114 = {};
const varsResolver$51 = createVarsResolver((_, { padding }) => ({ root: { "--card-padding": getSpacing(padding) } }));
const Card = polymorphicFactory((_props, ref) => {
	const props = useProps("Card", defaultProps$114, _props);
	const { classNames, className, style, styles, unstyled, vars, children, padding,...others } = props;
	const getStyles$1 = useStyles({
		name: "Card",
		props,
		classes: classes$52,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$51
	});
	const _children = import_react.Children.toArray(children);
	const content = _children.map((child, index$4) => {
		if (typeof child === "object" && child && "type" in child && child.type === CardSection) return (0, import_react.cloneElement)(child, {
			"data-first-section": index$4 === 0 || void 0,
			"data-last-section": index$4 === _children.length - 1 || void 0
		});
		return child;
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardProvider, {
		value: { getStyles: getStyles$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Paper, {
			ref,
			unstyled,
			...getStyles$1("root"),
			...others,
			children: content
		})
	});
});
Card.classes = classes$52;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Center/Center.module.css.mjs
var classes$51 = { "root": "m_4451eb3a" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Center/Center.mjs
const defaultProps$113 = {};
const Center = polymorphicFactory((_props, ref) => {
	const props = useProps("Center", defaultProps$113, _props);
	const { classNames, className, style, styles, unstyled, vars, inline: inline$3, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Center",
		props,
		classes: classes$51,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{ inline: inline$3 }, mod],
		...getStyles$1("root"),
		...others
	});
});
Center.classes = classes$51;
Center.displayName = "@mantine/core/Center";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Chip/ChipGroup.context.mjs
const [ChipGroupProvider, useChipGroupContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Chip/ChipGroup/ChipGroup.mjs
const defaultProps$112 = {};
function ChipGroup(props) {
	const { value, defaultValue, onChange, multiple, children } = useProps("ChipGroup", defaultProps$112, props);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: multiple ? [] : null,
		onChange
	});
	const isChipSelected = (val) => Array.isArray(_value) ? _value.includes(val) : val === _value;
	const handleChange = (event) => {
		const val = event.currentTarget.value;
		if (Array.isArray(_value)) setValue(_value.includes(val) ? _value.filter((v) => v !== val) : [..._value, val]);
		else setValue(val);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChipGroupProvider, {
		value: {
			isChipSelected,
			onChange: handleChange,
			multiple
		},
		children
	});
}
ChipGroup.displayName = "@mantine/core/ChipGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Chip/Chip.module.css.mjs
var classes$50 = {
	"root": "m_f59ffda3",
	"label": "m_be049a53",
	"label--outline": "m_3904c1af",
	"label--filled": "m_fa109255",
	"label--light": "m_f7e165c3",
	"iconWrapper": "m_9ac86df9",
	"checkIcon": "m_d6d72580",
	"input": "m_bde07329"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Chip/Chip.mjs
const defaultProps$111 = { type: "checkbox" };
const varsResolver$50 = createVarsResolver((theme, { size: size$3, radius, variant, color, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--chip-fz": getFontSize(size$3),
		"--chip-size": getSize(size$3, "chip-size"),
		"--chip-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--chip-checked-padding": getSize(size$3, "chip-checked-padding"),
		"--chip-padding": getSize(size$3, "chip-padding"),
		"--chip-icon-size": getSize(size$3, "chip-icon-size"),
		"--chip-bg": color || variant ? colors.background : void 0,
		"--chip-hover": color || variant ? colors.hover : void 0,
		"--chip-color": color || variant ? colors.color : void 0,
		"--chip-bd": color || variant ? colors.border : void 0,
		"--chip-spacing": getSize(size$3, "chip-spacing")
	} };
});
const Chip = factory((_props, ref) => {
	const props = useProps("Chip", defaultProps$111, _props);
	const { classNames, className, style, styles, unstyled, vars, id, checked, defaultChecked, onChange, value, wrapperProps, type, disabled, children, size: size$3, variant, icon, rootRef, autoContrast, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Chip",
		classes: classes$50,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$50
	});
	const ctx = useChipGroupContext();
	const uuid = useId(id);
	const { styleProps, rest } = extractStyleProps(others);
	const [_value, setValue] = useUncontrolled({
		value: checked,
		defaultValue: defaultChecked,
		finalValue: false,
		onChange
	});
	const contextProps = ctx ? {
		checked: ctx.isChipSelected(value),
		onChange: (event) => {
			ctx.onChange(event);
			onChange?.(event.currentTarget.checked);
		},
		type: ctx.multiple ? "checkbox" : "radio"
	} : {};
	const _checked = contextProps.checked || _value;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		size: size$3,
		variant,
		ref: rootRef,
		mod,
		...getStyles$1("root"),
		...styleProps,
		...wrapperProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
			type,
			...getStyles$1("input"),
			checked: _checked,
			onChange: (event) => setValue(event.currentTarget.checked),
			id: uuid,
			disabled,
			ref,
			value,
			...contextProps,
			...rest
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("label", {
			htmlFor: uuid,
			"data-checked": _checked || void 0,
			"data-disabled": disabled || void 0,
			...getStyles$1("label", { variant: variant || "filled" }),
			children: [_checked && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("iconWrapper"),
				children: icon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, { ...getStyles$1("checkIcon") })
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children })]
		})]
	});
});
Chip.classes = classes$50;
Chip.displayName = "@mantine/core/Chip";
Chip.Group = ChipGroup;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Code/Code.module.css.mjs
var classes$49 = { "root": "m_b183c0a2" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Code/Code.mjs
const defaultProps$110 = {};
const varsResolver$49 = createVarsResolver((theme, { color }) => ({ root: { "--code-bg": color ? getThemeColor(color, theme) : void 0 } }));
const Code = factory((_props, ref) => {
	const props = useProps("Code", defaultProps$110, _props);
	const { classNames, className, style, styles, unstyled, vars, color, block, variant, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Code",
		props,
		classes: classes$49,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$49
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: block ? "pre" : "code",
		variant,
		ref,
		mod: [{ block }, mod],
		...getStyles$1("root"),
		...others,
		dir: "ltr"
	});
});
Code.classes = classes$49;
Code.displayName = "@mantine/core/Code";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorSwatch/ColorSwatch.module.css.mjs
var classes$48 = {
	"root": "m_de3d2490",
	"colorOverlay": "m_862f3d1b",
	"shadowOverlay": "m_98ae7f22",
	"alphaOverlay": "m_95709ac0",
	"childrenOverlay": "m_93e74e3"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorSwatch/ColorSwatch.mjs
const defaultProps$109 = { withShadow: true };
const varsResolver$48 = createVarsResolver((_, { radius, size: size$3 }) => ({ root: {
	"--cs-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--cs-size": rem(size$3)
} }));
const ColorSwatch = polymorphicFactory((_props, ref) => {
	const props = useProps("ColorSwatch", defaultProps$109, _props);
	const { classNames, className, style, styles, unstyled, vars, color, size: size$3, radius, withShadow, children, variant,...others } = useProps("ColorSwatch", defaultProps$109, props);
	const getStyles$1 = useStyles({
		name: "ColorSwatch",
		props,
		classes: classes$48,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$48
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref,
		variant,
		size: size$3,
		...getStyles$1("root", { focusable: true }),
		...others,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { ...getStyles$1("alphaOverlay") }),
			withShadow && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { ...getStyles$1("shadowOverlay") }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { ...getStyles$1("colorOverlay", { style: { backgroundColor: color } }) }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("childrenOverlay"),
				children
			})
		]
	});
});
ColorSwatch.classes = classes$48;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/ColorPicker.context.mjs
const [ColorPickerProvider, useColorPickerContext] = createOptionalContext(null);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/Thumb/Thumb.mjs
const Thumb$1 = (0, import_react.forwardRef)(({ position,...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
	ref,
	__vars: {
		"--thumb-y-offset": `${position.y * 100}%`,
		"--thumb-x-offset": `${position.x * 100}%`
	},
	...others
}));
Thumb$1.displayName = "@mantine/core/ColorPickerThumb";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/ColorPicker.module.css.mjs
var classes$47 = {
	"wrapper": "m_fee9c77",
	"preview": "m_9dddfbac",
	"body": "m_bffecc3e",
	"sliders": "m_3283bb96",
	"thumb": "m_40d572ba",
	"swatch": "m_d8ee6fd8",
	"swatches": "m_5711e686",
	"saturation": "m_202a296e",
	"saturationOverlay": "m_11b3db02",
	"slider": "m_d856d47d",
	"sliderOverlay": "m_8f327113"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/ColorSlider/ColorSlider.mjs
const defaultProps$108 = {};
const ColorSlider = factory((_props, ref) => {
	const props = useProps("ColorSlider", defaultProps$108, _props);
	const { classNames, className, style, styles, unstyled, vars, onChange, onChangeEnd, maxValue, round: round$2, size: size$3 = "md", focusable = true, value, overlays, thumbColor = "transparent", onScrubStart, onScrubEnd, __staticSelector = "ColorPicker",...others } = props;
	const _getStyles = useStyles({
		name: __staticSelector,
		classes: classes$47,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled
	});
	const ctxGetStyles = useColorPickerContext()?.getStyles;
	const getStyles$1 = ctxGetStyles || _getStyles;
	const theme = useMantineTheme();
	const [position, setPosition] = (0, import_react.useState)({
		y: 0,
		x: value / maxValue
	});
	const positionRef = (0, import_react.useRef)(position);
	const getChangeValue$1 = (val) => round$2 ? Math.round(val * maxValue) : val * maxValue;
	const { ref: sliderRef } = useMove(({ x, y }) => {
		positionRef.current = {
			x,
			y
		};
		onChange?.(getChangeValue$1(x));
	}, {
		onScrubEnd: () => {
			const { x } = positionRef.current;
			onChangeEnd?.(getChangeValue$1(x));
			onScrubEnd?.();
		},
		onScrubStart
	});
	useDidUpdate(() => {
		setPosition({
			y: 0,
			x: value / maxValue
		});
	}, [value]);
	const handleArrow = (event, pos) => {
		event.preventDefault();
		const _position = clampUseMovePosition(pos);
		onChange?.(getChangeValue$1(_position.x));
		onChangeEnd?.(getChangeValue$1(_position.x));
	};
	const handleKeyDown = (event) => {
		switch (event.key) {
			case "ArrowRight": {
				handleArrow(event, {
					x: position.x + .05,
					y: position.y
				});
				break;
			}
			case "ArrowLeft": {
				handleArrow(event, {
					x: position.x - .05,
					y: position.y
				});
				break;
			}
		}
	};
	const layers = overlays.map((overlay, index$4) => /* @__PURE__ */ (0, import_react.createElement)("div", {
		...getStyles$1("sliderOverlay"),
		style: overlay,
		key: index$4
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...others,
		ref: useMergedRef(sliderRef, ref),
		...getStyles$1("slider"),
		role: "slider",
		"aria-valuenow": value,
		"aria-valuemax": maxValue,
		"aria-valuemin": 0,
		tabIndex: focusable ? 0 : -1,
		onKeyDown: handleKeyDown,
		"data-focus-ring": theme.focusRing,
		__vars: { "--cp-thumb-size": `var(--cp-thumb-size-${size$3})` },
		children: [layers, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb$1, {
			position,
			...getStyles$1("thumb", { style: {
				top: rem(1),
				background: thumbColor
			} })
		})]
	});
});
ColorSlider.displayName = "@mantine/core/ColorSlider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/converters/parsers.mjs
function round(number, digits = 0, base = 10 ** digits) {
	return Math.round(base * number) / base;
}
function hslaToHsva({ h, s, l, a }) {
	const ss = s * ((l < 50 ? l : 100 - l) / 100);
	return {
		h,
		s: ss > 0 ? 2 * ss / (l + ss) * 100 : 0,
		v: l + ss,
		a
	};
}
const angleUnits = {
	grad: 360 / 400,
	turn: 360,
	rad: 360 / (Math.PI * 2)
};
function parseHue(value, unit = "deg") {
	return Number(value) * (angleUnits[unit] || 1);
}
const HSL_REGEXP = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
function parseHsla(color) {
	const match = HSL_REGEXP.exec(color);
	if (!match) return {
		h: 0,
		s: 0,
		v: 0,
		a: 1
	};
	return hslaToHsva({
		h: parseHue(match[1], match[2]),
		s: Number(match[3]),
		l: Number(match[4]),
		a: match[5] === void 0 ? 1 : Number(match[5]) / (match[6] ? 100 : 1)
	});
}
function rgbaToHsva({ r: r$1, g, b, a }) {
	const max$1 = Math.max(r$1, g, b);
	const delta = max$1 - Math.min(r$1, g, b);
	const hh = delta ? max$1 === r$1 ? (g - b) / delta : max$1 === g ? 2 + (b - r$1) / delta : 4 + (r$1 - g) / delta : 0;
	return {
		h: round(60 * (hh < 0 ? hh + 6 : hh), 3),
		s: round(max$1 ? delta / max$1 * 100 : 0, 3),
		v: round(max$1 / 255 * 100, 3),
		a
	};
}
function parseHex(color) {
	const hex = color[0] === "#" ? color.slice(1) : color;
	if (hex.length === 3) return rgbaToHsva({
		r: parseInt(hex[0] + hex[0], 16),
		g: parseInt(hex[1] + hex[1], 16),
		b: parseInt(hex[2] + hex[2], 16),
		a: 1
	});
	return rgbaToHsva({
		r: parseInt(hex.slice(0, 2), 16),
		g: parseInt(hex.slice(2, 4), 16),
		b: parseInt(hex.slice(4, 6), 16),
		a: 1
	});
}
function parseHexa(color) {
	const hex = color[0] === "#" ? color.slice(1) : color;
	const roundA = (a2) => round(parseInt(a2, 16) / 255, 3);
	if (hex.length === 4) {
		const withoutOpacity2 = hex.slice(0, 3);
		const a2 = roundA(hex[3] + hex[3]);
		const hsvaColor2 = {
			...parseHex(withoutOpacity2),
			a: a2
		};
		return hsvaColor2;
	}
	const withoutOpacity = hex.slice(0, 6);
	const a = roundA(hex.slice(6, 8));
	const hsvaColor = {
		...parseHex(withoutOpacity),
		a
	};
	return hsvaColor;
}
const RGB_REGEXP = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
function parseRgba(color) {
	const match = RGB_REGEXP.exec(color);
	if (!match) return {
		h: 0,
		s: 0,
		v: 0,
		a: 1
	};
	return rgbaToHsva({
		r: Number(match[1]) / (match[2] ? 100 / 255 : 1),
		g: Number(match[3]) / (match[4] ? 100 / 255 : 1),
		b: Number(match[5]) / (match[6] ? 100 / 255 : 1),
		a: match[7] === void 0 ? 1 : Number(match[7]) / (match[8] ? 100 : 1)
	});
}
const VALIDATION_REGEXP = {
	hex: /^#?([0-9A-F]{3}){1,2}$/i,
	hexa: /^#?([0-9A-F]{4}){1,2}$/i,
	rgb: /^rgb\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i,
	rgba: /^rgba\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i,
	hsl: /hsl\(\s*(\d+)\s*,\s*(\d+(?:\.\d+)?%)\s*,\s*(\d+(?:\.\d+)?%)\)/i,
	hsla: /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/i
};
const CONVERTERS$1 = {
	hex: parseHex,
	hexa: parseHexa,
	rgb: parseRgba,
	rgba: parseRgba,
	hsl: parseHsla,
	hsla: parseHsla
};
function isColorValid(color) {
	for (const [, regexp] of Object.entries(VALIDATION_REGEXP)) if (regexp.test(color)) return true;
	return false;
}
function parseColor(color) {
	if (typeof color !== "string") return {
		h: 0,
		s: 0,
		v: 0,
		a: 1
	};
	if (color === "transparent") return {
		h: 0,
		s: 0,
		v: 0,
		a: 0
	};
	const trimmed = color.trim();
	for (const [rule, regexp] of Object.entries(VALIDATION_REGEXP)) if (regexp.test(trimmed)) return CONVERTERS$1[rule](trimmed);
	return {
		h: 0,
		s: 0,
		v: 0,
		a: 1
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/AlphaSlider/AlphaSlider.mjs
const defaultProps$107 = {};
const AlphaSlider = (0, import_react.forwardRef)((props, ref) => {
	const { value, onChange, onChangeEnd, color,...others } = useProps("AlphaSlider", defaultProps$107, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorSlider, {
		...others,
		ref,
		value,
		onChange: (val) => onChange?.(round(val, 2)),
		onChangeEnd: (val) => onChangeEnd?.(round(val, 2)),
		maxValue: 1,
		round: false,
		"data-alpha": true,
		overlays: [
			{
				backgroundImage: "linear-gradient(45deg, var(--slider-checkers) 25%, transparent 25%), linear-gradient(-45deg, var(--slider-checkers) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--slider-checkers) 75%), linear-gradient(-45deg, var(--mantine-color-body) 75%, var(--slider-checkers) 75%)",
				backgroundSize: `${rem(8)} ${rem(8)}`,
				backgroundPosition: `0 0, 0 ${rem(4)}, ${rem(4)} ${rem(-4)}, ${rem(-4)} 0`
			},
			{ backgroundImage: `linear-gradient(90deg, transparent, ${color})` },
			{ boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${rem(1)} inset, rgb(0, 0, 0, .15) 0 0 ${rem(4)} inset` }
		]
	});
});
AlphaSlider.displayName = "@mantine/core/AlphaSlider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/converters/converters.mjs
function hsvaToRgbaObject({ h, s, v, a }) {
	const _h = h / 360 * 6;
	const _s = s / 100;
	const _v = v / 100;
	const hh = Math.floor(_h);
	const l = _v * (1 - _s);
	const c = _v * (1 - (_h - hh) * _s);
	const d = _v * (1 - (1 - _h + hh) * _s);
	const module = hh % 6;
	return {
		r: round([
			_v,
			c,
			l,
			l,
			d,
			_v
		][module] * 255),
		g: round([
			d,
			_v,
			_v,
			c,
			l,
			l
		][module] * 255),
		b: round([
			l,
			l,
			d,
			_v,
			_v,
			c
		][module] * 255),
		a: round(a, 2)
	};
}
function hsvaToRgba(color, includeAlpha) {
	const { r: r$1, g, b, a } = hsvaToRgbaObject(color);
	if (!includeAlpha) return `rgb(${r$1}, ${g}, ${b})`;
	return `rgba(${r$1}, ${g}, ${b}, ${round(a, 2)})`;
}
function hsvaToHsl({ h, s, v, a }, includeAlpha) {
	const hh = (200 - s) * v / 100;
	const result = {
		h: Math.round(h),
		s: Math.round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
		l: Math.round(hh / 2)
	};
	if (!includeAlpha) return `hsl(${result.h}, ${result.s}%, ${result.l}%)`;
	return `hsla(${result.h}, ${result.s}%, ${result.l}%, ${round(a, 2)})`;
}
function formatHexPart(number) {
	const hex = number.toString(16);
	return hex.length < 2 ? `0${hex}` : hex;
}
function hsvaToHex(color) {
	const { r: r$1, g, b } = hsvaToRgbaObject(color);
	return `#${formatHexPart(r$1)}${formatHexPart(g)}${formatHexPart(b)}`;
}
function hsvaToHexa(color) {
	const a = Math.round(color.a * 255);
	return `${hsvaToHex(color)}${formatHexPart(a)}`;
}
const CONVERTERS = {
	hex: hsvaToHex,
	hexa: (color) => hsvaToHexa(color),
	rgb: (color) => hsvaToRgba(color, false),
	rgba: (color) => hsvaToRgba(color, true),
	hsl: (color) => hsvaToHsl(color, false),
	hsla: (color) => hsvaToHsl(color, true)
};
function convertHsvaTo(format$1, color) {
	if (!color) return "#000000";
	if (!(format$1 in CONVERTERS)) return CONVERTERS.hex(color);
	return CONVERTERS[format$1](color);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/HueSlider/HueSlider.mjs
const HueSlider = (0, import_react.forwardRef)((props, ref) => {
	const { value, onChange, onChangeEnd, color,...others } = useProps("HueSlider", {}, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorSlider, {
		...others,
		ref,
		value,
		onChange,
		onChangeEnd,
		maxValue: 360,
		thumbColor: `hsl(${value}, 100%, 50%)`,
		round: true,
		"data-hue": true,
		overlays: [{ backgroundImage: "linear-gradient(to right,hsl(0,100%,50%),hsl(60,100%,50%),hsl(120,100%,50%),hsl(170,100%,50%),hsl(240,100%,50%),hsl(300,100%,50%),hsl(360,100%,50%))" }, { boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${rem(1)} inset, rgb(0, 0, 0, .15) 0 0 ${rem(4)} inset` }]
	});
});
HueSlider.displayName = "@mantine/core/HueSlider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/Saturation/Saturation.mjs
function Saturation({ className, onChange, onChangeEnd, value, saturationLabel, focusable = true, size: size$3, color, onScrubStart, onScrubEnd,...others }) {
	const { getStyles: getStyles$1 } = useColorPickerContext();
	const [position, setPosition] = (0, import_react.useState)({
		x: value.s / 100,
		y: 1 - value.v / 100
	});
	const positionRef = (0, import_react.useRef)(position);
	const { ref } = useMove(({ x, y }) => {
		positionRef.current = {
			x,
			y
		};
		onChange({
			s: Math.round(x * 100),
			v: Math.round((1 - y) * 100)
		});
	}, {
		onScrubEnd: () => {
			const { x, y } = positionRef.current;
			onChangeEnd({
				s: Math.round(x * 100),
				v: Math.round((1 - y) * 100)
			});
			onScrubEnd?.();
		},
		onScrubStart
	});
	(0, import_react.useEffect)(() => {
		setPosition({
			x: value.s / 100,
			y: 1 - value.v / 100
		});
	}, [value.s, value.v]);
	const handleArrow = (event, pos) => {
		event.preventDefault();
		const _position = clampUseMovePosition(pos);
		onChange({
			s: Math.round(_position.x * 100),
			v: Math.round((1 - _position.y) * 100)
		});
		onChangeEnd({
			s: Math.round(_position.x * 100),
			v: Math.round((1 - _position.y) * 100)
		});
	};
	const handleKeyDown = (event) => {
		switch (event.key) {
			case "ArrowUp": {
				handleArrow(event, {
					y: position.y - .05,
					x: position.x
				});
				break;
			}
			case "ArrowDown": {
				handleArrow(event, {
					y: position.y + .05,
					x: position.x
				});
				break;
			}
			case "ArrowRight": {
				handleArrow(event, {
					x: position.x + .05,
					y: position.y
				});
				break;
			}
			case "ArrowLeft": {
				handleArrow(event, {
					x: position.x - .05,
					y: position.y
				});
				break;
			}
		}
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("saturation"),
		ref,
		...others,
		role: "slider",
		"aria-label": saturationLabel,
		"aria-valuenow": position.x,
		"aria-valuetext": convertHsvaTo("rgba", value),
		tabIndex: focusable ? 0 : -1,
		onKeyDown: handleKeyDown,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ...getStyles$1("saturationOverlay", { style: { backgroundColor: `hsl(${value.h}, 100%, 50%)` } }) }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ...getStyles$1("saturationOverlay", { style: { backgroundImage: "linear-gradient(90deg, #fff, transparent)" } }) }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ...getStyles$1("saturationOverlay", { style: { backgroundImage: "linear-gradient(0deg, #000, transparent)" } }) }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb$1, {
				position,
				...getStyles$1("thumb", { style: { backgroundColor: color } })
			})
		]
	});
}
Saturation.displayName = "@mantine/core/Saturation";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/Swatches/Swatches.mjs
const Swatches = (0, import_react.forwardRef)(({ className, datatype, setValue, onChangeEnd, size: size$3, focusable, data, swatchesPerRow,...others }, ref) => {
	const ctx = useColorPickerContext();
	const colors = data.map((color, index$4) => /* @__PURE__ */ (0, import_react.createElement)(ColorSwatch, {
		...ctx.getStyles("swatch"),
		unstyled: ctx.unstyled,
		component: "button",
		type: "button",
		color,
		key: index$4,
		radius: "sm",
		onClick: () => {
			setValue(color);
			onChangeEnd?.(color);
		},
		"aria-label": color,
		tabIndex: focusable ? 0 : -1,
		"data-swatch": true
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...ctx.getStyles("swatches"),
		ref,
		...others,
		children: colors
	});
});
Swatches.displayName = "@mantine/core/Swatches";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorPicker/ColorPicker.mjs
const defaultProps$106 = {
	swatchesPerRow: 7,
	withPicker: true,
	focusable: true,
	size: "md",
	__staticSelector: "ColorPicker"
};
const varsResolver$47 = createVarsResolver((_, { size: size$3, swatchesPerRow }) => ({ wrapper: {
	"--cp-preview-size": getSize(size$3, "cp-preview-size"),
	"--cp-width": getSize(size$3, "cp-width"),
	"--cp-body-spacing": getSpacing(size$3),
	"--cp-swatch-size": `${100 / swatchesPerRow}%`,
	"--cp-thumb-size": getSize(size$3, "cp-thumb-size"),
	"--cp-saturation-height": getSize(size$3, "cp-saturation-height")
} }));
const ColorPicker = factory((_props, ref) => {
	const props = useProps("ColorPicker", defaultProps$106, _props);
	const { classNames, className, style, styles, unstyled, vars, format: format$1, value, defaultValue, onChange, onChangeEnd, withPicker, size: size$3, saturationLabel, hueLabel, alphaLabel, focusable, swatches, swatchesPerRow, fullWidth, onColorSwatchClick, __staticSelector, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: __staticSelector,
		props,
		classes: classes$47,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "wrapper",
		vars,
		varsResolver: varsResolver$47
	});
	const formatRef = (0, import_react.useRef)(format$1);
	const valueRef = (0, import_react.useRef)("");
	const scrubTimeoutRef = (0, import_react.useRef)(-1);
	const isScrubbingRef = (0, import_react.useRef)(false);
	const withAlpha = format$1 === "hexa" || format$1 === "rgba" || format$1 === "hsla";
	const [_value, setValue, controlled] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "#FFFFFF",
		onChange
	});
	const [parsed, setParsed] = (0, import_react.useState)(parseColor(_value));
	const startScrubbing = () => {
		window.clearTimeout(scrubTimeoutRef.current);
		isScrubbingRef.current = true;
	};
	const stopScrubbing = () => {
		window.clearTimeout(scrubTimeoutRef.current);
		scrubTimeoutRef.current = window.setTimeout(() => {
			isScrubbingRef.current = false;
		}, 200);
	};
	const handleChange = (color) => {
		setParsed((current) => {
			const next = {
				...current,
				...color
			};
			valueRef.current = convertHsvaTo(formatRef.current, next);
			return next;
		});
		setValue(valueRef.current);
	};
	useDidUpdate(() => {
		if (isColorValid(value) && !isScrubbingRef.current) setParsed(parseColor(value));
	}, [value]);
	useDidUpdate(() => {
		formatRef.current = format$1;
		setValue(convertHsvaTo(format$1, parsed));
	}, [format$1]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorPickerProvider, {
		value: {
			getStyles: getStyles$1,
			unstyled
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			ref,
			...getStyles$1("wrapper"),
			size: size$3,
			mod: [{ "full-width": fullWidth }, mod],
			...others,
			children: [withPicker && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Saturation, {
				value: parsed,
				onChange: handleChange,
				onChangeEnd: ({ s, v }) => onChangeEnd?.(convertHsvaTo(formatRef.current, {
					...parsed,
					s,
					v
				})),
				color: _value,
				size: size$3,
				focusable,
				saturationLabel,
				onScrubStart: startScrubbing,
				onScrubEnd: stopScrubbing
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				...getStyles$1("body"),
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					...getStyles$1("sliders"),
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(HueSlider, {
						value: parsed.h,
						onChange: (h) => handleChange({ h }),
						onChangeEnd: (h) => onChangeEnd?.(convertHsvaTo(formatRef.current, {
							...parsed,
							h
						})),
						size: size$3,
						focusable,
						"aria-label": hueLabel,
						onScrubStart: startScrubbing,
						onScrubEnd: stopScrubbing
					}), withAlpha && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AlphaSlider, {
						value: parsed.a,
						onChange: (a) => handleChange({ a }),
						onChangeEnd: (a) => {
							onChangeEnd?.(convertHsvaTo(formatRef.current, {
								...parsed,
								a
							}));
						},
						size: size$3,
						color: convertHsvaTo("hex", parsed),
						focusable,
						"aria-label": alphaLabel,
						onScrubStart: startScrubbing,
						onScrubEnd: stopScrubbing
					})]
				}), withAlpha && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorSwatch, {
					color: _value,
					radius: "sm",
					size: "var(--cp-preview-size)",
					...getStyles$1("preview")
				})]
			})] }), Array.isArray(swatches) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Swatches, {
				data: swatches,
				swatchesPerRow,
				focusable,
				setValue,
				onChangeEnd: (color) => {
					const convertedColor = convertHsvaTo(format$1, parseColor(color));
					onColorSwatchClick?.(convertedColor);
					onChangeEnd?.(convertedColor);
					if (!controlled) setParsed(parseColor(color));
				}
			})]
		})
	});
});
ColorPicker.classes = classes$47;
ColorPicker.displayName = "@mantine/core/ColorPicker";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorInput/EyeDropperIcon.mjs
function EyeDropperIcon({ style,...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		style: {
			width: "var(--ci-eye-dropper-icon-size)",
			height: "var(--ci-eye-dropper-icon-size)",
			...style
		},
		viewBox: "0 0 24 24",
		strokeWidth: "1.5",
		stroke: "currentColor",
		fill: "none",
		strokeLinecap: "round",
		strokeLinejoin: "round",
		...others,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
				stroke: "none",
				d: "M0 0h24v24H0z",
				fill: "none"
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 3l0 4" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 21l0 -3" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M3 12l4 0" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M21 12l-3 0" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 12l0 .01" })
		]
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorInput/ColorInput.module.css.mjs
var classes$46 = {
	"eyeDropperIcon": "m_b077c2bc",
	"colorPreview": "m_c5ccdcab",
	"dropdown": "m_5ece2cd7"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ColorInput/ColorInput.mjs
const defaultProps$105 = {
	format: "hex",
	fixOnBlur: true,
	withPreview: true,
	swatchesPerRow: 7,
	withPicker: true,
	popoverProps: { transitionProps: {
		transition: "fade",
		duration: 0
	} },
	withEyeDropper: true
};
const varsResolver$46 = createVarsResolver((_, { size: size$3 }) => ({
	eyeDropperIcon: { "--ci-eye-dropper-icon-size": getSize(size$3, "ci-eye-dropper-icon-size") },
	colorPreview: { "--ci-preview-size": getSize(size$3, "ci-preview-size") }
}));
const ColorInput = factory((_props, ref) => {
	const props = useProps("ColorInput", defaultProps$105, _props);
	const { classNames, styles, unstyled, disallowInput, fixOnBlur, popoverProps, withPreview, withEyeDropper, eyeDropperIcon, closeOnColorSwatchClick, eyeDropperButtonProps, value, defaultValue, onChange, onChangeEnd, onClick, onFocus, onBlur, inputProps, format: format$1, wrapperProps, readOnly, withPicker, swatches, disabled, leftSection, rightSection, swatchesPerRow,...others } = useInputProps("ColorInput", defaultProps$105, _props);
	const getStyles$1 = useStyles({
		name: "ColorInput",
		props,
		classes: classes$46,
		classNames,
		styles,
		unstyled,
		rootSelector: "wrapper",
		vars: props.vars,
		varsResolver: varsResolver$46
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [dropdownOpened, setDropdownOpened] = (0, import_react.useState)(false);
	const [lastValidValue, setLastValidValue] = (0, import_react.useState)("");
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const { supported: eyeDropperSupported, open: openEyeDropper } = useEyeDropper();
	const eyeDropper = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionIcon, {
		...eyeDropperButtonProps,
		...getStyles$1("eyeDropperButton", {
			className: eyeDropperButtonProps?.className,
			style: eyeDropperButtonProps?.style
		}),
		variant: "subtle",
		color: "gray",
		size: inputProps.size,
		unstyled,
		onClick: () => openEyeDropper().then((payload) => {
			if (payload?.sRGBHex) {
				const color = convertHsvaTo(format$1, parseColor(payload.sRGBHex));
				setValue(color);
				onChangeEnd?.(color);
			}
		}).catch(() => {}),
		children: eyeDropperIcon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(EyeDropperIcon, { ...getStyles$1("eyeDropperIcon") })
	});
	const handleInputFocus = (event) => {
		onFocus?.(event);
		setDropdownOpened(true);
	};
	const handleInputBlur = (event) => {
		fixOnBlur && setValue(lastValidValue);
		onBlur?.(event);
		setDropdownOpened(false);
	};
	const handleInputClick = (event) => {
		onClick?.(event);
		setDropdownOpened(true);
	};
	(0, import_react.useEffect)(() => {
		if (isColorValid(_value) || _value.trim() === "") setLastValidValue(_value);
	}, [_value]);
	useDidUpdate(() => {
		if (isColorValid(_value)) setValue(convertHsvaTo(format$1, parseColor(_value)));
	}, [format$1]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
		...wrapperProps,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		__staticSelector: "ColorInput",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Popover, {
			__staticSelector: "ColorInput",
			position: "bottom-start",
			offset: 5,
			opened: dropdownOpened,
			...popoverProps,
			classNames: resolvedClassNames,
			styles: resolvedStyles,
			unstyled,
			withRoles: false,
			disabled: readOnly || withPicker === false && (!Array.isArray(swatches) || swatches.length === 0),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
				autoComplete: "off",
				...others,
				...inputProps,
				classNames: resolvedClassNames,
				styles: resolvedStyles,
				disabled,
				ref,
				__staticSelector: "ColorInput",
				onFocus: handleInputFocus,
				onBlur: handleInputBlur,
				onClick: handleInputClick,
				spellCheck: false,
				value: _value,
				onChange: (event) => {
					const inputValue = event.currentTarget.value;
					setValue(inputValue);
					if (isColorValid(inputValue)) onChangeEnd?.(convertHsvaTo(format$1, parseColor(inputValue)));
				},
				leftSection: leftSection || (withPreview ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorSwatch, {
					color: isColorValid(_value) ? _value : "#fff",
					size: "var(--ci-preview-size)",
					...getStyles$1("colorPreview")
				}) : null),
				readOnly: disallowInput || readOnly,
				pointer: disallowInput,
				unstyled,
				rightSection: rightSection || (withEyeDropper && !disabled && !readOnly && eyeDropperSupported ? eyeDropper : null)
			}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Dropdown, {
				onMouseDown: (event) => event.preventDefault(),
				className: classes$46.dropdown,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorPicker, {
					__staticSelector: "ColorInput",
					value: _value,
					onChange: setValue,
					onChangeEnd,
					format: format$1,
					swatches,
					swatchesPerRow,
					withPicker,
					size: inputProps.size,
					focusable: false,
					unstyled,
					styles: resolvedStyles,
					classNames: resolvedClassNames,
					onColorSwatchClick: () => closeOnColorSwatchClick && setDropdownOpened(false)
				})
			})]
		})
	});
});
ColorInput.classes = InputBase.classes;
ColorInput.displayName = "@mantine/core/ColorInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/use-combobox/get-index/get-virtualized-index.mjs
function getPreviousIndex({ currentIndex, isOptionDisabled, totalOptionsCount, loop }) {
	for (let i = currentIndex - 1; i >= 0; i -= 1) if (!isOptionDisabled(i)) return i;
	if (loop) {
		for (let i = totalOptionsCount - 1; i > -1; i -= 1) if (!isOptionDisabled(i)) return i;
	}
	return currentIndex;
}
function getNextIndex({ currentIndex, isOptionDisabled, totalOptionsCount, loop }) {
	for (let i = currentIndex + 1; i < totalOptionsCount; i += 1) if (!isOptionDisabled(i)) return i;
	if (loop) {
		for (let i = 0; i < totalOptionsCount; i += 1) if (!isOptionDisabled(i)) return i;
	}
	return currentIndex;
}
function getFirstIndex({ totalOptionsCount, isOptionDisabled }) {
	for (let i = 0; i < totalOptionsCount; i += 1) if (!isOptionDisabled(i)) return i;
	return -1;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Combobox/use-combobox/use-virtualized-combobox.mjs
function useVirtualizedCombobox({ defaultOpened, opened, onOpenedChange, onDropdownClose, onDropdownOpen, loop = true, totalOptionsCount, isOptionDisabled = () => false, getOptionId, selectedOptionIndex, setSelectedOptionIndex, activeOptionIndex, onSelectedOptionSubmit } = {
	totalOptionsCount: 0,
	getOptionId: () => null,
	selectedOptionIndex: 1,
	setSelectedOptionIndex: () => {},
	onSelectedOptionSubmit: () => {}
}) {
	const [dropdownOpened, setDropdownOpened] = useUncontrolled({
		value: opened,
		defaultValue: defaultOpened,
		finalValue: false,
		onChange: onOpenedChange
	});
	const listId = (0, import_react.useRef)(null);
	const searchRef = (0, import_react.useRef)(null);
	const targetRef = (0, import_react.useRef)(null);
	const focusSearchTimeout = (0, import_react.useRef)(-1);
	const focusTargetTimeout = (0, import_react.useRef)(-1);
	const openDropdown = () => {
		if (!dropdownOpened) {
			setDropdownOpened(true);
			onDropdownOpen?.();
		}
	};
	const closeDropdown = () => {
		if (dropdownOpened) {
			setDropdownOpened(false);
			onDropdownClose?.();
		}
	};
	const toggleDropdown = () => {
		if (dropdownOpened) closeDropdown();
		else openDropdown();
	};
	const selectOption = (index$4) => {
		const nextIndex = index$4 >= totalOptionsCount ? 0 : index$4 < 0 ? totalOptionsCount - 1 : index$4;
		setSelectedOptionIndex(nextIndex);
		return getOptionId(nextIndex);
	};
	const selectActiveOption = () => selectOption(activeOptionIndex ?? 0);
	const selectNextOption = () => selectOption(getNextIndex({
		currentIndex: selectedOptionIndex,
		isOptionDisabled,
		totalOptionsCount,
		loop
	}));
	const selectPreviousOption = () => selectOption(getPreviousIndex({
		currentIndex: selectedOptionIndex,
		isOptionDisabled,
		totalOptionsCount,
		loop
	}));
	const selectFirstOption = () => selectOption(getFirstIndex({
		isOptionDisabled,
		totalOptionsCount
	}));
	const resetSelectedOption = () => {
		setSelectedOptionIndex(-1);
	};
	const clickSelectedOption = () => {
		onSelectedOptionSubmit?.(selectedOptionIndex);
	};
	const setListId = (id) => {
		listId.current = id;
	};
	const focusSearchInput = () => {
		focusSearchTimeout.current = window.setTimeout(() => searchRef.current.focus(), 0);
	};
	const focusTarget = () => {
		focusTargetTimeout.current = window.setTimeout(() => targetRef.current.focus(), 0);
	};
	(0, import_react.useEffect)(() => () => {
		window.clearTimeout(focusSearchTimeout.current);
		window.clearTimeout(focusTargetTimeout.current);
	}, []);
	const getSelectedOptionIndex = (0, import_react.useCallback)(() => selectedOptionIndex, []);
	return {
		dropdownOpened,
		openDropdown,
		closeDropdown,
		toggleDropdown,
		selectedOptionIndex,
		getSelectedOptionIndex,
		selectOption,
		selectFirstOption,
		selectActiveOption,
		selectNextOption,
		selectPreviousOption,
		resetSelectedOption,
		updateSelectedOptionIndex: () => {},
		listId: listId.current,
		setListId,
		clickSelectedOption,
		searchRef,
		focusSearchInput,
		targetRef,
		focusTarget
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Container/Container.module.css.mjs
var classes$45 = { "root": "m_7485cace" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Container/Container.mjs
const defaultProps$104 = {};
const varsResolver$45 = createVarsResolver((_, { size: size$3, fluid }) => ({ root: { "--container-size": fluid ? void 0 : getSize(size$3, "container-size") } }));
const Container = factory((_props, ref) => {
	const props = useProps("Container", defaultProps$104, _props);
	const { classNames, className, style, styles, unstyled, vars, fluid, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Container",
		classes: classes$45,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$45
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{ fluid }, mod],
		...getStyles$1("root"),
		...others
	});
});
Container.classes = classes$45;
Container.displayName = "@mantine/core/Container";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/CopyButton/CopyButton.mjs
const defaultProps$103 = { timeout: 1e3 };
function CopyButton(props) {
	const { children, timeout, value,...others } = useProps("CopyButton", defaultProps$103, props);
	const clipboard = useClipboard({ timeout });
	const copy = () => clipboard.copy(value);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children({
		copy,
		copied: clipboard.copied,
		...others
	}) });
}
CopyButton.displayName = "@mantine/core/CopyButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Dialog/Dialog.module.css.mjs
var classes$44 = {
	"root": "m_e2125a27",
	"closeButton": "m_5abab665"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Dialog/Dialog.mjs
const defaultProps$102 = {
	shadow: "md",
	p: "md",
	withBorder: false,
	transitionProps: {
		transition: "pop-top-right",
		duration: 200
	},
	position: {
		bottom: 30,
		right: 30
	}
};
const varsResolver$44 = createVarsResolver((_, { size: size$3 }) => ({ root: { "--dialog-size": getSize(size$3, "dialog-size") } }));
const Dialog = factory((_props, ref) => {
	const props = useProps("Dialog", defaultProps$102, _props);
	const { classNames, className, style, styles, unstyled, vars, zIndex, position, keepMounted, opened, transitionProps, withCloseButton, withinPortal, children, onClose, portalProps,...others } = props;
	const getStyles$1 = useStyles({
		name: "Dialog",
		classes: classes$44,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$44
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Affix, {
		zIndex,
		position,
		ref,
		withinPortal,
		portalProps,
		unstyled,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			keepMounted,
			mounted: opened,
			...transitionProps,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Paper, {
				unstyled,
				...getStyles$1("root", { style: transitionStyles }),
				...others,
				children: [withCloseButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
					onClick: onClose,
					unstyled,
					...getStyles$1("closeButton")
				}), children]
			})
		})
	});
});
Dialog.classes = classes$44;
Dialog.displayName = "@mantine/core/Dialog";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Divider/Divider.module.css.mjs
var classes$43 = {
	"root": "m_3eebeb36",
	"label": "m_9e365f20"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Divider/Divider.mjs
const defaultProps$101 = { orientation: "horizontal" };
const varsResolver$43 = createVarsResolver((theme, { color, variant, size: size$3 }) => ({ root: {
	"--divider-color": color ? getThemeColor(color, theme) : void 0,
	"--divider-border-style": variant,
	"--divider-size": getSize(size$3, "divider-size")
} }));
const Divider = factory((_props, ref) => {
	const props = useProps("Divider", defaultProps$101, _props);
	const { classNames, className, style, styles, unstyled, vars, color, orientation, label, labelPosition, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Divider",
		classes: classes$43,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$43
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		mod: [{
			orientation,
			"with-label": !!label
		}, mod],
		...getStyles$1("root"),
		...others,
		role: "separator",
		children: label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			component: "span",
			mod: { position: labelPosition },
			...getStyles$1("label"),
			children: label
		})
	});
});
Divider.classes = classes$43;
Divider.displayName = "@mantine/core/Divider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/Drawer.context.mjs
const [DrawerProvider, useDrawerContext] = createSafeContext("Drawer component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/Drawer.module.css.mjs
var classes$42 = {
	"root": "m_f11b401e",
	"header": "m_5a7c2c9",
	"content": "m_b8a05bbd",
	"inner": "m_31cd769a"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerBody.mjs
const defaultProps$100 = {};
const DrawerBody = factory((_props, ref) => {
	const props = useProps("DrawerBody", defaultProps$100, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useDrawerContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseBody, {
		ref,
		...ctx.getStyles("body", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
DrawerBody.classes = classes$42;
DrawerBody.displayName = "@mantine/core/DrawerBody";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerCloseButton.mjs
const defaultProps$99 = {};
const DrawerCloseButton = factory((_props, ref) => {
	const props = useProps("DrawerCloseButton", defaultProps$99, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useDrawerContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseCloseButton, {
		ref,
		...ctx.getStyles("close", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
DrawerCloseButton.classes = classes$42;
DrawerCloseButton.displayName = "@mantine/core/DrawerCloseButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerContent.mjs
const defaultProps$98 = {};
const DrawerContent = factory((_props, ref) => {
	const props = useProps("DrawerContent", defaultProps$98, _props);
	const { classNames, className, style, styles, vars, children, radius, __hidden,...others } = props;
	const ctx = useDrawerContext();
	const Scroll = ctx.scrollAreaComponent || NativeScrollArea;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseContent, {
		...ctx.getStyles("content", {
			className,
			style,
			styles,
			classNames
		}),
		innerProps: ctx.getStyles("inner", {
			className,
			style,
			styles,
			classNames
		}),
		ref,
		...others,
		radius: radius || ctx.radius || 0,
		"data-hidden": __hidden || void 0,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scroll, {
			style: { height: "calc(100vh - var(--drawer-offset) * 2)" },
			children
		})
	});
});
DrawerContent.classes = classes$42;
DrawerContent.displayName = "@mantine/core/DrawerContent";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerHeader.mjs
const defaultProps$97 = {};
const DrawerHeader = factory((_props, ref) => {
	const props = useProps("DrawerHeader", defaultProps$97, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useDrawerContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseHeader, {
		ref,
		...ctx.getStyles("header", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
DrawerHeader.classes = classes$42;
DrawerHeader.displayName = "@mantine/core/DrawerHeader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerOverlay.mjs
const defaultProps$96 = {};
const DrawerOverlay = factory((_props, ref) => {
	const props = useProps("DrawerOverlay", defaultProps$96, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useDrawerContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseOverlay, {
		ref,
		...ctx.getStyles("overlay", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
DrawerOverlay.classes = classes$42;
DrawerOverlay.displayName = "@mantine/core/DrawerOverlay";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerRoot.mjs
function getDrawerAlign(position) {
	switch (position) {
		case "top": return "flex-start";
		case "bottom": return "flex-end";
		default: return void 0;
	}
}
function getDrawerFlex(position) {
	if (position === "top" || position === "bottom") return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
	return void 0;
}
const transitions = {
	top: "slide-down",
	bottom: "slide-up",
	left: "slide-right",
	right: "slide-left"
};
const rtlTransitions = {
	top: "slide-down",
	bottom: "slide-up",
	right: "slide-right",
	left: "slide-left"
};
const defaultProps$95 = {
	closeOnClickOutside: true,
	withinPortal: true,
	lockScroll: true,
	trapFocus: true,
	returnFocus: true,
	closeOnEscape: true,
	keepMounted: false,
	zIndex: getDefaultZIndex("modal"),
	position: "left"
};
const varsResolver$42 = createVarsResolver((_, { position, size: size$3, offset: offset$3 }) => ({ root: {
	"--drawer-size": getSize(size$3, "drawer-size"),
	"--drawer-flex": getDrawerFlex(position),
	"--drawer-height": position === "left" || position === "right" ? void 0 : "var(--drawer-size)",
	"--drawer-align": getDrawerAlign(position),
	"--drawer-justify": position === "right" ? "flex-end" : void 0,
	"--drawer-offset": rem(offset$3)
} }));
const DrawerRoot = factory((_props, ref) => {
	const props = useProps("DrawerRoot", defaultProps$95, _props);
	const { classNames, className, style, styles, unstyled, vars, scrollAreaComponent, position, transitionProps, radius,...others } = props;
	const { dir } = useDirection();
	const getStyles$1 = useStyles({
		name: "Drawer",
		classes: classes$42,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$42
	});
	const drawerTransition = (dir === "rtl" ? rtlTransitions : transitions)[position];
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerProvider, {
		value: {
			scrollAreaComponent,
			getStyles: getStyles$1,
			radius
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBase, {
			ref,
			...getStyles$1("root"),
			transitionProps: {
				transition: drawerTransition,
				...transitionProps
			},
			"data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || void 0,
			unstyled,
			...others
		})
	});
});
DrawerRoot.classes = classes$42;
DrawerRoot.displayName = "@mantine/core/DrawerRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerStack.mjs
const [DrawerStackProvider, useDrawerStackContext] = createOptionalContext();
function DrawerStack({ children }) {
	const [stack, setStack] = (0, import_react.useState)([]);
	const [maxZIndex, setMaxZIndex] = (0, import_react.useState)(getDefaultZIndex("modal"));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerStackProvider, {
		value: {
			stack,
			addModal: (id, zIndex) => {
				setStack((current) => [.../* @__PURE__ */ new Set([...current, id])]);
				setMaxZIndex((current) => typeof zIndex === "number" && typeof current === "number" ? Math.max(current, zIndex) : current);
			},
			removeModal: (id) => setStack((current) => current.filter((currentId) => currentId !== id)),
			getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
			currentId: stack[stack.length - 1],
			maxZIndex
		},
		children
	});
}
DrawerStack.displayName = "@mantine/core/DrawerStack";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/DrawerTitle.mjs
const defaultProps$94 = {};
const DrawerTitle = factory((_props, ref) => {
	const props = useProps("DrawerTitle", defaultProps$94, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useDrawerContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseTitle, {
		ref,
		...ctx.getStyles("title", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
DrawerTitle.classes = classes$42;
DrawerTitle.displayName = "@mantine/core/DrawerTitle";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Drawer/Drawer.mjs
const defaultProps$93 = {
	closeOnClickOutside: true,
	withinPortal: true,
	lockScroll: true,
	trapFocus: true,
	returnFocus: true,
	closeOnEscape: true,
	keepMounted: false,
	zIndex: getDefaultZIndex("modal"),
	withOverlay: true,
	withCloseButton: true
};
const Drawer = factory((_props, ref) => {
	const { title, withOverlay, overlayProps, withCloseButton, closeButtonProps, children, opened, stackId, zIndex,...others } = useProps("Drawer", defaultProps$93, _props);
	const ctx = useDrawerStackContext();
	const hasHeader = !!title || withCloseButton;
	const stackProps = ctx && stackId ? {
		closeOnEscape: ctx.currentId === stackId,
		trapFocus: ctx.currentId === stackId,
		zIndex: ctx.getZIndex(stackId)
	} : {};
	const overlayVisible = withOverlay === false ? false : stackId && ctx ? ctx.currentId === stackId : opened;
	(0, import_react.useEffect)(() => {
		if (ctx && stackId) opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId);
	}, [
		opened,
		stackId,
		zIndex
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DrawerRoot, {
		ref,
		opened,
		zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
		...others,
		...stackProps,
		children: [withOverlay && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerOverlay, {
			visible: overlayVisible,
			transitionProps: ctx && stackId ? { duration: 0 } : void 0,
			...overlayProps
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DrawerContent, {
			__hidden: ctx && stackId && opened ? stackId !== ctx.currentId : false,
			children: [hasHeader && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DrawerHeader, { children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerTitle, { children: title }), withCloseButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerCloseButton, { ...closeButtonProps })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DrawerBody, { children })]
		})]
	});
});
Drawer.classes = classes$42;
Drawer.displayName = "@mantine/core/Drawer";
Drawer.Root = DrawerRoot;
Drawer.Overlay = DrawerOverlay;
Drawer.Content = DrawerContent;
Drawer.Body = DrawerBody;
Drawer.Header = DrawerHeader;
Drawer.Title = DrawerTitle;
Drawer.CloseButton = DrawerCloseButton;
Drawer.Stack = DrawerStack;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Fieldset/Fieldset.module.css.mjs
var classes$41 = {
	"root": "m_e9408a47",
	"root--default": "m_84c9523a",
	"root--filled": "m_ef274e49",
	"root--unstyled": "m_eda993d3",
	"legend": "m_90794832",
	"legend--unstyled": "m_74ca27fe"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Fieldset/Fieldset.mjs
const defaultProps$92 = { variant: "default" };
const varsResolver$41 = createVarsResolver((_, { radius }) => ({ root: { "--fieldset-radius": radius === void 0 ? void 0 : getRadius(radius) } }));
const Fieldset = factory((_props, ref) => {
	const props = useProps("Fieldset", defaultProps$92, _props);
	const { classNames, className, style, styles, unstyled, vars, legend, variant, children,...others } = props;
	const getStyles$1 = useStyles({
		name: "Fieldset",
		classes: classes$41,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$41
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		component: "fieldset",
		ref,
		variant,
		...getStyles$1("root", { variant }),
		...others,
		children: [legend && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("legend", {
			...getStyles$1("legend", { variant }),
			children: legend
		}), children]
	});
});
Fieldset.classes = classes$41;
Fieldset.displayName = "@mantine/core/Fieldset";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FileButton/FileButton.mjs
const defaultProps$91 = { multiple: false };
const FileButton = (0, import_react.forwardRef)((props, ref) => {
	const { onChange, children, multiple, accept, name, form, resetRef, disabled, capture, inputProps,...others } = useProps("FileButton", defaultProps$91, props);
	const inputRef = (0, import_react.useRef)(null);
	const onClick = () => {
		!disabled && inputRef.current?.click();
	};
	const handleChange = (event) => {
		if (multiple) onChange(Array.from(event.currentTarget.files));
		else onChange(event.currentTarget.files[0] || null);
	};
	const reset = () => {
		if (inputRef.current) inputRef.current.value = "";
	};
	assignRef(resetRef, reset);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		style: { display: "none" },
		type: "file",
		accept,
		multiple,
		onChange: handleChange,
		ref: useMergedRef(ref, inputRef),
		name,
		form,
		capture,
		...inputProps
	}), children({
		onClick,
		...others
	})] });
});
FileButton.displayName = "@mantine/core/FileButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/FileInput/FileInput.mjs
const DefaultValue = ({ value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
	style: {
		overflow: "hidden",
		textOverflow: "ellipsis",
		whiteSpace: "nowrap"
	},
	children: Array.isArray(value) ? value.map((file) => file.name).join(", ") : value?.name
});
const defaultProps$90 = { valueComponent: DefaultValue };
const _FileInput = factory((_props, ref) => {
	const props = useProps("FileInput", defaultProps$90, _props);
	const { unstyled, vars, onChange, value, defaultValue, multiple, accept, name, form, valueComponent, clearable, clearButtonProps, readOnly, capture, fileInputProps, rightSection, size: size$3, placeholder, component, resetRef: resetRefProp, classNames, styles,...others } = props;
	const resetRef = (0, import_react.useRef)(null);
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		onChange,
		finalValue: multiple ? [] : null
	});
	const hasValue = Array.isArray(_value) ? _value.length !== 0 : _value !== null;
	const _rightSection = rightSection || (clearable && hasValue && !readOnly ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
		...clearButtonProps,
		variant: "subtle",
		onClick: () => setValue(multiple ? [] : null),
		size: size$3,
		unstyled
	}) : null);
	(0, import_react.useEffect)(() => {
		if (Array.isArray(_value) && _value.length === 0 || _value === null) resetRef.current?.();
	}, [_value]);
	const ValueComponent = valueComponent;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FileButton, {
		onChange: setValue,
		multiple,
		accept,
		name,
		form,
		resetRef: useMergedRef(resetRef, resetRefProp),
		disabled: readOnly,
		capture,
		inputProps: fileInputProps,
		children: (fileButtonProps) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
			component: component || "button",
			ref,
			rightSection: _rightSection,
			...fileButtonProps,
			...others,
			__staticSelector: "FileInput",
			multiline: true,
			type: "button",
			pointer: true,
			__stylesApiProps: props,
			unstyled,
			size: size$3,
			classNames,
			styles,
			children: !hasValue ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Placeholder, {
				__staticSelector: "FileInput",
				classNames: resolvedClassNames,
				styles: resolvedStyles,
				children: placeholder
			}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ValueComponent, { value: _value })
		})
	});
});
_FileInput.classes = InputBase.classes;
_FileInput.displayName = "@mantine/core/FileInput";
const FileInput = _FileInput;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Floating/use-delayed-hover.mjs
function useDelayedHover({ open, close, openDelay, closeDelay }) {
	const openTimeout = (0, import_react.useRef)(-1);
	const closeTimeout = (0, import_react.useRef)(-1);
	const clearTimeouts = () => {
		window.clearTimeout(openTimeout.current);
		window.clearTimeout(closeTimeout.current);
	};
	const openDropdown = () => {
		clearTimeouts();
		if (openDelay === 0 || openDelay === void 0) open();
		else openTimeout.current = window.setTimeout(open, openDelay);
	};
	const closeDropdown = () => {
		clearTimeouts();
		if (closeDelay === 0 || closeDelay === void 0) close();
		else closeTimeout.current = window.setTimeout(close, closeDelay);
	};
	(0, import_react.useEffect)(() => clearTimeouts, []);
	return {
		openDropdown,
		closeDropdown
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/Grid.context.mjs
const [GridProvider, useGridContext] = createSafeContext("Grid component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/GridCol/GridColVariables.mjs
const getColumnFlexBasis = (colSpan, columns) => {
	if (colSpan === "content") return "auto";
	if (colSpan === "auto") return "0rem";
	return colSpan ? `${100 / (columns / colSpan)}%` : void 0;
};
const getColumnMaxWidth = (colSpan, columns, grow) => {
	if (grow || colSpan === "auto") return "100%";
	if (colSpan === "content") return "unset";
	return getColumnFlexBasis(colSpan, columns);
};
const getColumnFlexGrow = (colSpan, grow) => {
	if (!colSpan) return void 0;
	return colSpan === "auto" || grow ? "1" : "auto";
};
const getColumnOffset = (offset$3, columns) => offset$3 === 0 ? "0" : offset$3 ? `${100 / (columns / offset$3)}%` : void 0;
function GridColVariables({ span, order, offset: offset$3, selector }) {
	const theme = useMantineTheme();
	const ctx = useGridContext();
	const _breakpoints = ctx.breakpoints || theme.breakpoints;
	const baseValue = getBaseValue(span);
	const baseSpan = baseValue === void 0 ? 12 : getBaseValue(span);
	const baseStyles = filterProps({
		"--col-order": getBaseValue(order)?.toString(),
		"--col-flex-grow": getColumnFlexGrow(baseSpan, ctx.grow),
		"--col-flex-basis": getColumnFlexBasis(baseSpan, ctx.columns),
		"--col-width": baseSpan === "content" ? "auto" : void 0,
		"--col-max-width": getColumnMaxWidth(baseSpan, ctx.columns, ctx.grow),
		"--col-offset": getColumnOffset(getBaseValue(offset$3), ctx.columns)
	});
	const queries = keys(_breakpoints).reduce((acc, breakpoint) => {
		if (!acc[breakpoint]) acc[breakpoint] = {};
		if (typeof order === "object" && order[breakpoint] !== void 0) acc[breakpoint]["--col-order"] = order[breakpoint]?.toString();
		if (typeof span === "object" && span[breakpoint] !== void 0) {
			acc[breakpoint]["--col-flex-grow"] = getColumnFlexGrow(span[breakpoint], ctx.grow);
			acc[breakpoint]["--col-flex-basis"] = getColumnFlexBasis(span[breakpoint], ctx.columns);
			acc[breakpoint]["--col-width"] = span[breakpoint] === "content" ? "auto" : void 0;
			acc[breakpoint]["--col-max-width"] = getColumnMaxWidth(span[breakpoint], ctx.columns, ctx.grow);
		}
		if (typeof offset$3 === "object" && offset$3[breakpoint] !== void 0) acc[breakpoint]["--col-offset"] = getColumnOffset(offset$3[breakpoint], ctx.columns);
		return acc;
	}, {});
	const sortedBreakpoints = getSortedBreakpoints(keys(queries), _breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
	const values$1 = sortedBreakpoints.map((breakpoint) => ({
		query: ctx.type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
		styles: queries[breakpoint.value]
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		styles: baseStyles,
		media: ctx.type === "container" ? void 0 : values$1,
		container: ctx.type === "container" ? values$1 : void 0,
		selector
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/Grid.module.css.mjs
var classes$40 = {
	"container": "m_8478a6da",
	"root": "m_410352e9",
	"inner": "m_dee7bd2f",
	"col": "m_96bdd299"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/GridCol/GridCol.mjs
const defaultProps$89 = { span: 12 };
const GridCol = factory((_props, ref) => {
	const props = useProps("GridCol", defaultProps$89, _props);
	const { classNames, className, style, styles, vars, span, order, offset: offset$3,...others } = props;
	const ctx = useGridContext();
	const responsiveClassName = useRandomClassName();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(GridColVariables, {
		selector: `.${responsiveClassName}`,
		span,
		order,
		offset: offset$3
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("col", {
			className: clsx_default(className, responsiveClassName),
			style,
			classNames,
			styles
		}),
		...others
	})] });
});
GridCol.classes = classes$40;
GridCol.displayName = "@mantine/core/GridCol";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/GridVariables.mjs
function GridVariables({ gutter, selector, breakpoints, type }) {
	const theme = useMantineTheme();
	const _breakpoints = breakpoints || theme.breakpoints;
	const baseStyles = filterProps({ "--grid-gutter": getSpacing(getBaseValue(gutter)) });
	const queries = keys(_breakpoints).reduce((acc, breakpoint) => {
		if (!acc[breakpoint]) acc[breakpoint] = {};
		if (typeof gutter === "object" && gutter[breakpoint] !== void 0) acc[breakpoint]["--grid-gutter"] = getSpacing(gutter[breakpoint]);
		return acc;
	}, {});
	const sortedBreakpoints = getSortedBreakpoints(keys(queries), _breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
	const values$1 = sortedBreakpoints.map((breakpoint) => ({
		query: type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
		styles: queries[breakpoint.value]
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		styles: baseStyles,
		media: type === "container" ? void 0 : values$1,
		container: type === "container" ? values$1 : void 0,
		selector
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Grid/Grid.mjs
const defaultProps$88 = {
	gutter: "md",
	grow: false,
	columns: 12
};
const varsResolver$40 = createVarsResolver((_, { justify, align, overflow }) => ({ root: {
	"--grid-justify": justify,
	"--grid-align": align,
	"--grid-overflow": overflow
} }));
const Grid = factory((_props, ref) => {
	const props = useProps("Grid", defaultProps$88, _props);
	const { classNames, className, style, styles, unstyled, vars, grow, gutter, columns, align, justify, children, breakpoints, type,...others } = props;
	const getStyles$1 = useStyles({
		name: "Grid",
		classes: classes$40,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$40
	});
	const responsiveClassName = useRandomClassName();
	if (type === "container" && breakpoints) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(GridProvider, {
		value: {
			getStyles: getStyles$1,
			grow,
			columns: columns || 12,
			breakpoints,
			type
		},
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(GridVariables, {
			selector: `.${responsiveClassName}`,
			...props
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...getStyles$1("container"),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				ref,
				...getStyles$1("root", { className: responsiveClassName }),
				...others,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...getStyles$1("inner"),
					children
				})
			})
		})]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(GridProvider, {
		value: {
			getStyles: getStyles$1,
			grow,
			columns: columns || 12,
			breakpoints,
			type
		},
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(GridVariables, {
			selector: `.${responsiveClassName}`,
			...props
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root", { className: responsiveClassName }),
			...others,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("inner"),
				children
			})
		})]
	});
});
Grid.classes = classes$40;
Grid.displayName = "@mantine/core/Grid";
Grid.Col = GridCol;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Mark/get-mark-color.mjs
function getMarkColor({ color, theme, defaultShade }) {
	const parsed = parseThemeColor({
		color,
		theme
	});
	if (!parsed.isThemeColor) return color;
	if (parsed.shade === void 0) return `var(--mantine-color-${parsed.color}-${defaultShade})`;
	return `var(${parsed.variable})`;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Mark/Mark.module.css.mjs
var classes$39 = { "root": "m_bcb3f3c2" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Mark/Mark.mjs
const defaultProps$87 = { color: "yellow" };
const varsResolver$39 = createVarsResolver((theme, { color }) => ({ root: {
	"--mark-bg-dark": getMarkColor({
		color,
		theme,
		defaultShade: 5
	}),
	"--mark-bg-light": getMarkColor({
		color,
		theme,
		defaultShade: 2
	})
} }));
const Mark = factory((_props, ref) => {
	const props = useProps("Mark", defaultProps$87, _props);
	const { classNames, className, style, styles, unstyled, vars, color, variant,...others } = props;
	const getStyles$1 = useStyles({
		name: "Mark",
		props,
		className,
		style,
		classes: classes$39,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$39
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "mark",
		ref,
		variant,
		...getStyles$1("root"),
		...others
	});
});
Mark.classes = classes$39;
Mark.displayName = "@mantine/core/Mark";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Highlight/highlighter/highlighter.mjs
function escapeRegex(value) {
	return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
	if (_highlight == null) return [{
		chunk: value,
		highlighted: false
	}];
	const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex) : escapeRegex(_highlight);
	const shouldHighlight = Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== "";
	if (!shouldHighlight) return [{
		chunk: value,
		highlighted: false
	}];
	const matcher = typeof highlight === "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a, b) => b.length - a.length).join("|");
	const re = new RegExp(`(${matcher})`, "gi");
	const chunks = value.split(re).map((part) => ({
		chunk: part,
		highlighted: re.test(part)
	})).filter(({ chunk }) => chunk);
	return chunks;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Highlight/Highlight.mjs
const defaultProps$86 = {};
const Highlight = polymorphicFactory((props, ref) => {
	const { unstyled, children, highlight, highlightStyles, color,...others } = useProps("Highlight", defaultProps$86, props);
	const highlightChunks = highlighter(children, highlight);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
		unstyled,
		ref,
		...others,
		__staticSelector: "Highlight",
		children: highlightChunks.map(({ chunk, highlighted }, i) => highlighted ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Mark, {
			unstyled,
			color,
			style: highlightStyles,
			"data-highlight": chunk,
			children: chunk
		}, i) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: chunk }, i))
	});
});
Highlight.classes = Text.classes;
Highlight.displayName = "@mantine/core/Highlight";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/HoverCard/HoverCard.context.mjs
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext("HoverCard component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/HoverCard/HoverCardDropdown/HoverCardDropdown.mjs
const defaultProps$85 = {};
function HoverCardDropdown(props) {
	const { children, onMouseEnter, onMouseLeave,...others } = useProps("HoverCardDropdown", defaultProps$85, props);
	const ctx = useHoverCardContext();
	const handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown);
	const handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Dropdown, {
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		...others,
		children
	});
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/HoverCard/HoverCardTarget/HoverCardTarget.mjs
const defaultProps$84 = { refProp: "ref" };
const HoverCardTarget = (0, import_react.forwardRef)((props, ref) => {
	const { children, refProp, eventPropsWrapperName,...others } = useProps("HoverCardTarget", defaultProps$84, props);
	if (!isElement(children)) throw new Error("HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useHoverCardContext();
	const onMouseEnter = createEventHandler(children.props.onMouseEnter, ctx.openDropdown);
	const onMouseLeave = createEventHandler(children.props.onMouseLeave, ctx.closeDropdown);
	const eventListeners = {
		onMouseEnter,
		onMouseLeave
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		refProp,
		ref,
		...others,
		children: (0, import_react.cloneElement)(children, eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners)
	});
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/HoverCard/HoverCard.mjs
const defaultProps$83 = {
	openDelay: 0,
	closeDelay: 150,
	initiallyOpened: false
};
function HoverCard(props) {
	const { children, onOpen, onClose, openDelay, closeDelay, initiallyOpened,...others } = useProps("HoverCard", defaultProps$83, props);
	const [opened, { open, close }] = useDisclosure(initiallyOpened, {
		onClose,
		onOpen
	});
	const { openDropdown, closeDropdown } = useDelayedHover({
		open,
		close,
		openDelay,
		closeDelay
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(HoverCardContextProvider, {
		value: {
			openDropdown,
			closeDropdown
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover, {
			...others,
			opened,
			__staticSelector: "HoverCard",
			children
		})
	});
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.extend = (input) => input;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Image/Image.module.css.mjs
var classes$38 = { "root": "m_9e117634" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Image/Image.mjs
const defaultProps$82 = {};
const varsResolver$38 = createVarsResolver((_, { radius, fit }) => ({ root: {
	"--image-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--image-object-fit": fit
} }));
const Image = polymorphicFactory((_props, ref) => {
	const props = useProps("Image", defaultProps$82, _props);
	const { classNames, className, style, styles, unstyled, vars, onError, src, radius, fit, fallbackSrc, mod,...others } = props;
	const [error$1, setError] = (0, import_react.useState)(!src);
	(0, import_react.useEffect)(() => setError(!src), [src]);
	const getStyles$1 = useStyles({
		name: "Image",
		classes: classes$38,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$38
	});
	if (error$1 && fallbackSrc) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "img",
		ref,
		src: fallbackSrc,
		...getStyles$1("root"),
		onError,
		mod: ["fallback", mod],
		...others
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "img",
		ref,
		...getStyles$1("root"),
		src,
		onError: (event) => {
			onError?.(event);
			setError(true);
		},
		mod,
		...others
	});
});
Image.classes = classes$38;
Image.displayName = "@mantine/core/Image";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Indicator/get-position-variables/get-position-variables.mjs
function getPositionVariables(_position = "top-end", offset$3 = 0) {
	const variables = {
		"--indicator-top": void 0,
		"--indicator-bottom": void 0,
		"--indicator-left": void 0,
		"--indicator-right": void 0,
		"--indicator-translate-x": void 0,
		"--indicator-translate-y": void 0
	};
	const _offset = rem(offset$3);
	const [position, placement] = _position.split("-");
	if (position === "top") {
		variables["--indicator-top"] = _offset;
		variables["--indicator-translate-y"] = "-50%";
	}
	if (position === "middle") {
		variables["--indicator-top"] = "50%";
		variables["--indicator-translate-y"] = "-50%";
	}
	if (position === "bottom") {
		variables["--indicator-bottom"] = _offset;
		variables["--indicator-translate-y"] = "50%";
	}
	if (placement === "start") {
		variables["--indicator-left"] = _offset;
		variables["--indicator-translate-x"] = "-50%";
	}
	if (placement === "center") {
		variables["--indicator-left"] = "50%";
		variables["--indicator-translate-x"] = "-50%";
	}
	if (placement === "end") {
		variables["--indicator-right"] = _offset;
		variables["--indicator-translate-x"] = "50%";
	}
	return variables;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Indicator/Indicator.module.css.mjs
var classes$37 = {
	"root": "m_e5262200",
	"indicator": "m_760d1fb1",
	"processing": "m_885901b1"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Indicator/Indicator.mjs
const defaultProps$81 = {
	position: "top-end",
	offset: 0,
	inline: false,
	withBorder: false,
	disabled: false,
	processing: false
};
const varsResolver$37 = createVarsResolver((theme, { color, position, offset: offset$3, size: size$3, radius, zIndex, autoContrast }) => ({ root: {
	"--indicator-color": color ? getThemeColor(color, theme) : void 0,
	"--indicator-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({
		color,
		theme,
		autoContrast
	}) : void 0,
	"--indicator-size": rem(size$3),
	"--indicator-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--indicator-z-index": zIndex?.toString(),
	...getPositionVariables(position, offset$3)
} }));
const Indicator = factory((_props, ref) => {
	const props = useProps("Indicator", defaultProps$81, _props);
	const { classNames, className, style, styles, unstyled, vars, children, position, offset: offset$3, inline: inline$3, label, radius, color, withBorder, disabled, processing, zIndex, autoContrast, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Indicator",
		classes: classes$37,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$37
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref,
		...getStyles$1("root"),
		mod: [{ inline: inline$3 }, mod],
		...others,
		children: [!disabled && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			mod: {
				"with-label": !!label,
				"with-border": withBorder,
				processing
			},
			...getStyles$1("indicator"),
			children: label
		}), children]
	});
});
Indicator.classes = classes$37;
Indicator.displayName = "@mantine/core/Indicator";

//#endregion
//#region node_modules/.pnpm/@babel+runtime@7.27.3/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends.apply(null, arguments);
}

//#endregion
//#region node_modules/.pnpm/@babel+runtime@7.27.3/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}

//#endregion
//#region node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.1.6_react@19.1.0/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var index$1 = import_react.useLayoutEffect;

//#endregion
//#region node_modules/.pnpm/use-latest@1.3.0_@types+react@19.1.6_react@19.1.0/node_modules/use-latest/dist/use-latest.esm.js
var useLatest = function useLatest$1(value) {
	var ref = import_react.default.useRef(value);
	index$1(function() {
		ref.current = value;
	});
	return ref;
};

//#endregion
//#region node_modules/.pnpm/use-composed-ref@1.4.0_@types+react@19.1.6_react@19.1.0/node_modules/use-composed-ref/dist/use-composed-ref.esm.js
var updateRef = function updateRef$1(ref, value) {
	if (typeof ref === "function") {
		ref(value);
		return;
	}
	ref.current = value;
};
var useComposedRef = function useComposedRef$1(libRef, userRef) {
	var prevUserRef = import_react.default.useRef();
	return import_react.default.useCallback(function(instance) {
		libRef.current = instance;
		if (prevUserRef.current) updateRef(prevUserRef.current, null);
		prevUserRef.current = userRef;
		if (!userRef) return;
		updateRef(userRef, instance);
	}, [userRef]);
};

//#endregion
//#region node_modules/.pnpm/react-textarea-autosize@8.5.9_@types+react@19.1.6_react@19.1.0/node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js
var HIDDEN_TEXTAREA_STYLE = {
	"min-height": "0",
	"max-height": "none",
	height: "0",
	visibility: "hidden",
	overflow: "hidden",
	position: "absolute",
	"z-index": "-1000",
	top: "0",
	right: "0",
	display: "block"
};
var forceHiddenStyles = function forceHiddenStyles$2(node) {
	Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
		node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
	});
};
var forceHiddenStyles$1 = forceHiddenStyles;
var hiddenTextarea = null;
var getHeight = function getHeight$1(node, sizingData) {
	var height = node.scrollHeight;
	if (sizingData.sizingStyle.boxSizing === "border-box") return height + sizingData.borderSize;
	return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
	if (minRows === void 0) minRows = 1;
	if (maxRows === void 0) maxRows = Infinity;
	if (!hiddenTextarea) {
		hiddenTextarea = document.createElement("textarea");
		hiddenTextarea.setAttribute("tabindex", "-1");
		hiddenTextarea.setAttribute("aria-hidden", "true");
		forceHiddenStyles$1(hiddenTextarea);
	}
	if (hiddenTextarea.parentNode === null) document.body.appendChild(hiddenTextarea);
	var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle;
	var boxSizing = sizingStyle.boxSizing;
	Object.keys(sizingStyle).forEach(function(_key) {
		var key = _key;
		hiddenTextarea.style[key] = sizingStyle[key];
	});
	forceHiddenStyles$1(hiddenTextarea);
	hiddenTextarea.value = value;
	var height = getHeight(hiddenTextarea, sizingData);
	hiddenTextarea.value = value;
	height = getHeight(hiddenTextarea, sizingData);
	hiddenTextarea.value = "x";
	var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
	var minHeight = rowHeight * minRows;
	if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
	height = Math.max(minHeight, height);
	var maxHeight = rowHeight * maxRows;
	if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
	height = Math.min(maxHeight, height);
	return [height, rowHeight];
}
var noop$2 = function noop$3() {};
var pick = function pick$1(props, obj) {
	return props.reduce(function(acc, prop) {
		acc[prop] = obj[prop];
		return acc;
	}, {});
};
var SIZING_STYLE = [
	"borderBottomWidth",
	"borderLeftWidth",
	"borderRightWidth",
	"borderTopWidth",
	"boxSizing",
	"fontFamily",
	"fontSize",
	"fontStyle",
	"fontWeight",
	"letterSpacing",
	"lineHeight",
	"paddingBottom",
	"paddingLeft",
	"paddingRight",
	"paddingTop",
	"tabSize",
	"textIndent",
	"textRendering",
	"textTransform",
	"width",
	"wordBreak",
	"wordSpacing",
	"scrollbarGutter"
];
var isIE = !!document.documentElement.currentStyle;
var getSizingData = function getSizingData$2(node) {
	var style = window.getComputedStyle(node);
	if (style === null) return null;
	var sizingStyle = pick(SIZING_STYLE, style);
	var boxSizing = sizingStyle.boxSizing;
	if (boxSizing === "") return null;
	if (isIE && boxSizing === "border-box") sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px";
	var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
	var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
	return {
		sizingStyle,
		paddingSize,
		borderSize
	};
};
var getSizingData$1 = getSizingData;
function useListener(target, type, listener) {
	var latestListener = useLatest(listener);
	import_react.useLayoutEffect(function() {
		var handler = function handler$1(ev) {
			return latestListener.current(ev);
		};
		if (!target) return;
		target.addEventListener(type, handler);
		return function() {
			return target.removeEventListener(type, handler);
		};
	}, []);
}
var useFormResetListener = function useFormResetListener$1(libRef, listener) {
	useListener(document.body, "reset", function(ev) {
		if (libRef.current.form === ev.target) listener(ev);
	});
};
var useWindowResizeListener = function useWindowResizeListener$1(listener) {
	useListener(window, "resize", listener);
};
var useFontsLoadedListener = function useFontsLoadedListener$1(listener) {
	useListener(document.fonts, "loadingdone", listener);
};
var _excluded = [
	"cacheMeasurements",
	"maxRows",
	"minRows",
	"onChange",
	"onHeightChange"
];
var TextareaAutosize = function TextareaAutosize$1(_ref, userRef) {
	var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop$2 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop$2 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose(_ref, _excluded);
	if (props.style) {
		if ("maxHeight" in props.style) throw new Error("Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.");
		if ("minHeight" in props.style) throw new Error("Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.");
	}
	var isControlled = props.value !== void 0;
	var libRef = import_react.useRef(null);
	var ref = useComposedRef(libRef, userRef);
	var heightRef = import_react.useRef(0);
	var measurementsCacheRef = import_react.useRef();
	var resizeTextarea = function resizeTextarea$1() {
		var node = libRef.current;
		var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
		if (!nodeSizingData) return;
		measurementsCacheRef.current = nodeSizingData;
		var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
		if (heightRef.current !== height) {
			heightRef.current = height;
			node.style.setProperty("height", height + "px", "important");
			onHeightChange(height, { rowHeight });
		}
	};
	var handleChange = function handleChange$1(event) {
		if (!isControlled) resizeTextarea();
		onChange(event);
	};
	{
		import_react.useLayoutEffect(resizeTextarea);
		useFormResetListener(libRef, function() {
			if (!isControlled) {
				var currentValue = libRef.current.value;
				requestAnimationFrame(function() {
					var node = libRef.current;
					if (node && currentValue !== node.value) resizeTextarea();
				});
			}
		});
		useWindowResizeListener(resizeTextarea);
		useFontsLoadedListener(resizeTextarea);
		return /* @__PURE__ */ import_react.createElement("textarea", _extends({}, props, {
			onChange: handleChange,
			ref
		}));
	}
};
var index = /* @__PURE__ */ import_react.forwardRef(TextareaAutosize);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Textarea/Textarea.mjs
const defaultProps$80 = {};
const Textarea = factory((props, ref) => {
	const { autosize, maxRows, minRows, __staticSelector, resize,...others } = useProps("Textarea", defaultProps$80, props);
	const shouldAutosize = autosize && getEnv() !== "test";
	const autosizeProps = shouldAutosize ? {
		maxRows,
		minRows
	} : {};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: shouldAutosize ? index : "textarea",
		ref,
		...others,
		__staticSelector: __staticSelector || "Textarea",
		multiline: true,
		"data-no-overflow": autosize && maxRows === void 0 || void 0,
		__vars: { "--input-resize": resize },
		...autosizeProps
	});
});
Textarea.classes = InputBase.classes;
Textarea.displayName = "@mantine/core/Textarea";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/JsonInput/validate-json/validate-json.mjs
function validateJson(value, deserialize) {
	if (typeof value === "string" && value.trim().length === 0) return true;
	try {
		deserialize(value);
		return true;
	} catch (e) {
		return false;
	}
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/JsonInput/JsonInput.mjs
const defaultProps$79 = {
	serialize: JSON.stringify,
	deserialize: JSON.parse
};
const JsonInput = factory((props, ref) => {
	const { value, defaultValue, onChange, formatOnBlur, validationError, serialize, deserialize, onFocus, onBlur, readOnly, error: error$1,...others } = useProps("JsonInput", defaultProps$79, props);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const [valid, setValid] = (0, import_react.useState)(validateJson(_value, deserialize));
	const handleFocus = (event) => {
		onFocus?.(event);
		setValid(true);
	};
	const handleBlur = (event) => {
		typeof onBlur === "function" && onBlur(event);
		const isValid = validateJson(event.currentTarget.value, deserialize);
		formatOnBlur && !readOnly && isValid && event.currentTarget.value.trim() !== "" && setValue(serialize(deserialize(event.currentTarget.value), null, 2));
		setValid(isValid);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Textarea, {
		value: _value,
		onChange: (event) => setValue(event.currentTarget.value),
		onFocus: handleFocus,
		onBlur: handleBlur,
		ref,
		readOnly,
		...others,
		autoComplete: "off",
		__staticSelector: "JsonInput",
		error: valid ? error$1 : validationError || true,
		"data-monospace": true
	});
});
JsonInput.classes = InputBase.classes;
JsonInput.displayName = "@mantine/core/JsonInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Kbd/Kbd.module.css.mjs
var classes$36 = { "root": "m_dc6f14e2" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Kbd/Kbd.mjs
const defaultProps$78 = {};
const varsResolver$36 = createVarsResolver((_, { size: size$3 }) => ({ root: { "--kbd-fz": getSize(size$3, "kbd-fz") } }));
const Kbd = factory((_props, ref) => {
	const props = useProps("Kbd", defaultProps$78, _props);
	const { classNames, className, style, styles, unstyled, vars,...others } = props;
	const getStyles$1 = useStyles({
		name: "Kbd",
		classes: classes$36,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$36
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "kbd",
		ref,
		...getStyles$1("root"),
		...others
	});
});
Kbd.classes = classes$36;
Kbd.displayName = "@mantine/core/Kbd";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/List/List.context.mjs
const [ListProvider, useListContext] = createSafeContext("List component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/List/List.module.css.mjs
var classes$35 = {
	"root": "m_abbac491",
	"item": "m_abb6bec2",
	"itemWrapper": "m_75cd9f71",
	"itemIcon": "m_60f83e5b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/List/ListItem/ListItem.mjs
const defaultProps$77 = {};
const ListItem = factory((_props, ref) => {
	const props = useProps("ListItem", defaultProps$77, _props);
	const { classNames, className, style, styles, vars, icon, children, mod,...others } = props;
	const ctx = useListContext();
	const _icon = icon || ctx.icon;
	const stylesApiProps = {
		classNames,
		styles
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...ctx.getStyles("item", {
			...stylesApiProps,
			className,
			style
		}),
		component: "li",
		mod: [{
			"with-icon": !!_icon,
			centered: ctx.center
		}, mod],
		ref,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			...ctx.getStyles("itemWrapper", stylesApiProps),
			children: [_icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("itemIcon", stylesApiProps),
				children: _icon
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("itemLabel", stylesApiProps),
				children
			})]
		})
	});
});
ListItem.classes = classes$35;
ListItem.displayName = "@mantine/core/ListItem";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/List/List.mjs
const defaultProps$76 = { type: "unordered" };
const varsResolver$35 = createVarsResolver((_, { size: size$3, spacing }) => ({ root: {
	"--list-fz": getFontSize(size$3),
	"--list-lh": getLineHeight(size$3),
	"--list-spacing": getSpacing(spacing)
} }));
const List = factory((_props, ref) => {
	const props = useProps("List", defaultProps$76, _props);
	const { classNames, className, style, styles, unstyled, vars, children, type, withPadding, icon, spacing, center, listStyleType, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "List",
		classes: classes$35,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$35
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ListProvider, {
		value: {
			center,
			icon,
			getStyles: getStyles$1
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...getStyles$1("root", { style: { listStyleType } }),
			component: type === "unordered" ? "ul" : "ol",
			mod: [{ "with-padding": withPadding }, mod],
			ref,
			...others,
			children
		})
	});
});
List.classes = classes$35;
List.displayName = "@mantine/core/List";
List.Item = ListItem;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/LoadingOverlay/LoadingOverlay.module.css.mjs
var classes$34 = {
	"root": "m_6e45937b",
	"loader": "m_e8eb006c",
	"overlay": "m_df587f17"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/LoadingOverlay/LoadingOverlay.mjs
const defaultProps$75 = {
	transitionProps: {
		transition: "fade",
		duration: 0
	},
	overlayProps: { backgroundOpacity: .75 },
	zIndex: getDefaultZIndex("overlay")
};
const varsResolver$34 = createVarsResolver((_, { zIndex }) => ({ root: { "--lo-z-index": zIndex?.toString() } }));
const LoadingOverlay = factory((_props, ref) => {
	const props = useProps("LoadingOverlay", defaultProps$75, _props);
	const { classNames, className, style, styles, unstyled, vars, transitionProps, loaderProps, overlayProps, visible, zIndex,...others } = props;
	const theme = useMantineTheme();
	const getStyles$1 = useStyles({
		name: "LoadingOverlay",
		classes: classes$34,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$34
	});
	const _overlayProps = {
		...defaultProps$75.overlayProps,
		...overlayProps
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
		transition: "fade",
		...transitionProps,
		mounted: !!visible,
		children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("root", { style: transitionStyles }),
			ref,
			...others,
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
					...getStyles$1("loader"),
					unstyled,
					...loaderProps
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
					..._overlayProps,
					...getStyles$1("overlay"),
					darkHidden: true,
					unstyled,
					color: overlayProps?.color || theme.white
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
					..._overlayProps,
					...getStyles$1("overlay"),
					lightHidden: true,
					unstyled,
					color: overlayProps?.color || theme.colors.dark[5]
				})
			]
		})
	});
});
LoadingOverlay.classes = classes$34;
LoadingOverlay.displayName = "@mantine/core/LoadingOverlay";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/Menu.context.mjs
const [MenuContextProvider, useMenuContext] = createSafeContext("Menu component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/Menu.module.css.mjs
var classes$33 = {
	"dropdown": "m_dc9b7c9f",
	"label": "m_9bfac126",
	"divider": "m_efdf90cb",
	"item": "m_99ac2aa1",
	"itemLabel": "m_5476e0d3",
	"itemSection": "m_8b75e504",
	"chevron": "m_b85b0bed"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuDivider/MenuDivider.mjs
const defaultProps$74 = {};
const MenuDivider = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("MenuDivider", defaultProps$74, props);
	const ctx = useMenuContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("divider", {
			className,
			style,
			styles,
			classNames
		}),
		...others
	});
});
MenuDivider.classes = classes$33;
MenuDivider.displayName = "@mantine/core/MenuDivider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuDropdown/MenuDropdown.mjs
const defaultProps$73 = {};
const MenuDropdown = factory((props, ref) => {
	const { classNames, className, style, styles, vars, onMouseEnter, onMouseLeave, onKeyDown, children,...others } = useProps("MenuDropdown", defaultProps$73, props);
	const wrapperRef = (0, import_react.useRef)(null);
	const ctx = useMenuContext();
	const handleKeyDown = createEventHandler(onKeyDown, (event) => {
		if (event.key === "ArrowUp" || event.key === "ArrowDown") {
			event.preventDefault();
			wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus();
		}
	});
	const handleMouseEnter = createEventHandler(onMouseEnter, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown());
	const handleMouseLeave = createEventHandler(onMouseLeave, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown());
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Popover.Dropdown, {
		...others,
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		role: "menu",
		"aria-orientation": "vertical",
		ref: useMergedRef(ref, wrapperRef),
		...ctx.getStyles("dropdown", {
			className,
			style,
			styles,
			classNames,
			withStaticClass: false
		}),
		tabIndex: -1,
		"data-menu-dropdown": true,
		onKeyDown: handleKeyDown,
		children: [ctx.withInitialFocusPlaceholder && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			tabIndex: -1,
			"data-autofocus": true,
			"data-mantine-stop-propagation": true,
			style: { outline: 0 }
		}), children]
	});
});
MenuDropdown.classes = classes$33;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuSub/MenuSub.context.mjs
const [SubMenuProvider, useSubMenuContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuItem/MenuItem.mjs
const defaultProps$72 = {};
const MenuItem = polymorphicFactory((props, ref) => {
	const { classNames, className, style, styles, vars, color, closeMenuOnClick, leftSection, rightSection, children, disabled, "data-disabled": dataDisabled,...others } = useProps("MenuItem", defaultProps$72, props);
	const ctx = useMenuContext();
	const subCtx = useSubMenuContext();
	const theme = useMantineTheme();
	const { dir } = useDirection();
	const itemRef = (0, import_react.useRef)(null);
	const _others = others;
	const handleClick = createEventHandler(_others.onClick, () => {
		if (dataDisabled) return;
		if (typeof closeMenuOnClick === "boolean") closeMenuOnClick && ctx.closeDropdownImmediately();
		else ctx.closeOnItemClick && ctx.closeDropdownImmediately();
	});
	const colors = color ? theme.variantColorResolver({
		color,
		theme,
		variant: "light"
	}) : void 0;
	const parsedThemeColor = color ? parseThemeColor({
		color,
		theme
	}) : null;
	const handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
		if (event.key === "ArrowLeft" && subCtx) {
			subCtx.close();
			subCtx.focusParentItem();
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		onMouseDown: (event) => event.preventDefault(),
		...others,
		unstyled: ctx.unstyled,
		tabIndex: ctx.menuItemTabIndex,
		...ctx.getStyles("item", {
			className,
			style,
			styles,
			classNames
		}),
		ref: useMergedRef(itemRef, ref),
		role: "menuitem",
		disabled,
		"data-menu-item": true,
		"data-disabled": disabled || dataDisabled || void 0,
		"data-mantine-stop-propagation": true,
		onClick: handleClick,
		onKeyDown: createScopedKeydownHandler({
			siblingSelector: "[data-menu-item]:not([data-disabled])",
			parentSelector: "[data-menu-dropdown]",
			activateOnFocus: false,
			loop: ctx.loop,
			dir,
			orientation: "vertical",
			onKeyDown: handleKeydown
		}),
		__vars: {
			"--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
			"--menu-item-hover": colors?.hover
		},
		children: [
			leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemSection", {
					styles,
					classNames
				}),
				"data-position": "left",
				children: leftSection
			}),
			children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemLabel", {
					styles,
					classNames
				}),
				children
			}),
			rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemSection", {
					styles,
					classNames
				}),
				"data-position": "right",
				children: rightSection
			})
		]
	});
});
MenuItem.classes = classes$33;
MenuItem.displayName = "@mantine/core/MenuItem";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuLabel/MenuLabel.mjs
const defaultProps$71 = {};
const MenuLabel = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("MenuLabel", defaultProps$71, props);
	const ctx = useMenuContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("label", {
			className,
			style,
			styles,
			classNames
		}),
		...others
	});
});
MenuLabel.classes = classes$33;
MenuLabel.displayName = "@mantine/core/MenuLabel";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuSubDropdown/MenuSubDropdown.mjs
const defaultProps$70 = {};
const MenuSubDropdown = factory((props, ref) => {
	const { classNames, className, style, styles, vars, onMouseEnter, onMouseLeave, onKeyDown, children,...others } = useProps("MenuSubDropdown", defaultProps$70, props);
	const wrapperRef = (0, import_react.useRef)(null);
	const ctx = useMenuContext();
	const subCtx = useSubMenuContext();
	const handleMouseEnter = createEventHandler(onMouseEnter, subCtx?.open);
	const handleMouseLeave = createEventHandler(onMouseLeave, subCtx?.close);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Dropdown, {
		...others,
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		role: "menu",
		"aria-orientation": "vertical",
		ref: useMergedRef(ref, wrapperRef),
		...ctx.getStyles("dropdown", {
			className,
			style,
			styles,
			classNames,
			withStaticClass: false
		}),
		tabIndex: -1,
		"data-menu-dropdown": true,
		children
	});
});
MenuSubDropdown.classes = classes$33;
MenuSubDropdown.displayName = "@mantine/core/MenuSubDropdown";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuSubItem/MenuSubItem.mjs
const defaultProps$69 = {};
const MenuSubItem = polymorphicFactory((props, ref) => {
	const { classNames, className, style, styles, vars, color, leftSection, rightSection, children, disabled, "data-disabled": dataDisabled, closeMenuOnClick,...others } = useProps("MenuSubItem", defaultProps$69, props);
	const ctx = useMenuContext();
	const subCtx = useSubMenuContext();
	const theme = useMantineTheme();
	const { dir } = useDirection();
	const itemRef = (0, import_react.useRef)(null);
	const _others = others;
	const colors = color ? theme.variantColorResolver({
		color,
		theme,
		variant: "light"
	}) : void 0;
	const parsedThemeColor = color ? parseThemeColor({
		color,
		theme
	}) : null;
	const handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
		if (event.key === "ArrowRight") {
			subCtx?.open();
			subCtx?.focusFirstItem();
		}
		if (event.key === "ArrowLeft" && subCtx?.parentContext) {
			subCtx.parentContext.close();
			subCtx.parentContext.focusParentItem();
		}
	});
	const handleClick = createEventHandler(_others.onClick, () => {
		if (!dataDisabled && closeMenuOnClick) ctx.closeDropdownImmediately();
	});
	const handleMouseEnter = createEventHandler(_others.onMouseEnter, subCtx?.open);
	const handleMouseLeave = createEventHandler(_others.onMouseLeave, subCtx?.close);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		onMouseDown: (event) => event.preventDefault(),
		...others,
		unstyled: ctx.unstyled,
		tabIndex: ctx.menuItemTabIndex,
		...ctx.getStyles("item", {
			className,
			style,
			styles,
			classNames
		}),
		ref: useMergedRef(itemRef, ref),
		role: "menuitem",
		disabled,
		"data-menu-item": true,
		"data-sub-menu-item": true,
		"data-disabled": disabled || dataDisabled || void 0,
		"data-mantine-stop-propagation": true,
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		onClick: handleClick,
		onKeyDown: createScopedKeydownHandler({
			siblingSelector: "[data-menu-item]:not([data-disabled])",
			parentSelector: "[data-menu-dropdown]",
			activateOnFocus: false,
			loop: ctx.loop,
			dir,
			orientation: "vertical",
			onKeyDown: handleKeydown
		}),
		__vars: {
			"--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
			"--menu-item-hover": colors?.hover
		},
		children: [
			leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemSection", {
					styles,
					classNames
				}),
				"data-position": "left",
				children: leftSection
			}),
			children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemLabel", {
					styles,
					classNames
				}),
				children
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemSection", {
					styles,
					classNames
				}),
				"data-position": "right",
				children: rightSection || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionChevron, {
					...ctx.getStyles("chevron"),
					size: 14
				})
			})
		]
	});
});
MenuSubItem.classes = classes$33;
MenuSubItem.displayName = "@mantine/core/MenuSubItem";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuSubTarget/MenuSubTarget.mjs
function MenuSubTarget({ children, refProp }) {
	if (!isElement(children)) throw new Error("Menu.Sub.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	useMenuContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		refProp,
		popupType: "menu",
		children
	});
}
MenuSubTarget.displayName = "@mantine/core/MenuSubTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuSub/MenuSub.mjs
const defaultProps$68 = {
	offset: 0,
	position: "right-start",
	transitionProps: { duration: 0 }
};
function MenuSub(_props) {
	const { children, closeDelay,...others } = useProps("MenuSub", defaultProps$68, _props);
	const id = useId();
	const [opened, { open, close }] = useDisclosure(false);
	const ctx = useSubMenuContext();
	const { openDropdown, closeDropdown } = useDelayedHover({
		open,
		close,
		closeDelay,
		openDelay: 0
	});
	const focusFirstItem = () => window.setTimeout(() => {
		document.getElementById(`${id}-dropdown`)?.querySelectorAll("[data-menu-item]:not([data-disabled])")[0]?.focus();
	}, 16);
	const focusParentItem = () => window.setTimeout(() => {
		document.getElementById(`${id}-target`)?.focus();
	}, 16);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SubMenuProvider, {
		value: {
			opened,
			close: closeDropdown,
			open: openDropdown,
			focusFirstItem,
			focusParentItem,
			parentContext: ctx
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover, {
			opened,
			...others,
			withinPortal: false,
			id,
			children
		})
	});
}
MenuSub.extend = (input) => input;
MenuSub.displayName = "@mantine/core/MenuSub";
MenuSub.Target = MenuSubTarget;
MenuSub.Dropdown = MenuSubDropdown;
MenuSub.Item = MenuSubItem;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/MenuTarget/MenuTarget.mjs
const defaultProps$67 = { refProp: "ref" };
const MenuTarget = (0, import_react.forwardRef)((props, ref) => {
	const { children, refProp,...others } = useProps("MenuTarget", defaultProps$67, props);
	if (!isElement(children)) throw new Error("Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useMenuContext();
	const _childrenProps = children.props;
	const onClick = createEventHandler(_childrenProps.onClick, () => {
		if (ctx.trigger === "click") ctx.toggleDropdown();
		else if (ctx.trigger === "click-hover") {
			ctx.setOpenedViaClick(true);
			if (!ctx.opened) ctx.openDropdown();
		}
	});
	const onMouseEnter = createEventHandler(_childrenProps.onMouseEnter, () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown());
	const onMouseLeave = createEventHandler(_childrenProps.onMouseLeave, () => {
		if (ctx.trigger === "hover") ctx.closeDropdown();
		else if (ctx.trigger === "click-hover" && !ctx.openedViaClick) ctx.closeDropdown();
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		refProp,
		popupType: "menu",
		ref,
		...others,
		children: (0, import_react.cloneElement)(children, {
			onClick,
			onMouseEnter,
			onMouseLeave,
			"data-expanded": ctx.opened ? true : void 0
		})
	});
});
MenuTarget.displayName = "@mantine/core/MenuTarget";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Menu/Menu.mjs
const defaultProps$66 = {
	trapFocus: true,
	closeOnItemClick: true,
	withInitialFocusPlaceholder: true,
	clickOutsideEvents: [
		"mousedown",
		"touchstart",
		"keydown"
	],
	loop: true,
	trigger: "click",
	openDelay: 0,
	closeDelay: 100,
	menuItemTabIndex: -1
};
function Menu(_props) {
	const props = useProps("Menu", defaultProps$66, _props);
	const { children, onOpen, onClose, opened, defaultOpened, trapFocus, onChange, closeOnItemClick, loop, closeOnEscape: closeOnEscape$1, trigger, openDelay, closeDelay, classNames, styles, unstyled, variant, vars, menuItemTabIndex, keepMounted, withInitialFocusPlaceholder,...others } = props;
	const getStyles$1 = useStyles({
		name: "Menu",
		classes: classes$33,
		props,
		classNames,
		styles,
		unstyled
	});
	const [_opened, setOpened] = useUncontrolled({
		value: opened,
		defaultValue: defaultOpened,
		finalValue: false,
		onChange
	});
	const [openedViaClick, setOpenedViaClick] = (0, import_react.useState)(false);
	const close = () => {
		setOpened(false);
		setOpenedViaClick(false);
		_opened && onClose?.();
	};
	const open = () => {
		setOpened(true);
		!_opened && onOpen?.();
	};
	const toggleDropdown = () => {
		_opened ? close() : open();
	};
	const { openDropdown, closeDropdown } = useDelayedHover({
		open,
		close,
		closeDelay,
		openDelay
	});
	const getItemIndex = (node) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node);
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MenuContextProvider, {
		value: {
			getStyles: getStyles$1,
			opened: _opened,
			toggleDropdown,
			getItemIndex,
			openedViaClick,
			setOpenedViaClick,
			closeOnItemClick,
			closeDropdown: trigger === "click" ? close : closeDropdown,
			openDropdown: trigger === "click" ? open : openDropdown,
			closeDropdownImmediately: close,
			loop,
			trigger,
			unstyled,
			menuItemTabIndex,
			withInitialFocusPlaceholder
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover, {
			...others,
			opened: _opened,
			onChange: toggleDropdown,
			defaultOpened,
			trapFocus: keepMounted ? false : trapFocus,
			closeOnEscape: closeOnEscape$1,
			__staticSelector: "Menu",
			classNames: resolvedClassNames,
			styles: resolvedStyles,
			unstyled,
			variant,
			keepMounted,
			children
		})
	});
}
Menu.extend = (input) => input;
Menu.withProps = getWithProps(Menu);
Menu.classes = classes$33;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
Menu.Sub = MenuSub;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/Modal.context.mjs
const [ModalProvider, useModalContext] = createSafeContext("Modal component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/Modal.module.css.mjs
var classes$32 = {
	"root": "m_9df02822",
	"content": "m_54c44539",
	"inner": "m_1f958f16",
	"header": "m_d0e2b9cd"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalBody.mjs
const defaultProps$65 = {};
const ModalBody = factory((_props, ref) => {
	const props = useProps("ModalBody", defaultProps$65, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useModalContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseBody, {
		ref,
		...ctx.getStyles("body", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
ModalBody.classes = classes$32;
ModalBody.displayName = "@mantine/core/ModalBody";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalCloseButton.mjs
const defaultProps$64 = {};
const ModalCloseButton = factory((_props, ref) => {
	const props = useProps("ModalCloseButton", defaultProps$64, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useModalContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseCloseButton, {
		ref,
		...ctx.getStyles("close", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
ModalCloseButton.classes = classes$32;
ModalCloseButton.displayName = "@mantine/core/ModalCloseButton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalContent.mjs
const defaultProps$63 = {};
const ModalContent = factory((_props, ref) => {
	const props = useProps("ModalContent", defaultProps$63, _props);
	const { classNames, className, style, styles, vars, children, __hidden,...others } = props;
	const ctx = useModalContext();
	const Scroll = ctx.scrollAreaComponent || NativeScrollArea;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseContent, {
		...ctx.getStyles("content", {
			className,
			style,
			styles,
			classNames
		}),
		innerProps: ctx.getStyles("inner", {
			className,
			style,
			styles,
			classNames
		}),
		"data-full-screen": ctx.fullScreen || void 0,
		"data-modal-content": true,
		"data-hidden": __hidden || void 0,
		ref,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scroll, {
			style: { maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))` },
			children
		})
	});
});
ModalContent.classes = classes$32;
ModalContent.displayName = "@mantine/core/ModalContent";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalHeader.mjs
const defaultProps$62 = {};
const ModalHeader = factory((_props, ref) => {
	const props = useProps("ModalHeader", defaultProps$62, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useModalContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseHeader, {
		ref,
		...ctx.getStyles("header", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
ModalHeader.classes = classes$32;
ModalHeader.displayName = "@mantine/core/ModalHeader";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalOverlay.mjs
const defaultProps$61 = {};
const ModalOverlay = factory((_props, ref) => {
	const props = useProps("ModalOverlay", defaultProps$61, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useModalContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseOverlay, {
		ref,
		...ctx.getStyles("overlay", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
ModalOverlay.classes = classes$32;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalRoot.mjs
const defaultProps$60 = {
	__staticSelector: "Modal",
	closeOnClickOutside: true,
	withinPortal: true,
	lockScroll: true,
	trapFocus: true,
	returnFocus: true,
	closeOnEscape: true,
	keepMounted: false,
	zIndex: getDefaultZIndex("modal"),
	transitionProps: {
		duration: 200,
		transition: "fade-down"
	},
	yOffset: "5dvh"
};
const varsResolver$33 = createVarsResolver((_, { radius, size: size$3, yOffset, xOffset }) => ({ root: {
	"--modal-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--modal-size": getSize(size$3, "modal-size"),
	"--modal-y-offset": rem(yOffset),
	"--modal-x-offset": rem(xOffset)
} }));
const ModalRoot = factory((_props, ref) => {
	const props = useProps("ModalRoot", defaultProps$60, _props);
	const { classNames, className, style, styles, unstyled, vars, yOffset, scrollAreaComponent, radius, fullScreen, centered, xOffset, __staticSelector,...others } = props;
	const getStyles$1 = useStyles({
		name: __staticSelector,
		classes: classes$32,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$33
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalProvider, {
		value: {
			yOffset,
			scrollAreaComponent,
			getStyles: getStyles$1,
			fullScreen
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBase, {
			ref,
			...getStyles$1("root"),
			"data-full-screen": fullScreen || void 0,
			"data-centered": centered || void 0,
			"data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || void 0,
			unstyled,
			...others
		})
	});
});
ModalRoot.classes = classes$32;
ModalRoot.displayName = "@mantine/core/ModalRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalStack.mjs
const [ModalStackProvider, useModalStackContext] = createOptionalContext();
function ModalStack({ children }) {
	const [stack, setStack] = (0, import_react.useState)([]);
	const [maxZIndex, setMaxZIndex] = (0, import_react.useState)(getDefaultZIndex("modal"));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalStackProvider, {
		value: {
			stack,
			addModal: (id, zIndex) => {
				setStack((current) => [.../* @__PURE__ */ new Set([...current, id])]);
				setMaxZIndex((current) => typeof zIndex === "number" && typeof current === "number" ? Math.max(current, zIndex) : current);
			},
			removeModal: (id) => setStack((current) => current.filter((currentId) => currentId !== id)),
			getZIndex: (id) => `calc(${maxZIndex} + ${stack.indexOf(id)} + 1)`,
			currentId: stack[stack.length - 1],
			maxZIndex
		},
		children
	});
}
ModalStack.displayName = "@mantine/core/ModalStack";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/ModalTitle.mjs
const defaultProps$59 = {};
const ModalTitle = factory((_props, ref) => {
	const props = useProps("ModalTitle", defaultProps$59, _props);
	const { classNames, className, style, styles, vars,...others } = props;
	const ctx = useModalContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBaseTitle, {
		ref,
		...ctx.getStyles("title", {
			classNames,
			style,
			styles,
			className
		}),
		...others
	});
});
ModalTitle.classes = classes$32;
ModalTitle.displayName = "@mantine/core/ModalTitle";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/Modal.mjs
const defaultProps$58 = {
	closeOnClickOutside: true,
	withinPortal: true,
	lockScroll: true,
	trapFocus: true,
	returnFocus: true,
	closeOnEscape: true,
	keepMounted: false,
	zIndex: getDefaultZIndex("modal"),
	transitionProps: {
		duration: 200,
		transition: "fade-down"
	},
	withOverlay: true,
	withCloseButton: true
};
const Modal = factory((_props, ref) => {
	const { title, withOverlay, overlayProps, withCloseButton, closeButtonProps, children, radius, opened, stackId, zIndex,...others } = useProps("Modal", defaultProps$58, _props);
	const ctx = useModalStackContext();
	const hasHeader = !!title || withCloseButton;
	const stackProps = ctx && stackId ? {
		closeOnEscape: ctx.currentId === stackId,
		trapFocus: ctx.currentId === stackId,
		zIndex: ctx.getZIndex(stackId)
	} : {};
	const overlayVisible = withOverlay === false ? false : stackId && ctx ? ctx.currentId === stackId : opened;
	(0, import_react.useEffect)(() => {
		if (ctx && stackId) opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId);
	}, [
		opened,
		stackId,
		zIndex
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ModalRoot, {
		ref,
		radius,
		opened,
		zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
		...others,
		...stackProps,
		children: [withOverlay && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalOverlay, {
			visible: overlayVisible,
			transitionProps: ctx && stackId ? { duration: 0 } : void 0,
			...overlayProps
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ModalContent, {
			radius,
			__hidden: ctx && stackId && opened ? stackId !== ctx.currentId : false,
			children: [hasHeader && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ModalHeader, { children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalTitle, { children: title }), withCloseButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalCloseButton, { ...closeButtonProps })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalBody, { children })]
		})]
	});
});
Modal.classes = classes$32;
Modal.displayName = "@mantine/core/Modal";
Modal.Root = ModalRoot;
Modal.Overlay = ModalOverlay;
Modal.Content = ModalContent;
Modal.Body = ModalBody;
Modal.Header = ModalHeader;
Modal.Title = ModalTitle;
Modal.CloseButton = ModalCloseButton;
Modal.Stack = ModalStack;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Modal/use-modals-stack.mjs
function useModalsStack(modals) {
	const initialState = modals.reduce((acc, modal) => ({
		...acc,
		[modal]: false
	}), {});
	const [state, setState] = (0, import_react.useState)(initialState);
	const open = (0, import_react.useCallback)((modal) => {
		setState((current) => ({
			...current,
			[modal]: true
		}));
	}, []);
	const close = (0, import_react.useCallback)((modal) => setState((current) => ({
		...current,
		[modal]: false
	})), []);
	const toggle = (0, import_react.useCallback)((modal) => setState((current) => ({
		...current,
		[modal]: !current[modal]
	})), []);
	const closeAll = (0, import_react.useCallback)(() => setState(initialState), []);
	const register = (0, import_react.useCallback)((modal) => ({
		opened: state[modal],
		onClose: () => close(modal),
		stackId: modal
	}), [state]);
	return {
		state,
		open,
		close,
		closeAll,
		toggle,
		register
	};
}
const useDrawersStack = useModalsStack;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PillsInput/PillsInput.context.mjs
const [PillsInputProvider, usePillsInputContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pill/PillGroup.context.mjs
const [PillGroupProvider, usePillGroupContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pill/Pill.module.css.mjs
var classes$31 = {
	"root": "m_7cda1cd6",
	"root--default": "m_44da308b",
	"root--contrast": "m_e3a01f8",
	"label": "m_1e0e6180",
	"remove": "m_ae386778",
	"group": "m_1dcfd90b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pill/PillGroup/PillGroup.mjs
const defaultProps$57 = {};
const varsResolver$32 = createVarsResolver((_, { gap }, { size: size$3 }) => ({ group: { "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size$3, "pg-gap") } }));
const PillGroup = factory((_props, ref) => {
	const props = useProps("PillGroup", defaultProps$57, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, disabled,...others } = props;
	const pillsInputCtx = usePillsInputContext();
	const _size = pillsInputCtx?.size || size$3 || void 0;
	const getStyles$1 = useStyles({
		name: "PillGroup",
		classes: classes$31,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$32,
		stylesCtx: { size: _size },
		rootSelector: "group"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillGroupProvider, {
		value: {
			size: _size,
			disabled
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			size: _size,
			...getStyles$1("group"),
			...others
		})
	});
});
PillGroup.classes = classes$31;
PillGroup.displayName = "@mantine/core/PillGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pill/Pill.mjs
const defaultProps$56 = { variant: "default" };
const varsResolver$31 = createVarsResolver((_, { radius }, { size: size$3 }) => ({ root: {
	"--pill-fz": getSize(size$3, "pill-fz"),
	"--pill-height": getSize(size$3, "pill-height"),
	"--pill-radius": radius === void 0 ? void 0 : getRadius(radius)
} }));
const Pill = factory((_props, ref) => {
	const props = useProps("Pill", defaultProps$56, _props);
	const { classNames, className, style, styles, unstyled, vars, variant, children, withRemoveButton, onRemove, removeButtonProps, radius, size: size$3, disabled, mod,...others } = props;
	const ctx = usePillGroupContext();
	const pillsInputCtx = usePillsInputContext();
	const _size = size$3 || ctx?.size || void 0;
	const _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default";
	const getStyles$1 = useStyles({
		name: "Pill",
		classes: classes$31,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$31,
		stylesCtx: { size: _size }
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		component: "span",
		ref,
		variant: _variant,
		size: _size,
		...getStyles$1("root", { variant: _variant }),
		mod: [{
			"with-remove": withRemoveButton && !disabled,
			disabled: disabled || ctx?.disabled
		}, mod],
		...others,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			...getStyles$1("label"),
			children
		}), withRemoveButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
			variant: "transparent",
			radius,
			tabIndex: -1,
			"aria-hidden": true,
			unstyled,
			...removeButtonProps,
			...getStyles$1("remove", {
				className: removeButtonProps?.className,
				style: removeButtonProps?.style
			}),
			onMouseDown: (event) => {
				event.preventDefault();
				event.stopPropagation();
				removeButtonProps?.onMouseDown?.(event);
			},
			onClick: (event) => {
				event.stopPropagation();
				onRemove?.();
				removeButtonProps?.onClick?.(event);
			}
		})]
	});
});
Pill.classes = classes$31;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PillsInput/PillsInput.module.css.mjs
var classes$30 = { "field": "m_45c4369d" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PillsInput/PillsInputField/PillsInputField.mjs
const defaultProps$55 = { type: "visible" };
const PillsInputField = factory((_props, ref) => {
	const props = useProps("PillsInputField", defaultProps$55, _props);
	const { classNames, className, style, styles, unstyled, vars, type, disabled, id, pointer, mod,...others } = props;
	const ctx = usePillsInputContext();
	const inputWrapperCtx = useInputWrapperContext();
	const getStyles$1 = useStyles({
		name: "PillsInputField",
		classes: classes$30,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "field"
	});
	const _disabled = disabled || ctx?.disabled;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "input",
		ref: useMergedRef(ref, ctx?.fieldRef),
		"data-type": type,
		disabled: _disabled,
		mod: [{
			disabled: _disabled,
			pointer
		}, mod],
		...getStyles$1("field"),
		...others,
		id: inputWrapperCtx?.inputId || id,
		"aria-invalid": ctx?.hasError,
		"aria-describedby": inputWrapperCtx?.describedBy,
		type: "text",
		onMouseDown: (event) => !pointer && event.stopPropagation()
	});
});
PillsInputField.classes = classes$30;
PillsInputField.displayName = "@mantine/core/PillsInputField";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PillsInput/PillsInput.mjs
const defaultProps$54 = {};
const PillsInput = factory((_props, ref) => {
	const props = useProps("PillsInput", defaultProps$54, _props);
	const { children, onMouseDown, onClick, size: size$3, disabled, __staticSelector, error: error$1, variant,...others } = props;
	const fieldRef = (0, import_react.useRef)(null);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillsInputProvider, {
		value: {
			fieldRef,
			size: size$3,
			disabled,
			hasError: !!error$1,
			variant
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
			size: size$3,
			error: error$1,
			variant,
			component: "div",
			ref,
			onMouseDown: (event) => {
				event.preventDefault();
				onMouseDown?.(event);
				fieldRef.current?.focus();
			},
			onClick: (event) => {
				event.preventDefault();
				const fieldset = event.currentTarget.closest("fieldset");
				if (!fieldset?.disabled) {
					fieldRef.current?.focus();
					onClick?.(event);
				}
			},
			...others,
			multiline: true,
			disabled,
			__staticSelector: __staticSelector || "PillsInput",
			withAria: false,
			children
		})
	});
});
PillsInput.displayName = "@mantine/core/PillsInput";
PillsInput.Field = PillsInputField;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/MultiSelect/filter-picked-values.mjs
function filterPickedValues({ data, value }) {
	const normalizedValue = value.map((item) => item.trim().toLowerCase());
	const filtered = data.reduce((acc, item) => {
		if (isOptionsGroup(item)) acc.push({
			group: item.group,
			items: item.items.filter((option) => normalizedValue.indexOf(option.value.toLowerCase().trim()) === -1)
		});
		else if (normalizedValue.indexOf(item.value.toLowerCase().trim()) === -1) acc.push(item);
		return acc;
	}, []);
	return filtered;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/MultiSelect/MultiSelect.mjs
const defaultProps$53 = {
	maxValues: Infinity,
	withCheckIcon: true,
	checkIconPosition: "left",
	hiddenInputValuesDivider: ","
};
const MultiSelect = factory((_props, ref) => {
	const props = useProps("MultiSelect", defaultProps$53, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, value, defaultValue, onChange, onKeyDown, variant, data, dropdownOpened, defaultDropdownOpened, onDropdownOpen, onDropdownClose, selectFirstOptionOnChange, onOptionSubmit, comboboxProps, filter, limit, withScrollArea, maxDropdownHeight, searchValue, defaultSearchValue, onSearchChange, readOnly, disabled, onFocus, onBlur, radius, rightSection, rightSectionWidth, rightSectionPointerEvents, rightSectionProps, leftSection, leftSectionWidth, leftSectionPointerEvents, leftSectionProps, inputContainer, inputWrapperOrder, withAsterisk, labelProps, descriptionProps, errorProps, wrapperProps, description, label, error: error$1, maxValues, searchable, nothingFoundMessage, withCheckIcon, checkIconPosition, hidePickedOptions, withErrorStyles, name, form, id, clearable, clearButtonProps, hiddenInputProps, placeholder, hiddenInputValuesDivider, required, mod, renderOption, onRemove, onClear, scrollAreaProps, chevronColor,...others } = props;
	const _id = useId(id);
	const parsedData = getParsedComboboxData(data);
	const optionsLockup = getOptionsLockup(parsedData);
	const combobox = useCombobox({
		opened: dropdownOpened,
		defaultOpened: defaultDropdownOpened,
		onDropdownOpen,
		onDropdownClose: () => {
			onDropdownClose?.();
			combobox.resetSelectedOption();
		}
	});
	const { styleProps, rest: { type, autoComplete,...rest } } = extractStyleProps(others);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [],
		onChange
	});
	const [_searchValue, setSearchValue] = useUncontrolled({
		value: searchValue,
		defaultValue: defaultSearchValue,
		finalValue: "",
		onChange: onSearchChange
	});
	const handleSearchChange = (value2) => {
		setSearchValue(value2);
		combobox.resetSelectedOption();
	};
	const getStyles$1 = useStyles({
		name: "MultiSelect",
		classes: {},
		props,
		classNames,
		styles,
		unstyled
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		props,
		styles,
		classNames
	});
	const handleInputKeydown = (event) => {
		onKeyDown?.(event);
		if (event.key === " " && !searchable) {
			event.preventDefault();
			combobox.toggleDropdown();
		}
		if (event.key === "Backspace" && _searchValue.length === 0 && _value.length > 0) {
			onRemove?.(_value[_value.length - 1]);
			setValue(_value.slice(0, _value.length - 1));
		}
	};
	const values$1 = _value.map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pill, {
		withRemoveButton: !readOnly && !optionsLockup[item]?.disabled,
		onRemove: () => {
			setValue(_value.filter((i) => item !== i));
			onRemove?.(item);
		},
		unstyled,
		disabled,
		...getStyles$1("pill"),
		children: optionsLockup[item]?.label || item
	}, `${item}-${index$4}`));
	(0, import_react.useEffect)(() => {
		if (selectFirstOptionOnChange) combobox.selectFirstOption();
	}, [selectFirstOptionOnChange, _searchValue]);
	const clearButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.ClearButton, {
		...clearButtonProps,
		onClear: () => {
			onClear?.();
			setValue([]);
			handleSearchChange("");
		}
	});
	const filteredData = filterPickedValues({
		data: parsedData,
		value: _value
	});
	const _clearable = clearable && _value.length > 0 && !disabled && !readOnly;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox, {
		store: combobox,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		size: size$3,
		readOnly,
		__staticSelector: "MultiSelect",
		onOptionSubmit: (val) => {
			onOptionSubmit?.(val);
			handleSearchChange("");
			combobox.updateSelectedOptionIndex("selected");
			if (_value.includes(optionsLockup[val].value)) {
				setValue(_value.filter((v) => v !== optionsLockup[val].value));
				onRemove?.(optionsLockup[val].value);
			} else if (_value.length < maxValues) setValue([..._value, optionsLockup[val].value]);
		},
		...comboboxProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.DropdownTarget, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillsInput, {
			...styleProps,
			__staticSelector: "MultiSelect",
			classNames: resolvedClassNames,
			styles: resolvedStyles,
			unstyled,
			size: size$3,
			className,
			style,
			variant,
			disabled,
			radius,
			__defaultRightSection: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Chevron, {
				size: size$3,
				error: error$1,
				unstyled,
				color: chevronColor
			}),
			__clearSection: clearButton,
			__clearable: _clearable,
			rightSection,
			rightSectionPointerEvents: rightSectionPointerEvents || (clearButton ? "all" : "none"),
			rightSectionWidth,
			rightSectionProps,
			leftSection,
			leftSectionWidth,
			leftSectionPointerEvents,
			leftSectionProps,
			inputContainer,
			inputWrapperOrder,
			withAsterisk,
			labelProps,
			descriptionProps,
			errorProps,
			wrapperProps,
			description,
			label,
			error: error$1,
			withErrorStyles,
			__stylesApiProps: {
				...props,
				rightSectionPointerEvents: rightSectionPointerEvents || (_clearable ? "all" : "none"),
				multiline: true
			},
			pointer: !searchable,
			onClick: () => searchable ? combobox.openDropdown() : combobox.toggleDropdown(),
			"data-expanded": combobox.dropdownOpened || void 0,
			id: _id,
			required,
			mod,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Pill.Group, {
				disabled,
				unstyled,
				...getStyles$1("pillsList"),
				children: [values$1, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.EventsTarget, {
					autoComplete,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillsInput.Field, {
						...rest,
						ref,
						id: _id,
						placeholder,
						type: !searchable && !placeholder ? "hidden" : "visible",
						...getStyles$1("inputField"),
						unstyled,
						onFocus: (event) => {
							onFocus?.(event);
							searchable && combobox.openDropdown();
						},
						onBlur: (event) => {
							onBlur?.(event);
							combobox.closeDropdown();
							handleSearchChange("");
						},
						onKeyDown: handleInputKeydown,
						value: _searchValue,
						onChange: (event) => {
							handleSearchChange(event.currentTarget.value);
							searchable && combobox.openDropdown();
							selectFirstOptionOnChange && combobox.selectFirstOption();
						},
						disabled,
						readOnly: readOnly || !searchable,
						pointer: !searchable
					})
				})]
			})
		}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionsDropdown, {
			data: hidePickedOptions ? filteredData : parsedData,
			hidden: readOnly || disabled,
			filter,
			search: _searchValue,
			limit,
			hiddenWhenEmpty: !nothingFoundMessage,
			withScrollArea,
			maxDropdownHeight,
			filterOptions: searchable,
			value: _value,
			checkIconPosition,
			withCheckIcon,
			nothingFoundMessage,
			unstyled,
			labelId: label ? `${_id}-label` : void 0,
			"aria-label": label ? void 0 : others["aria-label"],
			renderOption,
			scrollAreaProps
		})]
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.HiddenInput, {
		name,
		valuesDivider: hiddenInputValuesDivider,
		value: _value,
		form,
		disabled,
		...hiddenInputProps
	})] });
});
MultiSelect.classes = {
	...InputBase.classes,
	...Combobox.classes
};
MultiSelect.displayName = "@mantine/core/MultiSelect";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NativeSelect/NativeSelectOption.mjs
function isGroup(input) {
	return "group" in input;
}
function NativeSelectOption({ data }) {
	if (isGroup(data)) {
		const items = data.items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NativeSelectOption, { data: item }, item.value));
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("optgroup", {
			label: data.group,
			children: items
		});
	}
	const { value, label,...others } = data;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", {
		value: data.value,
		...others,
		children: data.label
	}, data.value);
}
NativeSelectOption.displayName = "@mantine/core/NativeSelectOption";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NativeSelect/NativeSelect.mjs
const defaultProps$52 = { rightSectionPointerEvents: "none" };
const NativeSelect = factory((props, ref) => {
	const { data, children, size: size$3, error: error$1, rightSection, unstyled,...others } = useProps("NativeSelect", defaultProps$52, props);
	const options$1 = getParsedComboboxData(data).map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NativeSelectOption, { data: item }, index$4));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: "select",
		ref,
		...others,
		__staticSelector: "NativeSelect",
		size: size$3,
		pointer: true,
		error: error$1,
		unstyled,
		rightSection: rightSection || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ComboboxChevron, {
			size: size$3,
			error: error$1,
			unstyled
		}),
		children: children || options$1
	});
});
NativeSelect.classes = InputBase.classes;
NativeSelect.displayName = "@mantine/core/NativeSelect";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NavLink/NavLink.module.css.mjs
var classes$29 = {
	"root": "m_f0824112",
	"description": "m_57492dcc",
	"section": "m_690090b5",
	"label": "m_1f6ac4c4",
	"body": "m_f07af9d2",
	"children": "m_e17b862f",
	"chevron": "m_1fd8a00b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NavLink/NavLink.mjs
const defaultProps$51 = {};
const varsResolver$30 = createVarsResolver((theme, { variant, color, childrenOffset, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		variant: variant || "light",
		autoContrast
	});
	return {
		root: {
			"--nl-bg": color || variant ? colors.background : void 0,
			"--nl-hover": color || variant ? colors.hover : void 0,
			"--nl-color": color || variant ? colors.color : void 0
		},
		children: { "--nl-offset": getSpacing(childrenOffset) }
	};
});
const NavLink = polymorphicFactory((_props, ref) => {
	const props = useProps("NavLink", defaultProps$51, _props);
	const { classNames, className, style, styles, unstyled, vars, opened, defaultOpened, onChange, children, onClick, active, disabled, leftSection, rightSection, label, description, disableRightSectionRotation, noWrap, childrenOffset, onKeyDown, autoContrast, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "NavLink",
		props,
		classes: classes$29,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$30
	});
	const [_opened, setOpened] = useUncontrolled({
		value: opened,
		defaultValue: defaultOpened,
		finalValue: false,
		onChange
	});
	const withChildren = !!children;
	const handleClick = (event) => {
		onClick?.(event);
		if (withChildren) {
			event.preventDefault();
			setOpened(!_opened);
		}
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...getStyles$1("root"),
		component: "a",
		ref,
		onClick: handleClick,
		onKeyDown: (event) => {
			onKeyDown?.(event);
			if (event.nativeEvent.code === "Space" && withChildren) {
				event.preventDefault();
				setOpened(!_opened);
			}
		},
		unstyled,
		mod: [{
			disabled,
			active,
			expanded: _opened
		}, mod],
		...others,
		children: [
			leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				...getStyles$1("section"),
				mod: { position: "left" },
				children: leftSection
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
				...getStyles$1("body"),
				mod: { "no-wrap": noWrap },
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					...getStyles$1("label"),
					children: label
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					mod: { active },
					...getStyles$1("description"),
					children: description
				})]
			}),
			(withChildren || rightSection !== void 0) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				...getStyles$1("section"),
				component: "span",
				mod: {
					rotate: _opened && !disableRightSectionRotation,
					position: "right"
				},
				children: withChildren ? rightSection !== void 0 ? rightSection : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionChevron, { ...getStyles$1("chevron") }) : rightSection
			})
		]
	}), withChildren && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collapse, {
		in: _opened,
		...getStyles$1("collapse"),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...getStyles$1("children"),
			children
		})
	})] });
});
NavLink.classes = classes$29;
NavLink.displayName = "@mantine/core/NavLink";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Notification/Notification.module.css.mjs
var classes$28 = {
	"root": "m_a513464",
	"icon": "m_a4ceffb",
	"loader": "m_b0920b15",
	"body": "m_a49ed24",
	"title": "m_3feedf16",
	"description": "m_3d733a3a",
	"closeButton": "m_919a4d88"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Notification/Notification.mjs
const defaultProps$50 = { withCloseButton: true };
const varsResolver$29 = createVarsResolver((theme, { radius, color }) => ({ root: {
	"--notification-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--notification-color": color ? getThemeColor(color, theme) : void 0
} }));
const Notification = factory((_props, ref) => {
	const props = useProps("Notification", defaultProps$50, _props);
	const { className, color, radius, loading, withCloseButton, withBorder, title, icon, children, onClose, closeButtonProps, classNames, style, styles, unstyled, variant, vars, mod, loaderProps, role,...others } = props;
	const getStyles$1 = useStyles({
		name: "Notification",
		classes: classes$28,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$29
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("root"),
		mod: [{
			"data-with-icon": !!icon || loading,
			"data-with-border": withBorder
		}, mod],
		ref,
		variant,
		role: role || "alert",
		...others,
		children: [
			icon && !loading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("icon"),
				children: icon
			}),
			loading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
				size: 28,
				color,
				...loaderProps,
				...getStyles$1("loader")
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				...getStyles$1("body"),
				children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...getStyles$1("title"),
					children: title
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					...getStyles$1("description"),
					mod: { "data-with-title": !!title },
					children
				})]
			}),
			withCloseButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
				iconSize: 16,
				color: "gray",
				...closeButtonProps,
				unstyled,
				onClick: onClose,
				...getStyles$1("closeButton")
			})
		]
	});
});
Notification.classes = classes$28;
Notification.displayName = "@mantine/core/Notification";

//#endregion
//#region node_modules/.pnpm/react-number-format@5.4.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/react-number-format/dist/react-number-format.es.js
/******************************************************************************

Copyright (c) Microsoft Corporation.



Permission to use, copy, modify, and/or distribute this software for any

purpose with or without fee is hereby granted.



THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH

REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY

AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,

INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

PERFORMANCE OF THIS SOFTWARE.

***************************************************************************** */
function __rest(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
}
var SourceType;
(function(SourceType$1) {
	SourceType$1["event"] = "event";
	SourceType$1["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop$1() {}
function memoizeOnce(cb) {
	var lastArgs;
	var lastValue = void 0;
	return function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		if (lastArgs && args.length === lastArgs.length && args.every(function(value, index$4) {
			return value === lastArgs[index$4];
		})) return lastValue;
		lastArgs = args;
		lastValue = cb.apply(void 0, args);
		return lastValue;
	};
}
function charIsNumber(char) {
	return !!(char || "").match(/\d/);
}
function isNil(val) {
	return val === null || val === void 0;
}
function isNanValue(val) {
	return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
	return isNil(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp(str) {
	return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
	switch (thousandsGroupStyle) {
		case "lakh": return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
		case "wan": return /(\d)(?=(\d{4})+(?!\d))/g;
		case "thousand":
		default: return /(\d)(?=(\d{3})+(?!\d))/g;
	}
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
	var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
	var index$4 = str.search(/[1-9]/);
	index$4 = index$4 === -1 ? str.length : index$4;
	return str.substring(0, index$4) + str.substring(index$4, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb) {
	var callbackRef = (0, import_react.useRef)(cb);
	callbackRef.current = cb;
	/**
	* initialize a persistent callback which never changes
	* through out the component lifecycle
	*/
	var persistentCbRef = (0, import_react.useRef)(function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		return callbackRef.current.apply(callbackRef, args);
	});
	return persistentCbRef.current;
}
function splitDecimal(numStr, allowNegative) {
	if (allowNegative === void 0) allowNegative = true;
	var hasNegation = numStr[0] === "-";
	var addNegation = hasNegation && allowNegative;
	numStr = numStr.replace("-", "");
	var parts = numStr.split(".");
	var beforeDecimal = parts[0];
	var afterDecimal = parts[1] || "";
	return {
		beforeDecimal,
		afterDecimal,
		hasNegation,
		addNegation
	};
}
function fixLeadingZero(numStr) {
	if (!numStr) return numStr;
	var isNegative = numStr[0] === "-";
	if (isNegative) numStr = numStr.substring(1, numStr.length);
	var parts = numStr.split(".");
	var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
	var afterDecimal = parts[1] || "";
	return (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
/**
* limit decimal numbers to given scale
* Not used .fixedTo because that will break with big numbers
*/
function limitToScale(numStr, scale, fixedDecimalScale) {
	var str = "";
	var filler = fixedDecimalScale ? "0" : "";
	for (var i = 0; i <= scale - 1; i++) str += numStr[i] || filler;
	return str;
}
function repeat(str, count$1) {
	return Array(count$1 + 1).join(str);
}
function toNumericString(num) {
	var _num = num + "";
	var sign = _num[0] === "-" ? "-" : "";
	if (sign) _num = _num.substring(1);
	var ref = _num.split(/[eE]/g);
	var coefficient = ref[0];
	var exponent = ref[1];
	exponent = Number(exponent);
	if (!exponent) return sign + coefficient;
	coefficient = coefficient.replace(".", "");
	/**
	* for scientific notation the current decimal index will be after first number (index 0)
	* So effective decimal index will always be 1 + exponent value
	*/
	var decimalIndex = 1 + exponent;
	var coffiecientLn = coefficient.length;
	if (decimalIndex < 0) coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
	else if (decimalIndex >= coffiecientLn) coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
	else coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
	return sign + coefficient;
}
/**
* This method is required to round prop value to given scale.
* Not used .round or .fixedTo because that will break with big numbers
*/
function roundToPrecision(numStr, scale, fixedDecimalScale) {
	if (["", "-"].indexOf(numStr) !== -1) return numStr;
	var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
	var ref = splitDecimal(numStr);
	var beforeDecimal = ref.beforeDecimal;
	var afterDecimal = ref.afterDecimal;
	var hasNegation = ref.hasNegation;
	var floatValue = parseFloat("0." + (afterDecimal || "0"));
	var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
	var roundedDecimalParts = floatValueStr.split(".");
	var intPart = beforeDecimal;
	if (beforeDecimal && Number(roundedDecimalParts[0])) intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current, idx) {
		if (roundedStr.length > idx) return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
		return current + roundedStr;
	}, roundedDecimalParts[0]);
	var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
	var negation = hasNegation ? "-" : "";
	var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
	return "" + negation + intPart + decimalSeparator + decimalPart;
}
/** set the caret positon in an input field **/
function setCaretPosition(el, caretPos) {
	el.value = el.value;
	if (el !== null) {
		if (el.createTextRange) {
			var range = el.createTextRange();
			range.move("character", caretPos);
			range.select();
			return true;
		}
		if (el.selectionStart || el.selectionStart === 0) {
			el.focus();
			el.setSelectionRange(caretPos, caretPos);
			return true;
		}
		el.focus();
		return false;
	}
}
/**
* TODO: remove dependency of findChangeRange, findChangedRangeFromCaretPositions is better way to find what is changed
* currently this is mostly required by test and isCharacterSame util
* Given previous value and newValue it returns the index
* start - end to which values have changed.
* This function makes assumption about only consecutive
* characters are changed which is correct assumption for caret input.
*/
var findChangeRange = memoizeOnce(function(prevValue, newValue) {
	var i = 0, j = 0;
	var prevLength = prevValue.length;
	var newLength = newValue.length;
	while (prevValue[i] === newValue[i] && i < prevLength) i++;
	while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) j++;
	return {
		from: {
			start: i,
			end: prevLength - j
		},
		to: {
			start: i,
			end: newLength - j
		}
	};
});
var findChangedRangeFromCaretPositions = function(lastCaretPositions, currentCaretPosition) {
	var startPosition = Math.min(lastCaretPositions.selectionStart, currentCaretPosition);
	return {
		from: {
			start: startPosition,
			end: lastCaretPositions.selectionEnd
		},
		to: {
			start: startPosition,
			end: currentCaretPosition
		}
	};
};
function clamp$1(num, min$1, max$1) {
	return Math.min(Math.max(num, min$1), max$1);
}
function geInputCaretPosition(el) {
	return Math.max(el.selectionStart, el.selectionEnd);
}
function addInputMode() {
	return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
	return {
		from: {
			start: 0,
			end: 0
		},
		to: {
			start: 0,
			end: value.length
		},
		lastValue: ""
	};
}
function defaultIsCharacterSame(ref) {
	var currentValue = ref.currentValue;
	var formattedValue = ref.formattedValue;
	var currentValueIndex = ref.currentValueIndex;
	var formattedValueIndex = ref.formattedValueIndex;
	return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, isCharacterSame) {
	if (isCharacterSame === void 0) isCharacterSame = defaultIsCharacterSame;
	/**
	* if something got inserted on empty value, add the formatted character before the current value,
	* This is to avoid the case where typed character is present on format characters
	*/
	var firstAllowedPosition = boundary.findIndex(function(b) {
		return b;
	});
	var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
	if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
		lastFormattedValue = prefixFormat;
		curValue = prefixFormat + curValue;
		curCaretPos = curCaretPos + prefixFormat.length;
	}
	var curValLn = curValue.length;
	var formattedValueLn = newFormattedValue.length;
	var addedIndexMap = {};
	var indexMap = new Array(curValLn);
	for (var i = 0; i < curValLn; i++) {
		indexMap[i] = -1;
		for (var j = 0, jLn = formattedValueLn; j < jLn; j++) {
			var isCharSame = isCharacterSame({
				currentValue: curValue,
				lastValue: lastFormattedValue,
				formattedValue: newFormattedValue,
				currentValueIndex: i,
				formattedValueIndex: j
			});
			if (isCharSame && addedIndexMap[j] !== true) {
				indexMap[i] = j;
				addedIndexMap[j] = true;
				break;
			}
		}
	}
	/**
	* For current caret position find closest characters (left and right side)
	* which are properly mapped to formatted value.
	* The idea is that the new caret position will exist always in the boundary of
	* that mapped index
	*/
	var pos = curCaretPos;
	while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) pos++;
	var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
	pos = curCaretPos - 1;
	while (pos > 0 && indexMap[pos] === -1) pos--;
	var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
	/**
	* case where a char is added on suffix and removed from middle, example 2sq345 becoming $2,345 sq
	* there is still a mapping but the order of start index and end index is changed
	*/
	if (startIndex > endIndex) return endIndex;
	/**
	* given the current caret position if it closer to startIndex
	* keep the new caret position on start index or keep it closer to endIndex
	*/
	return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value, caretPos, boundary, direction) {
	var valLn = value.length;
	caretPos = clamp$1(caretPos, 0, valLn);
	if (direction === "left") {
		while (caretPos >= 0 && !boundary[caretPos]) caretPos--;
		if (caretPos === -1) caretPos = boundary.indexOf(true);
	} else {
		while (caretPos <= valLn && !boundary[caretPos]) caretPos++;
		if (caretPos > valLn) caretPos = boundary.lastIndexOf(true);
	}
	if (caretPos === -1) caretPos = valLn;
	return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
	var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
		return true;
	});
	for (var i = 0, ln = boundaryAry.length; i < ln; i++) boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));
	return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format$1, removeFormatting$1, onValueChange) {
	if (onValueChange === void 0) onValueChange = noop$1;
	var getValues = usePersistentCallback(function(value$1, valueIsNumericString$1) {
		var formattedValue, numAsString;
		if (isNotValidValue(value$1)) {
			numAsString = "";
			formattedValue = "";
		} else if (typeof value$1 === "number" || valueIsNumericString$1) {
			numAsString = typeof value$1 === "number" ? toNumericString(value$1) : value$1;
			formattedValue = format$1(numAsString);
		} else {
			numAsString = removeFormatting$1(value$1, void 0);
			formattedValue = format$1(numAsString);
		}
		return {
			formattedValue,
			numAsString
		};
	});
	var ref = (0, import_react.useState)(function() {
		return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);
	});
	var values$1 = ref[0];
	var setValues = ref[1];
	var _onValueChange = function(newValues$1, sourceInfo) {
		if (newValues$1.formattedValue !== values$1.formattedValue) setValues({
			formattedValue: newValues$1.formattedValue,
			numAsString: newValues$1.value
		});
		onValueChange(newValues$1, sourceInfo);
	};
	var _value = value;
	var _valueIsNumericString = valueIsNumericString;
	if (isNil(value)) {
		_value = values$1.numAsString;
		_valueIsNumericString = true;
	}
	var newValues = getValues(_value, _valueIsNumericString);
	(0, import_react.useMemo)(function() {
		setValues(newValues);
	}, [newValues.formattedValue]);
	return [values$1, _onValueChange];
}
function defaultRemoveFormatting(value) {
	return value.replace(/[^0-9]/g, "");
}
function defaultFormat(value) {
	return value;
}
function NumberFormatBase(props) {
	var type = props.type;
	if (type === void 0) type = "text";
	var displayType = props.displayType;
	if (displayType === void 0) displayType = "input";
	var customInput = props.customInput;
	var renderText = props.renderText;
	var getInputRef = props.getInputRef;
	var format$1 = props.format;
	if (format$1 === void 0) format$1 = defaultFormat;
	var removeFormatting$1 = props.removeFormatting;
	if (removeFormatting$1 === void 0) removeFormatting$1 = defaultRemoveFormatting;
	var defaultValue = props.defaultValue;
	var valueIsNumericString = props.valueIsNumericString;
	var onValueChange = props.onValueChange;
	var isAllowed = props.isAllowed;
	var onChange = props.onChange;
	if (onChange === void 0) onChange = noop$1;
	var onKeyDown = props.onKeyDown;
	if (onKeyDown === void 0) onKeyDown = noop$1;
	var onMouseUp = props.onMouseUp;
	if (onMouseUp === void 0) onMouseUp = noop$1;
	var onFocus = props.onFocus;
	if (onFocus === void 0) onFocus = noop$1;
	var onBlur = props.onBlur;
	if (onBlur === void 0) onBlur = noop$1;
	var propValue = props.value;
	var getCaretBoundary$1 = props.getCaretBoundary;
	if (getCaretBoundary$1 === void 0) getCaretBoundary$1 = caretUnknownFormatBoundary;
	var isValidInputCharacter = props.isValidInputCharacter;
	if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;
	var isCharacterSame = props.isCharacterSame;
	var otherProps = __rest(props, [
		"type",
		"displayType",
		"customInput",
		"renderText",
		"getInputRef",
		"format",
		"removeFormatting",
		"defaultValue",
		"valueIsNumericString",
		"onValueChange",
		"isAllowed",
		"onChange",
		"onKeyDown",
		"onMouseUp",
		"onFocus",
		"onBlur",
		"value",
		"getCaretBoundary",
		"isValidInputCharacter",
		"isCharacterSame"
	]);
	var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format$1, removeFormatting$1, onValueChange);
	var ref_0 = ref[0];
	var formattedValue = ref_0.formattedValue;
	var numAsString = ref_0.numAsString;
	var onFormattedValueChange = ref[1];
	var caretPositionBeforeChange = (0, import_react.useRef)();
	var lastUpdatedValue = (0, import_react.useRef)({
		formattedValue,
		numAsString
	});
	var _onValueChange = function(values$1, source) {
		lastUpdatedValue.current = {
			formattedValue: values$1.formattedValue,
			numAsString: values$1.value
		};
		onFormattedValueChange(values$1, source);
	};
	var ref$1 = (0, import_react.useState)(false);
	var mounted = ref$1[0];
	var setMounted = ref$1[1];
	var focusedElm = (0, import_react.useRef)(null);
	var timeout = (0, import_react.useRef)({
		setCaretTimeout: null,
		focusTimeout: null
	});
	(0, import_react.useEffect)(function() {
		setMounted(true);
		return function() {
			clearTimeout(timeout.current.setCaretTimeout);
			clearTimeout(timeout.current.focusTimeout);
		};
	}, []);
	var _format = format$1;
	var getValueObject = function(formattedValue$1, numAsString$1) {
		var floatValue = parseFloat(numAsString$1);
		return {
			formattedValue: formattedValue$1,
			value: numAsString$1,
			floatValue: isNaN(floatValue) ? void 0 : floatValue
		};
	};
	var setPatchedCaretPosition = function(el, caretPos, currentValue) {
		if (el.selectionStart === 0 && el.selectionEnd === el.value.length) return;
		setCaretPosition(el, caretPos);
		timeout.current.setCaretTimeout = setTimeout(function() {
			if (el.value === currentValue && el.selectionStart !== caretPos) setCaretPosition(el, caretPos);
		}, 0);
	};
	var correctCaretPosition = function(value, caretPos, direction) {
		return getCaretPosInBoundary(value, caretPos, getCaretBoundary$1(value), direction);
	};
	var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
		var caretBoundary = getCaretBoundary$1(newFormattedValue);
		var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
		updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
		return updatedCaretPos;
	};
	var updateValueAndCaretPosition = function(params) {
		var newFormattedValue = params.formattedValue;
		if (newFormattedValue === void 0) newFormattedValue = "";
		var input = params.input;
		var source = params.source;
		var event = params.event;
		var numAsString$1 = params.numAsString;
		var caretPos;
		if (input) {
			var inputValue = params.inputValue || input.value;
			var currentCaretPosition$1 = geInputCaretPosition(input);
			/**
			* set the value imperatively, this is required for IE fix
			* This is also required as if new caret position is beyond the previous value.
			* Caret position will not be set correctly
			*/
			input.value = newFormattedValue;
			caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition$1);
			if (caretPos !== void 0) setPatchedCaretPosition(input, caretPos, newFormattedValue);
		}
		if (newFormattedValue !== formattedValue) _onValueChange(getValueObject(newFormattedValue, numAsString$1), {
			event,
			source
		});
	};
	/**
	* if the formatted value is not synced to parent, or if the formatted value is different from last synced value sync it
	* if the formatting props is removed, in which case last formatted value will be different from the numeric string value
	* in such case we need to inform the parent.
	*/
	(0, import_react.useEffect)(function() {
		var ref$2 = lastUpdatedValue.current;
		var lastFormattedValue = ref$2.formattedValue;
		var lastNumAsString = ref$2.numAsString;
		if (formattedValue !== lastFormattedValue || numAsString !== lastNumAsString) _onValueChange(getValueObject(formattedValue, numAsString), {
			event: void 0,
			source: SourceType.props
		});
	}, [formattedValue, numAsString]);
	var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : void 0;
	var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
	useIsomorphicLayoutEffect$1(function() {
		var input = focusedElm.current;
		if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
			var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
			/**
			* set the value imperatively, as we set the caret position as well imperatively.
			* This is to keep value and caret position in sync
			*/
			input.value = formattedValue;
			setPatchedCaretPosition(input, caretPos, formattedValue);
		}
	}, [formattedValue]);
	var formatInputValue = function(inputValue, event, source) {
		var input = event.target;
		var changeRange = caretPositionBeforeChange.current ? findChangedRangeFromCaretPositions(caretPositionBeforeChange.current, input.selectionEnd) : findChangeRange(formattedValue, inputValue);
		var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
		var _numAsString = removeFormatting$1(inputValue, changeMeta);
		var _formattedValue = _format(_numAsString);
		_numAsString = removeFormatting$1(_formattedValue, void 0);
		if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
			var input$1 = event.target;
			var currentCaretPosition$1 = geInputCaretPosition(input$1);
			var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition$1);
			input$1.value = formattedValue;
			setPatchedCaretPosition(input$1, caretPos, formattedValue);
			return false;
		}
		updateValueAndCaretPosition({
			formattedValue: _formattedValue,
			numAsString: _numAsString,
			inputValue,
			event,
			source,
			input: event.target
		});
		return true;
	};
	var setCaretPositionInfoBeforeChange = function(el, endOffset) {
		if (endOffset === void 0) endOffset = 0;
		var selectionStart = el.selectionStart;
		var selectionEnd = el.selectionEnd;
		caretPositionBeforeChange.current = {
			selectionStart,
			selectionEnd: selectionEnd + endOffset
		};
	};
	var _onChange = function(e) {
		var el = e.target;
		var inputValue = el.value;
		var changed = formatInputValue(inputValue, e, SourceType.event);
		if (changed) onChange(e);
		caretPositionBeforeChange.current = void 0;
	};
	var _onKeyDown = function(e) {
		var el = e.target;
		var key = e.key;
		var selectionStart = el.selectionStart;
		var selectionEnd = el.selectionEnd;
		var value = el.value;
		if (value === void 0) value = "";
		var expectedCaretPosition;
		if (key === "ArrowLeft" || key === "Backspace") expectedCaretPosition = Math.max(selectionStart - 1, 0);
		else if (key === "ArrowRight") expectedCaretPosition = Math.min(selectionStart + 1, value.length);
		else if (key === "Delete") expectedCaretPosition = selectionStart;
		var endOffset = 0;
		if (key === "Delete" && selectionStart === selectionEnd) endOffset = 1;
		var isArrowKey = key === "ArrowLeft" || key === "ArrowRight";
		if (expectedCaretPosition === void 0 || selectionStart !== selectionEnd && !isArrowKey) {
			onKeyDown(e);
			setCaretPositionInfoBeforeChange(el, endOffset);
			return;
		}
		var newCaretPosition = expectedCaretPosition;
		if (isArrowKey) {
			var direction = key === "ArrowLeft" ? "left" : "right";
			newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);
			if (newCaretPosition !== expectedCaretPosition) e.preventDefault();
		} else if (key === "Delete" && !isValidInputCharacter(value[expectedCaretPosition])) newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "right");
		else if (key === "Backspace" && !isValidInputCharacter(value[expectedCaretPosition])) newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "left");
		if (newCaretPosition !== expectedCaretPosition) setPatchedCaretPosition(el, newCaretPosition, value);
		onKeyDown(e);
		setCaretPositionInfoBeforeChange(el, endOffset);
	};
	/** required to handle the caret position when click anywhere within the input **/
	var _onMouseUp = function(e) {
		var el = e.target;
		/**
		* NOTE: we have to give default value for value as in case when custom input is provided
		* value can come as undefined when nothing is provided on value prop.
		*/
		var correctCaretPositionIfRequired = function() {
			var selectionStart = el.selectionStart;
			var selectionEnd = el.selectionEnd;
			var value = el.value;
			if (value === void 0) value = "";
			if (selectionStart === selectionEnd) {
				var caretPosition = correctCaretPosition(value, selectionStart);
				if (caretPosition !== selectionStart) setPatchedCaretPosition(el, caretPosition, value);
			}
		};
		correctCaretPositionIfRequired();
		requestAnimationFrame(function() {
			correctCaretPositionIfRequired();
		});
		onMouseUp(e);
		setCaretPositionInfoBeforeChange(el);
	};
	var _onFocus = function(e) {
		if (e.persist) e.persist();
		var el = e.target;
		var currentTarget = e.currentTarget;
		focusedElm.current = el;
		timeout.current.focusTimeout = setTimeout(function() {
			var selectionStart = el.selectionStart;
			var selectionEnd = el.selectionEnd;
			var value = el.value;
			if (value === void 0) value = "";
			var caretPosition = correctCaretPosition(value, selectionStart);
			if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) setPatchedCaretPosition(el, caretPosition, value);
			onFocus(Object.assign(Object.assign({}, e), { currentTarget }));
		}, 0);
	};
	var _onBlur = function(e) {
		focusedElm.current = null;
		clearTimeout(timeout.current.focusTimeout);
		clearTimeout(timeout.current.setCaretTimeout);
		onBlur(e);
	};
	var inputMode = mounted && addInputMode() ? "numeric" : void 0;
	var inputProps = Object.assign({ inputMode }, otherProps, {
		type,
		value: formattedValue,
		onChange: _onChange,
		onKeyDown: _onKeyDown,
		onMouseUp: _onMouseUp,
		onFocus: _onFocus,
		onBlur: _onBlur
	});
	if (displayType === "text") return renderText ? import_react.default.createElement(import_react.default.Fragment, null, renderText(formattedValue, otherProps) || null) : import_react.default.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
	else if (customInput) {
		var CustomInput = customInput;
		return import_react.default.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
	}
	return import_react.default.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format(numStr, props) {
	var decimalScale = props.decimalScale;
	var fixedDecimalScale = props.fixedDecimalScale;
	var prefix = props.prefix;
	if (prefix === void 0) prefix = "";
	var suffix = props.suffix;
	if (suffix === void 0) suffix = "";
	var allowNegative = props.allowNegative;
	var thousandsGroupStyle = props.thousandsGroupStyle;
	if (thousandsGroupStyle === void 0) thousandsGroupStyle = "thousand";
	if (numStr === "" || numStr === "-") return numStr;
	var ref = getSeparators(props);
	var thousandSeparator = ref.thousandSeparator;
	var decimalSeparator = ref.decimalSeparator;
	/**
	* Keep the decimal separator
	* when decimalScale is not defined or non zero and the numStr has decimal in it
	* Or if decimalScale is > 0 and fixeDecimalScale is true (even if numStr has no decimal)
	*/
	var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
	var ref$1 = splitDecimal(numStr, allowNegative);
	var beforeDecimal = ref$1.beforeDecimal;
	var afterDecimal = ref$1.afterDecimal;
	var addNegation = ref$1.addNegation;
	if (decimalScale !== void 0) afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
	if (thousandSeparator) beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
	if (prefix) beforeDecimal = prefix + beforeDecimal;
	if (suffix) afterDecimal = afterDecimal + suffix;
	if (addNegation) beforeDecimal = "-" + beforeDecimal;
	numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
	return numStr;
}
function getSeparators(props) {
	var decimalSeparator = props.decimalSeparator;
	if (decimalSeparator === void 0) decimalSeparator = ".";
	var thousandSeparator = props.thousandSeparator;
	var allowedDecimalSeparators = props.allowedDecimalSeparators;
	if (thousandSeparator === true) thousandSeparator = ",";
	if (!allowedDecimalSeparators) allowedDecimalSeparators = [decimalSeparator, "."];
	return {
		decimalSeparator,
		thousandSeparator,
		allowedDecimalSeparators
	};
}
function handleNegation(value, allowNegative) {
	if (value === void 0) value = "";
	var negationRegex = new RegExp("(-)");
	var doubleNegationRegex = new RegExp("(-)(.)*(-)");
	var hasNegation = negationRegex.test(value);
	var removeNegation = doubleNegationRegex.test(value);
	value = value.replace(/-/g, "");
	if (hasNegation && !removeNegation && allowNegative) value = "-" + value;
	return value;
}
function getNumberRegex(decimalSeparator, global) {
	return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global ? "g" : void 0);
}
function isNumericString(val, prefix, suffix) {
	if (val === "") return true;
	return !(prefix === null || prefix === void 0 ? void 0 : prefix.match(/\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
	var assign;
	if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);
	var allowNegative = props.allowNegative;
	var prefix = props.prefix;
	if (prefix === void 0) prefix = "";
	var suffix = props.suffix;
	if (suffix === void 0) suffix = "";
	var decimalScale = props.decimalScale;
	var from = changeMeta.from;
	var to = changeMeta.to;
	var start = to.start;
	var end = to.end;
	var ref = getSeparators(props);
	var allowedDecimalSeparators = ref.allowedDecimalSeparators;
	var decimalSeparator = ref.decimalSeparator;
	var isBeforeDecimalSeparator = value[end] === decimalSeparator;
	/**
	* If only a number is added on empty input which matches with the prefix or suffix,
	* then don't remove it, just return the same
	*/
	if (charIsNumber(value) && (value === prefix || value === suffix) && changeMeta.lastValue === "") return value;
	/** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */
	if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {
		var separator = decimalScale === 0 ? "" : decimalSeparator;
		value = value.substring(0, start) + separator + value.substring(start + 1, value.length);
	}
	var stripNegation = function(value$1, start$1, end$1) {
		/**
		* if prefix starts with - we don't allow negative number to avoid confusion
		* if suffix starts with - and the value length is same as suffix length, then the - sign is from the suffix
		* In other cases, if the value starts with - then it is a negation
		*/
		var hasNegation$1 = false;
		var hasDoubleNegation = false;
		if (prefix.startsWith("-")) hasNegation$1 = false;
		else if (value$1.startsWith("--")) {
			hasNegation$1 = false;
			hasDoubleNegation = true;
		} else if (suffix.startsWith("-") && value$1.length === suffix.length) hasNegation$1 = false;
		else if (value$1[0] === "-") hasNegation$1 = true;
		var charsToRemove = hasNegation$1 ? 1 : 0;
		if (hasDoubleNegation) charsToRemove = 2;
		if (charsToRemove) {
			value$1 = value$1.substring(charsToRemove);
			start$1 -= charsToRemove;
			end$1 -= charsToRemove;
		}
		return {
			value: value$1,
			start: start$1,
			end: end$1,
			hasNegation: hasNegation$1
		};
	};
	var toMetadata = stripNegation(value, start, end);
	var hasNegation = toMetadata.hasNegation;
	assign = toMetadata, value = assign.value, start = assign.start, end = assign.end;
	var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);
	var fromStart = ref$1.start;
	var fromEnd = ref$1.end;
	var lastValue = ref$1.value;
	var updatedSuffixPart = value.substring(start, end);
	if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) value = lastValue;
	/**
	* remove prefix
	* Remove whole prefix part if its present on the value
	* If the prefix is partially deleted (in which case change start index will be less the prefix length)
	* Remove only partial part of prefix.
	*/
	var startIndex = 0;
	if (value.startsWith(prefix)) startIndex += prefix.length;
	else if (start < prefix.length) startIndex = start;
	value = value.substring(startIndex);
	end -= startIndex;
	/**
	* Remove suffix
	* Remove whole suffix part if its present on the value
	* If the suffix is partially deleted (in which case change end index will be greater than the suffixStartIndex)
	* remove the partial part of suffix
	*/
	var endIndex = value.length;
	var suffixStartIndex = value.length - suffix.length;
	if (value.endsWith(suffix)) endIndex = suffixStartIndex;
	else if (end > suffixStartIndex) endIndex = end;
	else if (end > value.length - suffix.length) endIndex = end;
	value = value.substring(0, endIndex);
	value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
	value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join("");
	var firstIndex = value.indexOf(decimalSeparator);
	value = value.replace(new RegExp(escapeRegExp(decimalSeparator), "g"), function(match, index$4) {
		return index$4 === firstIndex ? "." : "";
	});
	var ref$2 = splitDecimal(value, allowNegative);
	var beforeDecimal = ref$2.beforeDecimal;
	var afterDecimal = ref$2.afterDecimal;
	var addNegation = ref$2.addNegation;
	if (to.end - to.start < from.end - from.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) value = addNegation ? "-" : "";
	return value;
}
function getCaretBoundary(formattedValue, props) {
	var prefix = props.prefix;
	if (prefix === void 0) prefix = "";
	var suffix = props.suffix;
	if (suffix === void 0) suffix = "";
	var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
		return true;
	});
	var hasNegation = formattedValue[0] === "-";
	boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));
	var valLn = formattedValue.length;
	boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);
	return boundaryAry;
}
function validateAndUpdateProps(props) {
	var ref = getSeparators(props);
	var thousandSeparator = ref.thousandSeparator;
	var decimalSeparator = ref.decimalSeparator;
	var prefix = props.prefix;
	if (prefix === void 0) prefix = "";
	var allowNegative = props.allowNegative;
	if (allowNegative === void 0) allowNegative = true;
	if (thousandSeparator === decimalSeparator) throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + " (thousandSeparator = {true} is same as thousandSeparator = \",\")\n        decimalSeparator: " + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
	if (prefix.startsWith("-") && allowNegative) {
		console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix + "\n      allowNegative: " + allowNegative + "\n    ");
		allowNegative = false;
	}
	return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
	props = validateAndUpdateProps(props);
	var _decimalSeparator = props.decimalSeparator;
	var _allowedDecimalSeparators = props.allowedDecimalSeparators;
	var thousandsGroupStyle = props.thousandsGroupStyle;
	var suffix = props.suffix;
	var allowNegative = props.allowNegative;
	var allowLeadingZeros = props.allowLeadingZeros;
	var onKeyDown = props.onKeyDown;
	if (onKeyDown === void 0) onKeyDown = noop$1;
	var onBlur = props.onBlur;
	if (onBlur === void 0) onBlur = noop$1;
	var thousandSeparator = props.thousandSeparator;
	var decimalScale = props.decimalScale;
	var fixedDecimalScale = props.fixedDecimalScale;
	var prefix = props.prefix;
	if (prefix === void 0) prefix = "";
	var defaultValue = props.defaultValue;
	var value = props.value;
	var valueIsNumericString = props.valueIsNumericString;
	var onValueChange = props.onValueChange;
	var restProps = __rest(props, [
		"decimalSeparator",
		"allowedDecimalSeparators",
		"thousandsGroupStyle",
		"suffix",
		"allowNegative",
		"allowLeadingZeros",
		"onKeyDown",
		"onBlur",
		"thousandSeparator",
		"decimalScale",
		"fixedDecimalScale",
		"prefix",
		"defaultValue",
		"value",
		"valueIsNumericString",
		"onValueChange"
	]);
	var ref = getSeparators(props);
	var decimalSeparator = ref.decimalSeparator;
	var allowedDecimalSeparators = ref.allowedDecimalSeparators;
	var _format = function(numStr) {
		return format(numStr, props);
	};
	var _removeFormatting = function(inputValue, changeMeta) {
		return removeFormatting(inputValue, changeMeta, props);
	};
	var _value = isNil(value) ? defaultValue : value;
	var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix, suffix);
	if (!isNil(value)) _valueIsNumericString = _valueIsNumericString || typeof value === "number";
	else if (!isNil(defaultValue)) _valueIsNumericString = _valueIsNumericString || typeof defaultValue === "number";
	var roundIncomingValueToPrecision = function(value$1) {
		if (isNotValidValue(value$1)) return value$1;
		if (typeof value$1 === "number") value$1 = toNumericString(value$1);
		/**
		* only round numeric or float string values coming through props,
		* we don't need to do it for onChange events, as we want to prevent typing there
		*/
		if (_valueIsNumericString && typeof decimalScale === "number") return roundToPrecision(value$1, decimalScale, Boolean(fixedDecimalScale));
		return value$1;
	};
	var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
	var ref$1_0 = ref$1[0];
	var numAsString = ref$1_0.numAsString;
	var formattedValue = ref$1_0.formattedValue;
	var _onValueChange = ref$1[1];
	var _onKeyDown = function(e) {
		var el = e.target;
		var key = e.key;
		var selectionStart = el.selectionStart;
		var selectionEnd = el.selectionEnd;
		var value$1 = el.value;
		if (value$1 === void 0) value$1 = "";
		if ((key === "Backspace" || key === "Delete") && selectionEnd < prefix.length) {
			e.preventDefault();
			return;
		}
		if (selectionStart !== selectionEnd) {
			onKeyDown(e);
			return;
		}
		if (key === "Backspace" && value$1[0] === "-" && selectionStart === prefix.length + 1 && allowNegative) setCaretPosition(el, 1);
		if (decimalScale && fixedDecimalScale) {
			if (key === "Backspace" && value$1[selectionStart - 1] === decimalSeparator) {
				setCaretPosition(el, selectionStart - 1);
				e.preventDefault();
			} else if (key === "Delete" && value$1[selectionStart] === decimalSeparator) e.preventDefault();
		}
		if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value$1[selectionStart] === decimalSeparator) setCaretPosition(el, selectionStart + 1);
		var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
		if (key === "Backspace" && value$1[selectionStart - 1] === _thousandSeparator) setCaretPosition(el, selectionStart - 1);
		if (key === "Delete" && value$1[selectionStart] === _thousandSeparator) setCaretPosition(el, selectionStart + 1);
		onKeyDown(e);
	};
	var _onBlur = function(e) {
		var _value$1 = numAsString;
		if (!_value$1.match(/\d/g)) _value$1 = "";
		if (!allowLeadingZeros) _value$1 = fixLeadingZero(_value$1);
		if (fixedDecimalScale && decimalScale) _value$1 = roundToPrecision(_value$1, decimalScale, fixedDecimalScale);
		if (_value$1 !== numAsString) {
			var formattedValue$1 = format(_value$1, props);
			_onValueChange({
				formattedValue: formattedValue$1,
				value: _value$1,
				floatValue: parseFloat(_value$1)
			}, {
				event: e,
				source: SourceType.event
			});
		}
		onBlur(e);
	};
	var isValidInputCharacter = function(inputChar) {
		if (inputChar === decimalSeparator) return true;
		return charIsNumber(inputChar);
	};
	var isCharacterSame = function(ref$2) {
		var currentValue = ref$2.currentValue;
		var lastValue = ref$2.lastValue;
		var formattedValue$1 = ref$2.formattedValue;
		var currentValueIndex = ref$2.currentValueIndex;
		var formattedValueIndex = ref$2.formattedValueIndex;
		var curChar = currentValue[currentValueIndex];
		var newChar = formattedValue$1[formattedValueIndex];
		/**
		* NOTE: as thousand separator and allowedDecimalSeparators can be same, we need to check on
		* typed range if we have typed any character from allowedDecimalSeparators, in that case we
		* consider different characters like , and . same within the range of updated value.
		*/
		var typedRange = findChangeRange(lastValue, currentValue);
		var to = typedRange.to;
		var getDecimalSeparatorIndex = function(value$1) {
			return _removeFormatting(value$1).indexOf(".") + prefix.length;
		};
		if (value === 0 && fixedDecimalScale && decimalScale && currentValue[to.start] === decimalSeparator && getDecimalSeparatorIndex(currentValue) < currentValueIndex && getDecimalSeparatorIndex(formattedValue$1) > formattedValueIndex) return false;
		if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) return true;
		return curChar === newChar;
	};
	return Object.assign(Object.assign({}, restProps), {
		value: formattedValue,
		valueIsNumericString: false,
		isValidInputCharacter,
		isCharacterSame,
		onValueChange: _onValueChange,
		format: _format,
		removeFormatting: _removeFormatting,
		getCaretBoundary: function(formattedValue$1) {
			return getCaretBoundary(formattedValue$1, props);
		},
		onKeyDown: _onKeyDown,
		onBlur: _onBlur
	});
}
function NumericFormat(props) {
	var numericFormatProps = useNumericFormat(props);
	return import_react.default.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NumberFormatter/NumberFormatter.mjs
const defaultProps$49 = {};
function NumberFormatter(_props) {
	const props = useProps("NumberFormatter", defaultProps$49, _props);
	const { value, defaultValue,...others } = props;
	if (value === void 0) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumericFormat, {
		displayType: "text",
		value,
		...others
	});
}
const extendNumberFormatter = (c) => c;
NumberFormatter.extend = extendNumberFormatter;
NumberFormatter.displayName = "@mantine/core/NumberFormatter";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NumberInput/NumberInputChevron.mjs
function NumberInputChevron({ direction, style,...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		style: {
			width: "var(--ni-chevron-size)",
			height: "var(--ni-chevron-size)",
			transform: direction === "up" ? "rotate(180deg)" : void 0,
			...style
		},
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NumberInput/NumberInput.module.css.mjs
var classes$27 = {
	"root": "m_e2f5cd4e",
	"controls": "m_95e17d22",
	"control": "m_80b4b171"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/NumberInput/NumberInput.mjs
const leadingDecimalZeroPattern = /^(0\.0*|-0(\.0*)?)$/;
const leadingZerosPattern = /^-?0\d+(\.\d+)?\.?$/;
function isNumberString(value) {
	return typeof value === "string" && value !== "" && !Number.isNaN(Number(value));
}
function canIncrement(value) {
	if (typeof value === "number") return value < Number.MAX_SAFE_INTEGER;
	return value === "" || isNumberString(value) && Number(value) < Number.MAX_SAFE_INTEGER;
}
function getDecimalPlaces(inputValue) {
	return inputValue.toString().replace(".", "").length;
}
function isValidNumber(floatValue, value) {
	return (typeof floatValue === "number" ? floatValue < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(floatValue))) && !Number.isNaN(floatValue) && getDecimalPlaces(value) < 14 && value !== "";
}
function isInRange(value, min$1, max$1) {
	if (value === void 0) return true;
	const minValid = min$1 === void 0 || value >= min$1;
	const maxValid = max$1 === void 0 || value <= max$1;
	return minValid && maxValid;
}
const defaultProps$48 = {
	step: 1,
	clampBehavior: "blur",
	allowDecimal: true,
	allowNegative: true,
	withKeyboardEvents: true,
	allowLeadingZeros: true,
	trimLeadingZeroesOnBlur: true,
	startValue: 0
};
const varsResolver$28 = createVarsResolver((_, { size: size$3 }) => ({ controls: { "--ni-chevron-size": getSize(size$3, "ni-chevron-size") } }));
function clampAndSanitizeInput(sanitizedValue, max$1, min$1) {
	const replaced = sanitizedValue.toString().replace(/^0+/, "");
	const parsedValue = parseFloat(replaced);
	if (Number.isNaN(parsedValue)) return replaced;
	else if (parsedValue > Number.MAX_SAFE_INTEGER) return max$1 !== void 0 ? String(max$1) : replaced;
	return clamp(parsedValue, min$1, max$1);
}
const NumberInput = factory((_props, ref) => {
	const props = useProps("NumberInput", defaultProps$48, _props);
	const { className, classNames, styles, unstyled, vars, onChange, onValueChange, value, defaultValue, max: max$1, min: min$1, step, hideControls, rightSection, isAllowed, clampBehavior, onBlur, allowDecimal, decimalScale, onKeyDown, onKeyDownCapture, handlersRef, startValue, disabled, rightSectionPointerEvents, allowNegative, readOnly, size: size$3, rightSectionWidth, stepHoldInterval, stepHoldDelay, allowLeadingZeros, withKeyboardEvents, trimLeadingZeroesOnBlur,...others } = props;
	const getStyles$1 = useStyles({
		name: "NumberInput",
		classes: classes$27,
		props,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$28
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const shouldUseStepInterval = stepHoldDelay !== void 0 && stepHoldInterval !== void 0;
	const inputRef = (0, import_react.useRef)(null);
	const onStepTimeoutRef = (0, import_react.useRef)(null);
	const stepCountRef = (0, import_react.useRef)(0);
	const handleValueChange = (payload, event) => {
		if (event.source === "event") setValue(isValidNumber(payload.floatValue, payload.value) && !leadingDecimalZeroPattern.test(payload.value) && !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) ? payload.floatValue : payload.value);
		onValueChange?.(payload, event);
	};
	const getDecimalPlaces2 = (inputValue) => {
		const match = String(inputValue).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
		if (!match) return 0;
		return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
	};
	const adjustCursor = (position) => {
		if (inputRef.current && typeof position !== "undefined") inputRef.current.setSelectionRange(position, position);
	};
	const incrementRef = (0, import_react.useRef)(noop);
	incrementRef.current = () => {
		if (!canIncrement(_value)) return;
		let val;
		const currentValuePrecision = getDecimalPlaces2(_value);
		const stepPrecision = getDecimalPlaces2(step);
		const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
		const factor = 10 ** maxPrecision;
		if (!isNumberString(_value) && (typeof _value !== "number" || Number.isNaN(_value))) val = clamp(startValue, min$1, max$1);
		else if (max$1 !== void 0) {
			const incrementedValue = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
			val = incrementedValue <= max$1 ? incrementedValue : max$1;
		} else val = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
		const formattedValue = val.toFixed(maxPrecision);
		setValue(parseFloat(formattedValue));
		onValueChange?.({
			floatValue: parseFloat(formattedValue),
			formattedValue,
			value: formattedValue
		}, { source: "increment" });
		setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
	};
	const decrementRef = (0, import_react.useRef)(noop);
	decrementRef.current = () => {
		if (!canIncrement(_value)) return;
		let val;
		const minValue = min$1 !== void 0 ? min$1 : !allowNegative ? 0 : Number.MIN_SAFE_INTEGER;
		const currentValuePrecision = getDecimalPlaces2(_value);
		const stepPrecision = getDecimalPlaces2(step);
		const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
		const factor = 10 ** maxPrecision;
		if (!isNumberString(_value) && typeof _value !== "number" || Number.isNaN(_value)) val = clamp(startValue, minValue, max$1);
		else {
			const decrementedValue = (Math.round(Number(_value) * factor) - Math.round(step * factor)) / factor;
			val = minValue !== void 0 && decrementedValue < minValue ? minValue : decrementedValue;
		}
		const formattedValue = val.toFixed(maxPrecision);
		setValue(parseFloat(formattedValue));
		onValueChange?.({
			floatValue: parseFloat(formattedValue),
			formattedValue,
			value: formattedValue
		}, { source: "decrement" });
		setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
	};
	const handleKeyDown = (event) => {
		onKeyDown?.(event);
		if (readOnly || !withKeyboardEvents) return;
		if (event.key === "ArrowUp") {
			event.preventDefault();
			incrementRef.current();
		}
		if (event.key === "ArrowDown") {
			event.preventDefault();
			decrementRef.current();
		}
	};
	const handleKeyDownCapture = (event) => {
		onKeyDownCapture?.(event);
		if (event.key === "Backspace") {
			const input = inputRef.current;
			if (input.selectionStart === 0 && input.selectionStart === input.selectionEnd) {
				event.preventDefault();
				window.setTimeout(() => adjustCursor(0), 0);
			}
		}
	};
	const handleBlur = (event) => {
		let sanitizedValue = _value;
		if (clampBehavior === "blur" && typeof sanitizedValue === "number") sanitizedValue = clamp(sanitizedValue, min$1, max$1);
		if (trimLeadingZeroesOnBlur && typeof sanitizedValue === "string" && getDecimalPlaces2(sanitizedValue) < 15) sanitizedValue = clampAndSanitizeInput(sanitizedValue, max$1, min$1);
		if (_value !== sanitizedValue) setValue(sanitizedValue);
		onBlur?.(event);
	};
	assignRef(handlersRef, {
		increment: incrementRef.current,
		decrement: decrementRef.current
	});
	const onStepHandleChange = (isIncrement) => {
		if (isIncrement) incrementRef.current();
		else decrementRef.current();
		stepCountRef.current += 1;
	};
	const onStepLoop = (isIncrement) => {
		onStepHandleChange(isIncrement);
		if (shouldUseStepInterval) {
			const interval = typeof stepHoldInterval === "number" ? stepHoldInterval : stepHoldInterval(stepCountRef.current);
			onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);
		}
	};
	const onStep = (event, isIncrement) => {
		event.preventDefault();
		inputRef.current?.focus();
		onStepHandleChange(isIncrement);
		if (shouldUseStepInterval) onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);
	};
	const onStepDone = () => {
		if (onStepTimeoutRef.current) window.clearTimeout(onStepTimeoutRef.current);
		onStepTimeoutRef.current = null;
		stepCountRef.current = 0;
	};
	const controls = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		...getStyles$1("controls"),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			...getStyles$1("control"),
			tabIndex: -1,
			"aria-hidden": true,
			disabled: disabled || typeof _value === "number" && max$1 !== void 0 && _value >= max$1,
			mod: { direction: "up" },
			onMouseDown: (event) => event.preventDefault(),
			onPointerDown: (event) => {
				onStep(event, true);
			},
			onPointerUp: onStepDone,
			onPointerLeave: onStepDone,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumberInputChevron, { direction: "up" })
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			...getStyles$1("control"),
			tabIndex: -1,
			"aria-hidden": true,
			disabled: disabled || typeof _value === "number" && min$1 !== void 0 && _value <= min$1,
			mod: { direction: "down" },
			onMouseDown: (event) => event.preventDefault(),
			onPointerDown: (event) => {
				onStep(event, false);
			},
			onPointerUp: onStepDone,
			onPointerLeave: onStepDone,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumberInputChevron, { direction: "down" })
		})]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: NumericFormat,
		allowNegative,
		className: clsx_default(classes$27.root, className),
		size: size$3,
		...others,
		readOnly,
		disabled,
		value: _value,
		getInputRef: useMergedRef(ref, inputRef),
		onValueChange: handleValueChange,
		rightSection: hideControls || readOnly || !canIncrement(_value) ? rightSection : rightSection || controls,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		__staticSelector: "NumberInput",
		decimalScale: allowDecimal ? decimalScale : 0,
		onKeyDown: handleKeyDown,
		onKeyDownCapture: handleKeyDownCapture,
		rightSectionPointerEvents: rightSectionPointerEvents ?? (disabled ? "none" : void 0),
		rightSectionWidth: rightSectionWidth ?? `var(--ni-right-section-width-${size$3 || "sm"})`,
		allowLeadingZeros,
		onBlur: handleBlur,
		isAllowed: (val) => {
			if (clampBehavior === "strict") {
				if (isAllowed) return isAllowed(val) && isInRange(val.floatValue, min$1, max$1);
				return isInRange(val.floatValue, min$1, max$1);
			}
			return isAllowed ? isAllowed(val) : true;
		}
	});
});
NumberInput.classes = {
	...InputBase.classes,
	...classes$27
};
NumberInput.displayName = "@mantine/core/NumberInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/Pagination.context.mjs
const [PaginationProvider, usePaginationContext] = createSafeContext("Pagination.Root component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/Pagination.module.css.mjs
var classes$26 = {
	"root": "m_4addd315",
	"control": "m_326d024a",
	"dots": "m_4ad7767d"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/PaginationControl/PaginationControl.mjs
const defaultProps$47 = { withPadding: true };
const PaginationControl = factory((_props, ref) => {
	const props = useProps("PaginationControl", defaultProps$47, _props);
	const { classNames, className, style, styles, vars, active, disabled, withPadding, mod,...others } = props;
	const ctx = usePaginationContext();
	const _disabled = disabled || ctx.disabled;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
		ref,
		disabled: _disabled,
		mod: [{
			active,
			disabled: _disabled,
			"with-padding": withPadding
		}, mod],
		...ctx.getStyles("control", {
			className,
			style,
			classNames,
			styles,
			active: !_disabled
		}),
		...others
	});
});
PaginationControl.classes = classes$26;
PaginationControl.displayName = "@mantine/core/PaginationControl";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/Pagination.icons.mjs
function PaginationIcon({ style, children, path,...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		viewBox: "0 0 16 16",
		xmlns: "http://www.w3.org/2000/svg",
		style: {
			width: "calc(var(--pagination-control-size) / 1.8)",
			height: "calc(var(--pagination-control-size) / 1.8)",
			...style
		},
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: path,
			fill: "currentColor"
		})
	});
}
const PaginationNextIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationIcon, {
	...props,
	path: "M8.781 8l-3.3-3.3.943-.943L10.667 8l-4.243 4.243-.943-.943 3.3-3.3z"
});
const PaginationPreviousIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationIcon, {
	...props,
	path: "M7.219 8l3.3 3.3-.943.943L5.333 8l4.243-4.243.943.943-3.3 3.3z"
});
const PaginationFirstIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationIcon, {
	...props,
	path: "M6.85355 3.85355C7.04882 3.65829 7.04882 3.34171 6.85355 3.14645C6.65829 2.95118 6.34171 2.95118 6.14645 3.14645L2.14645 7.14645C1.95118 7.34171 1.95118 7.65829 2.14645 7.85355L6.14645 11.8536C6.34171 12.0488 6.65829 12.0488 6.85355 11.8536C7.04882 11.6583 7.04882 11.3417 6.85355 11.1464L3.20711 7.5L6.85355 3.85355ZM12.8536 3.85355C13.0488 3.65829 13.0488 3.34171 12.8536 3.14645C12.6583 2.95118 12.3417 2.95118 12.1464 3.14645L8.14645 7.14645C7.95118 7.34171 7.95118 7.65829 8.14645 7.85355L12.1464 11.8536C12.3417 12.0488 12.6583 12.0488 12.8536 11.8536C13.0488 11.6583 13.0488 11.3417 12.8536 11.1464L9.20711 7.5L12.8536 3.85355Z"
});
const PaginationLastIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationIcon, {
	...props,
	path: "M2.14645 11.1464C1.95118 11.3417 1.95118 11.6583 2.14645 11.8536C2.34171 12.0488 2.65829 12.0488 2.85355 11.8536L6.85355 7.85355C7.04882 7.65829 7.04882 7.34171 6.85355 7.14645L2.85355 3.14645C2.65829 2.95118 2.34171 2.95118 2.14645 3.14645C1.95118 3.34171 1.95118 3.65829 2.14645 3.85355L5.79289 7.5L2.14645 11.1464ZM8.14645 11.1464C7.95118 11.3417 7.95118 11.6583 8.14645 11.8536C8.34171 12.0488 8.65829 12.0488 8.85355 11.8536L12.8536 7.85355C13.0488 7.65829 13.0488 7.34171 12.8536 7.14645L8.85355 3.14645C8.65829 2.95118 8.34171 2.95118 8.14645 3.14645C7.95118 3.34171 7.95118 3.65829 8.14645 3.85355L11.7929 7.5L8.14645 11.1464Z"
});
const PaginationDotsIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationIcon, {
	...props,
	path: "M2 8c0-.733.6-1.333 1.333-1.333.734 0 1.334.6 1.334 1.333s-.6 1.333-1.334 1.333C2.6 9.333 2 8.733 2 8zm9.333 0c0-.733.6-1.333 1.334-1.333C13.4 6.667 14 7.267 14 8s-.6 1.333-1.333 1.333c-.734 0-1.334-.6-1.334-1.333zM6.667 8c0-.733.6-1.333 1.333-1.333s1.333.6 1.333 1.333S8.733 9.333 8 9.333 6.667 8.733 6.667 8z"
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/PaginationDots/PaginationDots.mjs
const defaultProps$46 = { icon: PaginationDotsIcon };
const PaginationDots = factory((_props, ref) => {
	const props = useProps("PaginationDots", defaultProps$46, _props);
	const { classNames, className, style, styles, vars, icon,...others } = props;
	const ctx = usePaginationContext();
	const Icon = icon;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("dots", {
			className,
			style,
			styles,
			classNames
		}),
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { style: {
			width: "calc(var(--pagination-control-size) / 1.8)",
			height: "calc(var(--pagination-control-size) / 1.8)"
		} })
	});
});
PaginationDots.classes = classes$26;
PaginationDots.displayName = "@mantine/core/PaginationDots";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/PaginationEdges/PaginationEdges.mjs
function createEdgeComponent({ icon, name, action, type }) {
	const defaultProps$188 = { icon };
	const Component = (0, import_react.forwardRef)((props, ref) => {
		const { icon: _icon,...others } = useProps(name, defaultProps$188, props);
		const Icon = _icon;
		const ctx = usePaginationContext();
		const disabled = type === "next" ? ctx.active === ctx.total : ctx.active === 1;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationControl, {
			disabled: ctx.disabled || disabled,
			ref,
			onClick: ctx[action],
			withPadding: false,
			...others,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
				className: "mantine-rotate-rtl",
				style: {
					width: "calc(var(--pagination-control-size) / 1.8)",
					height: "calc(var(--pagination-control-size) / 1.8)"
				}
			})
		});
	});
	Component.displayName = `@mantine/core/${name}`;
	return createPolymorphicComponent(Component);
}
const PaginationNext = createEdgeComponent({
	icon: PaginationNextIcon,
	name: "PaginationNext",
	action: "onNext",
	type: "next"
});
const PaginationPrevious = createEdgeComponent({
	icon: PaginationPreviousIcon,
	name: "PaginationPrevious",
	action: "onPrevious",
	type: "previous"
});
const PaginationFirst = createEdgeComponent({
	icon: PaginationFirstIcon,
	name: "PaginationFirst",
	action: "onFirst",
	type: "previous"
});
const PaginationLast = createEdgeComponent({
	icon: PaginationLastIcon,
	name: "PaginationLast",
	action: "onLast",
	type: "next"
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/PaginationItems/PaginationItems.mjs
function PaginationItems({ dotsIcon }) {
	const ctx = usePaginationContext();
	const items = ctx.range.map((page, index$4) => {
		if (page === "dots") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationDots, { icon: dotsIcon }, index$4);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationControl, {
			active: page === ctx.active,
			"aria-current": page === ctx.active ? "page" : void 0,
			onClick: () => ctx.onChange(page),
			disabled: ctx.disabled,
			...ctx.getItemProps?.(page),
			children: ctx.getItemProps?.(page)?.children ?? page
		}, index$4);
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: items });
}
PaginationItems.displayName = "@mantine/core/PaginationItems";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/PaginationRoot/PaginationRoot.mjs
const defaultProps$45 = {
	siblings: 1,
	boundaries: 1
};
const varsResolver$27 = createVarsResolver((theme, { size: size$3, radius, color, autoContrast }) => ({ root: {
	"--pagination-control-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--pagination-control-size": getSize(size$3, "pagination-control-size"),
	"--pagination-control-fz": getFontSize(size$3),
	"--pagination-active-bg": color ? getThemeColor(color, theme) : void 0,
	"--pagination-active-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({
		color,
		theme,
		autoContrast
	}) : void 0
} }));
const PaginationRoot = factory((_props, ref) => {
	const props = useProps("PaginationRoot", defaultProps$45, _props);
	const { classNames, className, style, styles, unstyled, vars, total, value, defaultValue, onChange, disabled, siblings, boundaries, color, radius, onNextPage, onPreviousPage, onFirstPage, onLastPage, getItemProps, autoContrast,...others } = props;
	const getStyles$1 = useStyles({
		name: "Pagination",
		classes: classes$26,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$27
	});
	const { range, setPage, next, previous, active, first, last } = usePagination({
		page: value,
		initialPage: defaultValue,
		onChange,
		total,
		siblings,
		boundaries
	});
	const handleNextPage = createEventHandler(onNextPage, next);
	const handlePreviousPage = createEventHandler(onPreviousPage, previous);
	const handleFirstPage = createEventHandler(onFirstPage, first);
	const handleLastPage = createEventHandler(onLastPage, last);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationProvider, {
		value: {
			total,
			range,
			active,
			disabled,
			getItemProps,
			onChange: setPage,
			onNext: handleNextPage,
			onPrevious: handlePreviousPage,
			onFirst: handleFirstPage,
			onLast: handleLastPage,
			getStyles: getStyles$1
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root"),
			...others
		})
	});
});
PaginationRoot.classes = classes$26;
PaginationRoot.displayName = "@mantine/core/PaginationRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Pagination/Pagination.mjs
const defaultProps$44 = {
	withControls: true,
	withPages: true,
	siblings: 1,
	boundaries: 1,
	gap: 8
};
const Pagination = factory((_props, ref) => {
	const props = useProps("Pagination", defaultProps$44, _props);
	const { withEdges, withControls, getControlProps, nextIcon, previousIcon, lastIcon, firstIcon, dotsIcon, total, gap, hideWithOnePage, withPages,...others } = props;
	if (total <= 0 || hideWithOnePage && total === 1) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationRoot, {
		ref,
		total,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Group, {
			gap,
			children: [
				withEdges && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationFirst, {
					icon: firstIcon,
					...getControlProps?.("first")
				}),
				withControls && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationPrevious, {
					icon: previousIcon,
					...getControlProps?.("previous")
				}),
				withPages && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationItems, { dotsIcon }),
				withControls && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationNext, {
					icon: nextIcon,
					...getControlProps?.("next")
				}),
				withEdges && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaginationLast, {
					icon: lastIcon,
					...getControlProps?.("last")
				})
			]
		})
	});
});
Pagination.classes = classes$26;
Pagination.displayName = "@mantine/core/Pagination";
Pagination.Root = PaginationRoot;
Pagination.Control = PaginationControl;
Pagination.Dots = PaginationDots;
Pagination.First = PaginationFirst;
Pagination.Last = PaginationLast;
Pagination.Next = PaginationNext;
Pagination.Previous = PaginationPrevious;
Pagination.Items = PaginationItems;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PasswordInput/PasswordToggleIcon.mjs
const PasswordToggleIcon = ({ reveal }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
	viewBox: "0 0 15 15",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	style: {
		width: "var(--psi-icon-size)",
		height: "var(--psi-icon-size)"
	},
	children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
		d: reveal ? "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L10.6828 3.61012C9.70652 3.21671 8.63759 3 7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C0.902945 9.08812 2.02314 10.1861 3.36061 10.9323L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L4.31723 11.3899C5.29348 11.7833 6.36241 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C14.0971 5.9119 12.9769 4.81391 11.6394 4.06771L13.3536 2.35355ZM9.90428 4.38861C9.15332 4.1361 8.34759 4 7.5 4C4.80285 4 2.52952 5.37816 1.09622 7.50001C1.87284 8.6497 2.89609 9.58106 4.09974 10.1931L9.90428 4.38861ZM5.09572 10.6114L10.9003 4.80685C12.1039 5.41894 13.1272 6.35031 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11C6.65241 11 5.84668 10.8639 5.09572 10.6114Z" : "M7.5 11C4.80285 11 2.52952 9.62184 1.09622 7.50001C2.52952 5.37816 4.80285 4 7.5 4C10.1971 4 12.4705 5.37816 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11ZM7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C1.65639 10.2936 4.30786 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C13.3436 4.70638 10.6921 3 7.5 3ZM7.5 9.5C8.60457 9.5 9.5 8.60457 9.5 7.5C9.5 6.39543 8.60457 5.5 7.5 5.5C6.39543 5.5 5.5 6.39543 5.5 7.5C5.5 8.60457 6.39543 9.5 7.5 9.5Z",
		fill: "currentColor",
		fillRule: "evenodd",
		clipRule: "evenodd"
	})
});

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PasswordInput/PasswordInput.module.css.mjs
var classes$25 = {
	"root": "m_f61ca620",
	"input": "m_ccf8da4c",
	"innerInput": "m_f2d85dd2",
	"visibilityToggle": "m_b1072d44"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PasswordInput/PasswordInput.mjs
const defaultProps$43 = { visibilityToggleIcon: PasswordToggleIcon };
const varsResolver$26 = createVarsResolver((_, { size: size$3 }) => ({ root: {
	"--psi-icon-size": getSize(size$3, "psi-icon-size"),
	"--psi-button-size": getSize(size$3, "psi-button-size")
} }));
const PasswordInput = factory((_props, ref) => {
	const props = useProps("PasswordInput", defaultProps$43, _props);
	const { classNames, className, style, styles, unstyled, vars, required, error: error$1, leftSection, disabled, id, variant, inputContainer, description, label, size: size$3, errorProps, descriptionProps, labelProps, withAsterisk, inputWrapperOrder, wrapperProps, radius, rightSection, rightSectionWidth, rightSectionPointerEvents, leftSectionWidth, visible, defaultVisible, onVisibilityChange, visibilityToggleIcon, visibilityToggleButtonProps, rightSectionProps, leftSectionProps, leftSectionPointerEvents, withErrorStyles, mod,...others } = props;
	const uuid = useId(id);
	const [_visible, setVisibility] = useUncontrolled({
		value: visible,
		defaultValue: defaultVisible,
		finalValue: false,
		onChange: onVisibilityChange
	});
	const toggleVisibility = () => setVisibility(!_visible);
	const getStyles$1 = useStyles({
		name: "PasswordInput",
		classes: classes$25,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$26
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const { styleProps, rest } = extractStyleProps(others);
	const VisibilityToggleIcon = visibilityToggleIcon;
	const errorId = errorProps?.id || `${uuid}-error`;
	const descriptionId = descriptionProps?.id || `${uuid}-description`;
	const hasError = !!error$1 && typeof error$1 !== "boolean";
	const hasDescription = !!description;
	const _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`;
	const describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0;
	const visibilityToggleButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionIcon, {
		...getStyles$1("visibilityToggle"),
		disabled,
		radius,
		"aria-hidden": !visibilityToggleButtonProps,
		tabIndex: -1,
		...visibilityToggleButtonProps,
		variant: visibilityToggleButtonProps?.variant ?? "subtle",
		color: "gray",
		unstyled,
		onTouchEnd: (event) => {
			event.preventDefault();
			visibilityToggleButtonProps?.onTouchEnd?.(event);
			toggleVisibility();
		},
		onMouseDown: (event) => {
			event.preventDefault();
			visibilityToggleButtonProps?.onMouseDown?.(event);
			toggleVisibility();
		},
		onKeyDown: (event) => {
			visibilityToggleButtonProps?.onKeyDown?.(event);
			if (event.key === " ") {
				event.preventDefault();
				toggleVisibility();
			}
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(VisibilityToggleIcon, { reveal: _visible })
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
		required,
		id: uuid,
		label,
		error: error$1,
		description,
		size: size$3,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		__staticSelector: "PasswordInput",
		unstyled,
		withAsterisk,
		inputWrapperOrder,
		inputContainer,
		variant,
		labelProps: {
			...labelProps,
			htmlFor: uuid
		},
		descriptionProps: {
			...descriptionProps,
			id: descriptionId
		},
		errorProps: {
			...errorProps,
			id: errorId
		},
		mod,
		...getStyles$1("root"),
		...styleProps,
		...wrapperProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
			component: "div",
			error: error$1,
			leftSection,
			size: size$3,
			classNames: {
				...resolvedClassNames,
				input: clsx_default(classes$25.input, resolvedClassNames.input)
			},
			styles: resolvedStyles,
			radius,
			disabled,
			__staticSelector: "PasswordInput",
			rightSectionWidth,
			rightSection: rightSection ?? visibilityToggleButton,
			variant,
			unstyled,
			leftSectionWidth,
			rightSectionPointerEvents: rightSectionPointerEvents || "all",
			rightSectionProps,
			leftSectionProps,
			leftSectionPointerEvents,
			withAria: false,
			withErrorStyles,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
				required,
				"data-invalid": !!error$1 || void 0,
				"data-with-left-section": !!leftSection || void 0,
				...getStyles$1("innerInput"),
				disabled,
				id: uuid,
				ref,
				...rest,
				"aria-describedby": describedBy,
				autoComplete: rest.autoComplete || "off",
				type: _visible ? "text" : "password"
			})
		})
	});
});
PasswordInput.classes = {
	...InputBase.classes,
	...classes$25
};
PasswordInput.displayName = "@mantine/core/PasswordInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PinInput/create-pin-array/create-pin-array.mjs
function createPinArray(length, value) {
	if (length < 1) return [];
	const values$1 = new Array(length).fill("");
	if (value) {
		const splitted = value.trim().split("");
		for (let i = 0; i < Math.min(length, splitted.length); i += 1) values$1[i] = splitted[i] === " " ? "" : splitted[i];
	}
	return values$1;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PinInput/PinInput.module.css.mjs
var classes$24 = {
	"root": "m_f1cb205a",
	"pinInput": "m_cb288ead"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/PinInput/PinInput.mjs
const regex = {
	number: /^[0-9]+$/,
	alphanumeric: /^[a-zA-Z0-9]+$/i
};
const defaultProps$42 = {
	gap: "sm",
	length: 4,
	manageFocus: true,
	oneTimeCode: true,
	placeholder: "â—‹",
	type: "alphanumeric",
	ariaLabel: "PinInput"
};
const varsResolver$25 = createVarsResolver((_, { size: size$3 }) => ({ root: { "--pin-input-size": getSize(size$3 ?? defaultProps$42.size, "pin-input-size") } }));
const PinInput = factory((props, ref) => {
	const { name, form, className, value, defaultValue, variant, gap, style, size: size$3, classNames, styles, unstyled, length, onChange, onComplete, manageFocus, autoFocus, error: error$1, radius, disabled, oneTimeCode, placeholder, type, mask, readOnly, inputType, inputMode, ariaLabel, vars, id, hiddenInputProps, rootRef, getInputProps,...others } = useProps("PinInput", defaultProps$42, props);
	const uuid = useId(id);
	const getStyles$1 = useStyles({
		name: "PinInput",
		classes: classes$24,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$25
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(-1);
	const [_value, setValues] = useUncontrolled({
		value: value ? createPinArray(length ?? 0, value) : void 0,
		defaultValue: defaultValue?.split("").slice(0, length ?? 0),
		finalValue: createPinArray(length ?? 0, ""),
		onChange: typeof onChange === "function" ? (val) => {
			onChange(val.join("").trim());
		} : void 0
	});
	const _valueToString = _value.join("").trim();
	const inputsRef = (0, import_react.useRef)([]);
	const validate = (code) => {
		const re = type instanceof RegExp ? type : type && type in regex ? regex[type] : null;
		return re?.test(code);
	};
	const focusInputField = (dir, index$4, event) => {
		if (!manageFocus) {
			event?.preventDefault();
			return;
		}
		if (dir === "next") {
			const nextIndex = index$4 + 1;
			const canFocusNext = nextIndex < (length ?? 0);
			if (canFocusNext) {
				event?.preventDefault();
				inputsRef.current[nextIndex].focus();
			}
		}
		if (dir === "prev") {
			const nextIndex = index$4 - 1;
			const canFocusNext = nextIndex > -1;
			if (canFocusNext) {
				event?.preventDefault();
				inputsRef.current[nextIndex].focus();
			}
		}
	};
	const setFieldValue = (val, index$4) => {
		const values$1 = [..._value];
		values$1[index$4] = val;
		setValues(values$1);
	};
	const handleChange = (event, index$4) => {
		const inputValue = event.target.value;
		const nextCharOrValue = inputValue.length === 2 ? inputValue.split("")[inputValue.length - 1] : inputValue;
		const isValid = validate(nextCharOrValue);
		if (nextCharOrValue.length < 2) if (isValid) {
			setFieldValue(nextCharOrValue, index$4);
			focusInputField("next", index$4);
		} else setFieldValue("", index$4);
		else if (isValid) setValues(createPinArray(length ?? 0, inputValue));
	};
	const handleKeyDown = (event, index$4) => {
		const { ctrlKey, metaKey, key, shiftKey, target } = event;
		const inputValue = target.value;
		if (inputMode === "numeric") {
			const canTypeSign = key === "Backspace" || key === "Tab" || key === "Control" || key === "Delete" || ctrlKey && key === "v" || metaKey && key === "v" ? true : !Number.isNaN(Number(key));
			if (!canTypeSign) event.preventDefault();
		}
		if (key === "ArrowLeft" || shiftKey && key === "Tab") focusInputField("prev", index$4, event);
		else if (key === "ArrowRight" || key === "Tab" || key === " ") focusInputField("next", index$4, event);
		else if (key === "Delete") setFieldValue("", index$4);
		else if (key === "Backspace") {
			if (index$4 !== 0) {
				setFieldValue("", index$4);
				if (length === index$4 + 1) {
					if (event.target.value === "") focusInputField("prev", index$4, event);
				} else focusInputField("prev", index$4, event);
			}
		} else if (inputValue.length > 0 && key === _value[index$4]) focusInputField("next", index$4, event);
	};
	const handleFocus = (event, index$4) => {
		event.target.select();
		setFocusedIndex(index$4);
	};
	const handleBlur = () => {
		setFocusedIndex(-1);
	};
	const handlePaste = (event) => {
		event.preventDefault();
		const copyValue = event.clipboardData.getData("text/plain").replace(/[\n\r\s]+/g, "");
		const isValid = validate(copyValue.trim());
		if (isValid) {
			const copyValueToPinArray = createPinArray(length ?? 0, copyValue);
			setValues(copyValueToPinArray);
			focusInputField("next", copyValueToPinArray.length - 2);
		}
	};
	(0, import_react.useEffect)(() => {
		if (_valueToString.length !== length) return;
		onComplete?.(_valueToString);
	}, [length, _valueToString]);
	(0, import_react.useEffect)(() => {
		if (length !== _value.length) setValues(createPinArray(length ?? 0, _value.join("")));
	}, [length, _value]);
	(0, import_react.useEffect)(() => {
		if (value === "") setValues(createPinArray(length ?? 0, value));
	}, [value]);
	(0, import_react.useEffect)(() => {
		if (disabled) setFocusedIndex(-1);
	}, [disabled]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Group, {
		...others,
		...getStyles$1("root"),
		ref: rootRef,
		role: "group",
		id: uuid,
		gap,
		unstyled,
		wrap: "nowrap",
		variant,
		__size: size$3,
		dir: "ltr",
		children: _value.map((char, index$4) => /* @__PURE__ */ (0, import_react.createElement)(Input, {
			component: "input",
			...getStyles$1("pinInput", { style: {
				"--input-padding": "0",
				"--input-text-align": "center"
			} }),
			classNames: resolvedClassNames,
			styles: resolvedStyles,
			size: size$3,
			__staticSelector: "PinInput",
			id: `${uuid}-${index$4 + 1}`,
			key: `${uuid}-${index$4}`,
			inputMode: inputMode || (type === "number" ? "numeric" : "text"),
			onChange: (event) => handleChange(event, index$4),
			onKeyDown: (event) => handleKeyDown(event, index$4),
			onFocus: (event) => handleFocus(event, index$4),
			onBlur: handleBlur,
			onPaste: handlePaste,
			type: inputType || (mask ? "password" : type === "number" ? "tel" : "text"),
			radius,
			error: error$1,
			variant,
			disabled,
			ref: (node) => {
				index$4 === 0 && assignRef(ref, node);
				inputsRef.current[index$4] = node;
			},
			autoComplete: oneTimeCode ? "one-time-code" : "off",
			placeholder: focusedIndex === index$4 ? "" : placeholder,
			value: char,
			autoFocus: autoFocus && index$4 === 0,
			unstyled,
			"aria-label": ariaLabel,
			readOnly,
			...getInputProps?.(index$4)
		}))
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		type: "hidden",
		name,
		form,
		value: _valueToString,
		...hiddenInputProps
	})] });
});
PinInput.classes = {
	...classes$24,
	...InputBase.classes
};
PinInput.displayName = "@mantine/core/PinInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/Progress.context.mjs
const [ProgressProvider, useProgressContext] = createSafeContext("Progress.Root component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/Progress.module.css.mjs
var classes$23 = {
	"root": "m_db6d6462",
	"section": "m_2242eb65",
	"stripes-animation": "m_81a374bd",
	"label": "m_91e40b74"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/ProgressLabel/ProgressLabel.mjs
const defaultProps$41 = {};
const ProgressLabel = factory((props, ref) => {
	const { classNames, className, style, styles, vars,...others } = useProps("ProgressLabel", defaultProps$41, props);
	const ctx = useProgressContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("label", {
			className,
			style,
			classNames,
			styles
		}),
		...others
	});
});
ProgressLabel.classes = classes$23;
ProgressLabel.displayName = "@mantine/core/ProgressLabel";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/ProgressRoot/ProgressRoot.mjs
const defaultProps$40 = {};
const varsResolver$24 = createVarsResolver((_, { size: size$3, radius, transitionDuration }) => ({ root: {
	"--progress-size": getSize(size$3, "progress-size"),
	"--progress-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--progress-transition-duration": typeof transitionDuration === "number" ? `${transitionDuration}ms` : void 0
} }));
const ProgressRoot = factory((_props, ref) => {
	const props = useProps("ProgressRoot", defaultProps$40, _props);
	const { classNames, className, style, styles, unstyled, vars, autoContrast, transitionDuration,...others } = props;
	const getStyles$1 = useStyles({
		name: "Progress",
		classes: classes$23,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$24
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ProgressProvider, {
		value: {
			getStyles: getStyles$1,
			autoContrast
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root"),
			...others
		})
	});
});
ProgressRoot.classes = classes$23;
ProgressRoot.displayName = "@mantine/core/ProgressRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/ProgressSection/ProgressSection.mjs
const defaultProps$39 = { withAria: true };
const ProgressSection = factory((props, ref) => {
	const { classNames, className, style, styles, vars, value, withAria, color, striped, animated, mod,...others } = useProps("ProgressSection", defaultProps$39, props);
	const ctx = useProgressContext();
	const theme = useMantineTheme();
	const ariaAttributes = withAria ? {
		role: "progressbar",
		"aria-valuemax": 100,
		"aria-valuemin": 0,
		"aria-valuenow": value,
		"aria-valuetext": `${value}%`
	} : {};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("section", {
			className,
			classNames,
			styles,
			style
		}),
		...others,
		...ariaAttributes,
		mod: [{
			striped: striped || animated,
			animated
		}, mod],
		__vars: {
			"--progress-section-width": `${value}%`,
			"--progress-section-color": getThemeColor(color, theme),
			"--progress-label-color": getAutoContrastValue(ctx.autoContrast, theme) ? getContrastColor({
				color,
				theme,
				autoContrast: ctx.autoContrast
			}) : void 0
		}
	});
});
ProgressSection.classes = classes$23;
ProgressSection.displayName = "@mantine/core/ProgressSection";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Progress/Progress.mjs
const defaultProps$38 = {};
const Progress = factory((_props, ref) => {
	const props = useProps("Progress", defaultProps$38, _props);
	const { value, classNames, styles, vars, color, striped, animated, "aria-label": label,...others } = props;
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ProgressRoot, {
		ref,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		vars,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ProgressSection, {
			value,
			color,
			striped,
			animated,
			"aria-label": label
		})
	});
});
Progress.classes = classes$23;
Progress.displayName = "@mantine/core/Progress";
Progress.Section = ProgressSection;
Progress.Root = ProgressRoot;
Progress.Label = ProgressLabel;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioGroup.context.mjs
const [RadioGroupProvider, useRadioGroupContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioCard/RadioCard.context.mjs
const [RadioCardProvider, useRadioCardContext] = createOptionalContext();

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioCard/RadioCard.module.css.mjs
var classes$22 = { "card": "m_9dc8ae12" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioCard/RadioCard.mjs
const defaultProps$37 = { withBorder: true };
const varsResolver$23 = createVarsResolver((_, { radius }) => ({ card: { "--card-radius": getRadius(radius) } }));
const RadioCard = factory((_props, ref) => {
	const props = useProps("RadioCard", defaultProps$37, _props);
	const { classNames, className, style, styles, unstyled, vars, checked, mod, withBorder, value, onClick, name, onKeyDown,...others } = props;
	const getStyles$1 = useStyles({
		name: "RadioCard",
		classes: classes$22,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$23,
		rootSelector: "card"
	});
	const { dir } = useDirection();
	const ctx = useRadioGroupContext();
	const _checked = typeof checked === "boolean" ? checked : ctx?.value === value || false;
	const _name = name || ctx?.name;
	const handleKeyDown = (event) => {
		onKeyDown?.(event);
		if ([
			"ArrowDown",
			"ArrowUp",
			"ArrowLeft",
			"ArrowRight"
		].includes(event.nativeEvent.code)) {
			event.preventDefault();
			const siblings = Array.from(document.querySelectorAll(`[role="radio"][name="${_name || "__mantine"}"]`));
			const currentIndex = siblings.findIndex((element) => element === event.target);
			const nextIndex = currentIndex + 1 >= siblings.length ? 0 : currentIndex + 1;
			const prevIndex = currentIndex - 1 < 0 ? siblings.length - 1 : currentIndex - 1;
			if (event.nativeEvent.code === "ArrowDown") {
				siblings[nextIndex].focus();
				siblings[nextIndex].click();
			}
			if (event.nativeEvent.code === "ArrowUp") {
				siblings[prevIndex].focus();
				siblings[prevIndex].click();
			}
			if (event.nativeEvent.code === "ArrowLeft") {
				siblings[dir === "ltr" ? prevIndex : nextIndex].focus();
				siblings[dir === "ltr" ? prevIndex : nextIndex].click();
			}
			if (event.nativeEvent.code === "ArrowRight") {
				siblings[dir === "ltr" ? nextIndex : prevIndex].focus();
				siblings[dir === "ltr" ? nextIndex : prevIndex].click();
			}
		}
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RadioCardProvider, {
		value: { checked: _checked },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			ref,
			mod: [{
				"with-border": withBorder,
				checked: _checked
			}, mod],
			...getStyles$1("card"),
			...others,
			role: "radio",
			"aria-checked": _checked,
			name: _name,
			onClick: (event) => {
				onClick?.(event);
				ctx?.onChange(value || "");
			},
			onKeyDown: handleKeyDown
		})
	});
});
RadioCard.displayName = "@mantine/core/RadioCard";
RadioCard.classes = classes$22;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioGroup/RadioGroup.mjs
const defaultProps$36 = {};
const RadioGroup = factory((props, ref) => {
	const { value, defaultValue, onChange, size: size$3, wrapperProps, children, name, readOnly,...others } = useProps("RadioGroup", defaultProps$36, props);
	const _name = useId(name);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const handleChange = (event) => !readOnly && setValue(typeof event === "string" ? event : event.currentTarget.value);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RadioGroupProvider, {
		value: {
			value: _value,
			onChange: handleChange,
			size: size$3,
			name: _name
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
			size: size$3,
			ref,
			...wrapperProps,
			...others,
			labelElement: "div",
			__staticSelector: "RadioGroup",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputsGroupFieldset, {
				role: "radiogroup",
				children
			})
		})
	});
});
RadioGroup.classes = Input.Wrapper.classes;
RadioGroup.displayName = "@mantine/core/RadioGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioIcon.mjs
function RadioIcon({ size: size$3, style,...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "none",
		viewBox: "0 0 5 5",
		style: {
			width: rem(size$3),
			height: rem(size$3),
			...style
		},
		"aria-hidden": true,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", {
			cx: "2.5",
			cy: "2.5",
			r: "2.5",
			fill: "currentColor"
		})
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioIndicator/RadioIndicator.module.css.mjs
var classes$21 = {
	"indicator": "m_717d7ff6",
	"icon": "m_3e4da632",
	"indicator--outline": "m_2980836c"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/RadioIndicator/RadioIndicator.mjs
const defaultProps$35 = { icon: RadioIcon };
const varsResolver$22 = createVarsResolver((theme, { radius, color, size: size$3, iconColor, variant, autoContrast }) => {
	const parsedColor = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	const outlineColor = parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
	return { indicator: {
		"--radio-size": getSize(size$3, "radio-size"),
		"--radio-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--radio-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
		"--radio-icon-size": getSize(size$3, "radio-icon-size"),
		"--radio-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({
			color,
			theme,
			autoContrast
		}) : void 0
	} };
});
const RadioIndicator = factory((_props, ref) => {
	const props = useProps("RadioIndicator", defaultProps$35, _props);
	const { classNames, className, style, styles, unstyled, vars, icon, radius, color, iconColor, autoContrast, checked, mod, variant, disabled,...others } = props;
	const Icon = icon;
	const getStyles$1 = useStyles({
		name: "RadioIndicator",
		classes: classes$21,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$22,
		rootSelector: "indicator"
	});
	const ctx = useRadioCardContext();
	const _checked = typeof checked === "boolean" ? checked : ctx?.checked || false;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("indicator", { variant }),
		variant,
		mod: [{
			checked: _checked,
			disabled
		}, mod],
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { ...getStyles$1("icon") })
	});
});
RadioIndicator.displayName = "@mantine/core/RadioIndicator";
RadioIndicator.classes = classes$21;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/Radio.module.css.mjs
var classes$20 = {
	"root": "m_f3f1af94",
	"inner": "m_89c4f5e4",
	"icon": "m_f3ed6b2b",
	"radio": "m_8a3dbb89",
	"radio--outline": "m_1bfe9d39"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Radio/Radio.mjs
const defaultProps$34 = { labelPosition: "right" };
const varsResolver$21 = createVarsResolver((theme, { size: size$3, radius, color, iconColor, variant, autoContrast }) => {
	const parsedColor = parseThemeColor({
		color: color || theme.primaryColor,
		theme
	});
	const outlineColor = parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-outline)` : parsedColor.color;
	return { root: {
		"--radio-size": getSize(size$3, "radio-size"),
		"--radio-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--radio-color": variant === "outline" ? outlineColor : getThemeColor(color, theme),
		"--radio-icon-color": iconColor ? getThemeColor(iconColor, theme) : getAutoContrastValue(autoContrast, theme) ? getContrastColor({
			color,
			theme,
			autoContrast
		}) : void 0,
		"--radio-icon-size": getSize(size$3, "radio-icon-size")
	} };
});
const Radio = factory((_props, ref) => {
	const props = useProps("Radio", defaultProps$34, _props);
	const { classNames, className, style, styles, unstyled, vars, id, size: size$3, label, labelPosition, description, error: error$1, radius, color, variant, disabled, wrapperProps, icon: Icon = RadioIcon, rootRef, iconColor, onChange, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Radio",
		classes: classes$20,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$21
	});
	const ctx = useRadioGroupContext();
	const contextSize = ctx?.size ?? size$3;
	const componentSize = props.size ? size$3 : contextSize;
	const { styleProps, rest } = extractStyleProps(others);
	const uuid = useId(id);
	const contextProps = ctx ? {
		checked: ctx.value === rest.value,
		name: rest.name ?? ctx.name,
		onChange: (event) => {
			ctx.onChange(event);
			onChange?.(event);
		}
	} : {};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineInput, {
		...getStyles$1("root"),
		__staticSelector: "Radio",
		__stylesApiProps: props,
		id: uuid,
		size: componentSize,
		labelPosition,
		label,
		description,
		error: error$1,
		disabled,
		classNames,
		styles,
		unstyled,
		"data-checked": contextProps.checked || void 0,
		variant,
		ref: rootRef,
		mod,
		...styleProps,
		...wrapperProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("inner"),
			mod: { "label-position": labelPosition },
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				...getStyles$1("radio", {
					focusable: true,
					variant
				}),
				onChange,
				...rest,
				...contextProps,
				component: "input",
				mod: { error: !!error$1 },
				ref,
				id: uuid,
				disabled,
				type: "radio"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
				...getStyles$1("icon"),
				"aria-hidden": true
			})]
		})
	});
});
Radio.classes = classes$20;
Radio.displayName = "@mantine/core/Radio";
Radio.Group = RadioGroup;
Radio.Card = RadioCard;
Radio.Indicator = RadioIndicator;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/Rating.context.mjs
const [RatingProvider, useRatingContext] = createSafeContext("Rating was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/StarSymbol/StarIcon.mjs
function StarIcon(props) {
	const { width, height, style,...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		viewBox: "0 0 24 24",
		strokeLinecap: "round",
		strokeLinejoin: "round",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		style: {
			width,
			height,
			...style
		},
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M12 17.75l-6.172 3.245l1.179 -6.873l-5 -4.867l6.9 -1l3.086 -6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z" })
	});
}
StarIcon.displayName = "@mantine/core/StarIcon";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/StarSymbol/StarSymbol.mjs
function StarSymbol({ type }) {
	const ctx = useRatingContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StarIcon, {
		...ctx.getStyles("starSymbol"),
		"data-filled": type === "full" || void 0
	});
}
StarSymbol.displayName = "@mantine/core/StarSymbol";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/RatingItem/RatingItem.mjs
function RatingItem({ getSymbolLabel, emptyIcon, fullIcon, full, active, value, readOnly, fractionValue, color, id, onBlur, onChange, onInputChange, style,...others }) {
	const ctx = useRatingContext();
	const _fullIcon = typeof fullIcon === "function" ? fullIcon(value) : fullIcon;
	const _emptyIcon = typeof emptyIcon === "function" ? emptyIcon(value) : emptyIcon;
	const { dir } = useDirection();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [!readOnly && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		...ctx.getStyles("input"),
		onKeyDown: (event) => event.key === " " && onChange(value),
		id,
		type: "radio",
		"data-active": active || void 0,
		"aria-label": getSymbolLabel?.(value),
		value,
		onBlur,
		onChange: onInputChange,
		...others
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: readOnly ? "div" : "label",
		...ctx.getStyles("label"),
		"data-read-only": readOnly || void 0,
		htmlFor: id,
		onClick: () => onChange(value),
		__vars: { "--rating-item-z-index": (fractionValue === 1 ? void 0 : active ? 2 : 0)?.toString() },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...ctx.getStyles("symbolBody"),
			__vars: { "--rating-symbol-clip-path": fractionValue === 1 ? void 0 : dir === "ltr" ? `inset(0 ${active ? 100 - fractionValue * 100 : 100}% 0 0)` : `inset(0 0 0 ${active ? 100 - fractionValue * 100 : 100}% )` },
			children: full ? _fullIcon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StarSymbol, { type: "full" }) : _emptyIcon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StarSymbol, { type: "empty" })
		})
	})] });
}
RatingItem.displayName = "@mantine/core/RatingItem";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/Rating.module.css.mjs
var classes$19 = {
	"root": "m_f8d312f2",
	"symbolGroup": "m_61734bb7",
	"starSymbol": "m_5662a89a",
	"input": "m_211007ba",
	"label": "m_21342ee4",
	"symbolBody": "m_fae05d6a"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Rating/Rating.mjs
function roundValueTo(value, to) {
	const rounded = Math.round(value / to) * to;
	const precision = `${to}`.split(".")[1]?.length || 0;
	return Number(rounded.toFixed(precision));
}
const defaultProps$33 = {
	size: "sm",
	getSymbolLabel: (value) => `${value}`,
	count: 5,
	fractions: 1,
	color: "yellow"
};
const varsResolver$20 = createVarsResolver((theme, { size: size$3, color }) => ({ root: {
	"--rating-size": getSize(size$3, "rating-size"),
	"--rating-color": getThemeColor(color, theme)
} }));
const Rating = factory((_props, ref) => {
	const props = useProps("Rating", defaultProps$33, _props);
	const { classNames, className, style, styles, unstyled, vars, name, id, value, defaultValue, onChange, fractions, count: count$1, onMouseEnter, readOnly, onMouseMove, onHover, onMouseLeave, onTouchStart, onTouchEnd, size: size$3, variant, getSymbolLabel, color, emptySymbol, fullSymbol, highlightSelectedOnly,...others } = props;
	const getStyles$1 = useStyles({
		name: "Rating",
		classes: classes$19,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$20
	});
	const { dir } = useDirection();
	const _name = useId(name);
	const _id = useId(id);
	const rootRef = (0, import_react.useRef)(null);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: 0,
		onChange
	});
	const [hovered, setHovered] = (0, import_react.useState)(-1);
	const [isOutside, setOutside] = (0, import_react.useState)(true);
	const _fractions = Math.floor(fractions);
	const _count = Math.floor(count$1);
	const decimalUnit = 1 / _fractions;
	const stableValueRounded = roundValueTo(_value, decimalUnit);
	const finalValue = hovered !== -1 ? hovered : stableValueRounded;
	const getRatingFromCoordinates = (x) => {
		const { left, right, width } = rootRef.current.getBoundingClientRect();
		const symbolWidth = width / _count;
		const hoverPosition = dir === "rtl" ? right - x : x - left;
		const hoverValue = hoverPosition / symbolWidth;
		return clamp(roundValueTo(hoverValue + decimalUnit / 2, decimalUnit), decimalUnit, _count);
	};
	const handleMouseEnter = (event) => {
		onMouseEnter?.(event);
		!readOnly && setOutside(false);
	};
	const handleMouseMove = (event) => {
		onMouseMove?.(event);
		if (readOnly) return;
		const rounded = getRatingFromCoordinates(event.clientX);
		setHovered(rounded);
		rounded !== hovered && onHover?.(rounded);
	};
	const handleMouseLeave = (event) => {
		onMouseLeave?.(event);
		if (readOnly) return;
		setHovered(-1);
		setOutside(true);
		hovered !== -1 && onHover?.(-1);
	};
	const handleTouchStart = (event) => {
		const { touches } = event;
		if (touches.length !== 1) return;
		if (!readOnly) {
			const touch = touches[0];
			setValue(getRatingFromCoordinates(touch.clientX));
		}
		onTouchStart?.(event);
	};
	const handleTouchEnd = (event) => {
		event.preventDefault();
		onTouchEnd?.(event);
	};
	const handleItemBlur = () => isOutside && setHovered(-1);
	const handleInputChange = (event) => {
		if (!readOnly) if (typeof event === "number") setHovered(event);
		else setHovered(parseFloat(event.target.value));
	};
	const handleChange = (event) => {
		if (!readOnly) if (typeof event === "number") setValue(event);
		else setValue(parseFloat(event.target.value));
	};
	const items = Array(_count).fill(0).map((_, index$4) => {
		const integerValue = index$4 + 1;
		const fractionItems = Array.from(new Array(index$4 === 0 ? _fractions + 1 : _fractions));
		const isGroupActive = !readOnly && Math.ceil(hovered) === integerValue;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			"data-active": isGroupActive || void 0,
			...getStyles$1("symbolGroup"),
			children: fractionItems.map((__, fractionIndex) => {
				const fractionValue = decimalUnit * (index$4 === 0 ? fractionIndex : fractionIndex + 1);
				const symbolValue = roundValueTo(integerValue - 1 + fractionValue, decimalUnit);
				return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RatingItem, {
					getSymbolLabel,
					emptyIcon: emptySymbol,
					fullIcon: fullSymbol,
					full: highlightSelectedOnly ? symbolValue === finalValue : symbolValue <= finalValue,
					active: symbolValue === finalValue,
					checked: symbolValue === stableValueRounded,
					readOnly,
					fractionValue,
					value: symbolValue,
					name: _name,
					onChange: handleChange,
					onBlur: handleItemBlur,
					onInputChange: handleInputChange,
					id: `${_id}-${index$4}-${fractionIndex}`
				}, `${integerValue}-${symbolValue}`);
			})
		}, integerValue);
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RatingProvider, {
		value: { getStyles: getStyles$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref: useMergedRef(rootRef, ref),
			...getStyles$1("root"),
			onMouseMove: handleMouseMove,
			onMouseEnter: handleMouseEnter,
			onMouseLeave: handleMouseLeave,
			onTouchStart: handleTouchStart,
			onTouchEnd: handleTouchEnd,
			variant,
			size: size$3,
			id: _id,
			...others,
			children: items
		})
	});
});
Rating.classes = classes$19;
Rating.displayName = "@mantine/core/Rating";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Transition/get-transition-props/get-transition-props.mjs
const defaultTransition = {
	duration: 100,
	transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
	return {
		...defaultTransition,
		...componentTransition,
		...transitionProps
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/use-floating-tooltip.mjs
function useFloatingTooltip({ offset: offset$3, position, defaultOpened }) {
	const [opened, setOpened] = (0, import_react.useState)(defaultOpened);
	const boundaryRef = (0, import_react.useRef)(null);
	const { x, y, elements, refs, update, placement } = useFloating({
		placement: position,
		middleware: [shift({
			crossAxis: true,
			padding: 5,
			rootBoundary: "document"
		})]
	});
	const horizontalOffset = placement.includes("right") ? offset$3 : position.includes("left") ? offset$3 * -1 : 0;
	const verticalOffset = placement.includes("bottom") ? offset$3 : position.includes("top") ? offset$3 * -1 : 0;
	const handleMouseMove = (0, import_react.useCallback)(({ clientX, clientY }) => {
		refs.setPositionReference({ getBoundingClientRect() {
			return {
				width: 0,
				height: 0,
				x: clientX,
				y: clientY,
				left: clientX + horizontalOffset,
				top: clientY + verticalOffset,
				right: clientX,
				bottom: clientY
			};
		} });
	}, [elements.reference]);
	(0, import_react.useEffect)(() => {
		if (refs.floating.current) {
			const boundary = boundaryRef.current;
			boundary.addEventListener("mousemove", handleMouseMove);
			const parents = getOverflowAncestors(refs.floating.current);
			parents.forEach((parent) => {
				parent.addEventListener("scroll", update);
			});
			return () => {
				boundary.removeEventListener("mousemove", handleMouseMove);
				parents.forEach((parent) => {
					parent.removeEventListener("scroll", update);
				});
			};
		}
		return void 0;
	}, [
		elements.reference,
		refs.floating.current,
		update,
		handleMouseMove,
		opened
	]);
	return {
		handleMouseMove,
		x,
		y,
		opened,
		setOpened,
		boundaryRef,
		floating: refs.setFloating
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/Tooltip.module.css.mjs
var classes$18 = {
	"tooltip": "m_1b3c8819",
	"arrow": "m_f898399f"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/TooltipFloating.mjs
const defaultProps$32 = {
	refProp: "ref",
	withinPortal: true,
	offset: 10,
	defaultOpened: false,
	position: "right",
	zIndex: getDefaultZIndex("popover")
};
const varsResolver$19 = createVarsResolver((theme, { radius, color }) => ({ tooltip: {
	"--tooltip-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--tooltip-bg": color ? getThemeColor(color, theme) : void 0,
	"--tooltip-color": color ? "var(--mantine-color-white)" : void 0
} }));
const TooltipFloating = factory((_props, ref) => {
	const props = useProps("TooltipFloating", defaultProps$32, _props);
	const { children, refProp, withinPortal, style, className, classNames, styles, unstyled, radius, color, label, offset: offset$3, position, multiline, zIndex, disabled, defaultOpened, variant, vars, portalProps,...others } = props;
	const theme = useMantineTheme();
	const getStyles$1 = useStyles({
		name: "TooltipFloating",
		props,
		classes: classes$18,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "tooltip",
		vars,
		varsResolver: varsResolver$19
	});
	const { handleMouseMove, x, y, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
		offset: offset$3,
		position,
		defaultOpened
	});
	if (!isElement(children)) throw new Error("[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
	const targetRef = useMergedRef(boundaryRef, getRefProp(children), ref);
	const _childrenProps = children.props;
	const onMouseEnter = (event) => {
		_childrenProps.onMouseEnter?.(event);
		handleMouseMove(event);
		setOpened(true);
	};
	const onMouseLeave = (event) => {
		_childrenProps.onMouseLeave?.(event);
		setOpened(false);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...portalProps,
		withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...others,
			...getStyles$1("tooltip", { style: {
				...getStyleObject(style, theme),
				zIndex,
				display: !disabled && opened ? "block" : "none",
				top: (y && Math.round(y)) ?? "",
				left: (x && Math.round(x)) ?? ""
			} }),
			variant,
			ref: floating,
			mod: { multiline },
			children: label
		})
	}), (0, import_react.cloneElement)(children, {
		..._childrenProps,
		[refProp]: targetRef,
		onMouseEnter,
		onMouseLeave
	})] });
});
TooltipFloating.classes = classes$18;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.context.mjs
const TooltipGroupContext = (0, import_react.createContext)(false);
const TooltipGroupProvider = TooltipGroupContext.Provider;
const useTooltipGroupContext = () => (0, import_react.useContext)(TooltipGroupContext);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.mjs
const defaultProps$31 = {
	openDelay: 0,
	closeDelay: 0
};
function TooltipGroup(props) {
	const { openDelay, closeDelay, children } = useProps("TooltipGroup", defaultProps$31, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TooltipGroupProvider, {
		value: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FloatingDelayGroup, {
			delay: {
				open: openDelay,
				close: closeDelay
			},
			children
		})
	});
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c) => c;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/use-tooltip.mjs
function getDefaultMiddlewares(middlewares) {
	if (middlewares === void 0) return {
		shift: true,
		flip: true
	};
	const result = { ...middlewares };
	if (middlewares.shift === void 0) result.shift = true;
	if (middlewares.flip === void 0) result.flip = true;
	return result;
}
function getTooltipMiddlewares(settings) {
	const middlewaresOptions = getDefaultMiddlewares(settings.middlewares);
	const middlewares = [offset(settings.offset)];
	if (middlewaresOptions.shift) middlewares.push(shift(typeof middlewaresOptions.shift === "boolean" ? { padding: 8 } : {
		padding: 8,
		...middlewaresOptions.shift
	}));
	if (middlewaresOptions.flip) middlewares.push(typeof middlewaresOptions.flip === "boolean" ? flip() : flip(middlewaresOptions.flip));
	middlewares.push(arrow({
		element: settings.arrowRef,
		padding: settings.arrowOffset
	}));
	if (middlewaresOptions.inline) middlewares.push(typeof middlewaresOptions.inline === "boolean" ? inline() : inline(middlewaresOptions.inline));
	else if (settings.inline) middlewares.push(inline());
	return middlewares;
}
function useTooltip(settings) {
	const [uncontrolledOpened, setUncontrolledOpened] = (0, import_react.useState)(settings.defaultOpened);
	const controlled = typeof settings.opened === "boolean";
	const opened = controlled ? settings.opened : uncontrolledOpened;
	const withinGroup = useTooltipGroupContext();
	const uid = useId();
	const onChange = (0, import_react.useCallback)((_opened) => {
		setUncontrolledOpened(_opened);
		if (_opened) setCurrentId(uid);
	}, [uid]);
	const { x, y, context, refs, update, placement, middlewareData: { arrow: { x: arrowX, y: arrowY } = {} } } = useFloating({
		strategy: settings.strategy,
		placement: settings.position,
		open: opened,
		onOpenChange: onChange,
		middleware: getTooltipMiddlewares(settings)
	});
	const { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context, { id: uid });
	const { getReferenceProps, getFloatingProps } = useInteractions([
		useHover(context, {
			enabled: settings.events?.hover,
			delay: withinGroup ? groupDelay : {
				open: settings.openDelay,
				close: settings.closeDelay
			},
			mouseOnly: !settings.events?.touch
		}),
		useFocus(context, {
			enabled: settings.events?.focus,
			visibleOnly: true
		}),
		useRole(context, { role: "tooltip" }),
		useDismiss(context, { enabled: typeof settings.opened === "undefined" })
	]);
	useFloatingAutoUpdate({
		opened,
		position: settings.position,
		positionDependencies: settings.positionDependencies,
		floating: {
			refs,
			update
		}
	});
	useDidUpdate(() => {
		settings.onPositionChange?.(placement);
	}, [placement]);
	const isGroupPhase = opened && currentId && currentId !== uid;
	return {
		x,
		y,
		arrowX,
		arrowY,
		reference: refs.setReference,
		floating: refs.setFloating,
		getFloatingProps,
		getReferenceProps,
		isGroupPhase,
		opened,
		placement
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tooltip/Tooltip.mjs
const defaultProps$30 = {
	position: "top",
	refProp: "ref",
	withinPortal: true,
	inline: false,
	defaultOpened: false,
	arrowSize: 4,
	arrowOffset: 5,
	arrowRadius: 0,
	arrowPosition: "side",
	offset: 5,
	transitionProps: {
		duration: 100,
		transition: "fade"
	},
	events: {
		hover: true,
		focus: false,
		touch: false
	},
	zIndex: getDefaultZIndex("popover"),
	positionDependencies: [],
	middlewares: {
		flip: true,
		shift: true,
		inline: false
	}
};
const varsResolver$18 = createVarsResolver((theme, { radius, color }) => ({ tooltip: {
	"--tooltip-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--tooltip-bg": color ? getThemeColor(color, theme) : void 0,
	"--tooltip-color": color ? "var(--mantine-color-white)" : void 0
} }));
const Tooltip = factory((_props, ref) => {
	const props = useProps("Tooltip", defaultProps$30, _props);
	const { children, position, refProp, label, openDelay, closeDelay, onPositionChange, opened, defaultOpened, withinPortal, radius, color, classNames, styles, unstyled, style, className, withArrow, arrowSize, arrowOffset, arrowRadius, arrowPosition, offset: offset$3, transitionProps, multiline, events, zIndex, disabled, positionDependencies, onClick, onMouseEnter, onMouseLeave, inline: inline$3, variant, keepMounted, vars, portalProps, mod, floatingStrategy, middlewares,...others } = useProps("Tooltip", defaultProps$30, props);
	const { dir } = useDirection();
	const arrowRef = (0, import_react.useRef)(null);
	const tooltip = useTooltip({
		position: getFloatingPosition(dir, position),
		closeDelay,
		openDelay,
		onPositionChange,
		opened,
		defaultOpened,
		events,
		arrowRef,
		arrowOffset,
		offset: typeof offset$3 === "number" ? offset$3 + (withArrow ? arrowSize / 2 : 0) : offset$3,
		positionDependencies: [...positionDependencies, children],
		inline: inline$3,
		strategy: floatingStrategy,
		middlewares
	});
	const getStyles$1 = useStyles({
		name: "Tooltip",
		props,
		classes: classes$18,
		className,
		style,
		classNames,
		styles,
		unstyled,
		rootSelector: "tooltip",
		vars,
		varsResolver: varsResolver$18
	});
	if (!isElement(children)) throw new Error("[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported");
	const targetRef = useMergedRef(tooltip.reference, getRefProp(children), ref);
	const transition = getTransitionProps(transitionProps, {
		duration: 100,
		transition: "fade"
	});
	const _childrenProps = children.props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...portalProps,
		withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			...transition,
			keepMounted,
			mounted: !disabled && !!tooltip.opened,
			duration: tooltip.isGroupPhase ? 10 : transition.duration,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
				...others,
				"data-fixed": floatingStrategy === "fixed" || void 0,
				variant,
				mod: [{ multiline }, mod],
				...tooltip.getFloatingProps({
					ref: tooltip.floating,
					className: getStyles$1("tooltip").className,
					style: {
						...getStyles$1("tooltip").style,
						...transitionStyles,
						zIndex,
						top: tooltip.y ?? 0,
						left: tooltip.x ?? 0
					}
				}),
				children: [label, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FloatingArrow, {
					ref: arrowRef,
					arrowX: tooltip.arrowX,
					arrowY: tooltip.arrowY,
					visible: withArrow,
					position: tooltip.placement,
					arrowSize,
					arrowOffset,
					arrowRadius,
					arrowPosition,
					...getStyles$1("arrow")
				})]
			})
		})
	}), (0, import_react.cloneElement)(children, tooltip.getReferenceProps({
		onClick,
		onMouseEnter,
		onMouseLeave,
		onMouseMove: props.onMouseMove,
		onPointerDown: props.onPointerDown,
		onPointerEnter: props.onPointerEnter,
		className: clsx_default(className, _childrenProps.className),
		..._childrenProps,
		[refProp]: targetRef
	}))] });
});
Tooltip.classes = classes$18;
Tooltip.displayName = "@mantine/core/Tooltip";
Tooltip.Floating = TooltipFloating;
Tooltip.Group = TooltipGroup;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/RingProgress/Curve/get-curve-props.mjs
function getCurveProps({ size: size$3, thickness, sum, value, root, offset: offset$3 }) {
	const radius = (size$3 * .9 - thickness * 2) / 2;
	const deg = Math.PI * radius * 2 / 100;
	const strokeDasharray = root || value === void 0 ? `${(100 - sum) * deg}, ${sum * deg}` : `${value * deg}, ${(100 - value) * deg}`;
	return {
		strokeWidth: Number.isNaN(thickness) ? 12 : thickness,
		cx: size$3 / 2 || 0,
		cy: size$3 / 2 || 0,
		r: radius || 0,
		transform: root ? `scale(1, -1) translate(0, -${size$3})` : void 0,
		strokeDasharray,
		strokeDashoffset: root ? 0 : offset$3 || 0
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/RingProgress/Curve/Curve.mjs
function Curve({ size: size$3, value, offset: offset$3, sum, thickness, root, color, lineRoundCaps, tooltip, getStyles: getStyles$1, display,...others }) {
	const theme = useMantineTheme();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tooltip.Floating, {
		disabled: !tooltip,
		label: tooltip,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			component: "circle",
			...others,
			...getStyles$1("curve"),
			__vars: { "--curve-color": color ? getThemeColor(color, theme) : void 0 },
			fill: "none",
			strokeLinecap: lineRoundCaps ? "round" : "butt",
			...getCurveProps({
				sum,
				size: size$3,
				thickness,
				value,
				offset: offset$3,
				root
			})
		})
	});
}
Curve.displayName = "@mantine/core/Curve";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/RingProgress/get-curves/get-curves.mjs
function getCurves({ size: size$3, thickness, sections, renderRoundedLineCaps, rootColor }) {
	const sum = sections.reduce((acc, current) => acc + current.value, 0);
	const accumulated = Math.PI * ((size$3 * .9 - thickness * 2) / 2) * 2;
	let offset$3 = accumulated;
	const curves = [];
	const curvesInOrder = [];
	for (let i = 0; i < sections.length; i += 1) {
		curves.push({
			sum,
			offset: offset$3,
			data: sections[i],
			root: false
		});
		offset$3 -= sections[i].value / 100 * accumulated;
	}
	curves.push({
		sum,
		offset: offset$3,
		data: { color: rootColor },
		root: true
	});
	curvesInOrder.push({
		...curves[curves.length - 1],
		lineRoundCaps: false
	});
	if (curves.length > 2) {
		curvesInOrder.push({
			...curves[0],
			lineRoundCaps: renderRoundedLineCaps
		});
		curvesInOrder.push({
			...curves[curves.length - 2],
			lineRoundCaps: renderRoundedLineCaps
		});
		for (let i = 1; i <= curves.length - 3; i += 1) curvesInOrder.push({
			...curves[i],
			lineRoundCaps: false
		});
	} else curvesInOrder.push({
		...curves[0],
		lineRoundCaps: renderRoundedLineCaps
	});
	return curvesInOrder;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/RingProgress/RingProgress.module.css.mjs
var classes$17 = {
	"root": "m_b32e4812",
	"svg": "m_d43b5134",
	"curve": "m_b1ca1fbf",
	"label": "m_b23f9dc4"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/RingProgress/RingProgress.mjs
function getClampedThickness(thickness, size$3) {
	return Math.min(thickness || 12, (size$3 || 120) / 4);
}
const defaultProps$29 = {
	size: 120,
	thickness: 12
};
const varsResolver$17 = createVarsResolver((_, { size: size$3, thickness, transitionDuration }) => ({ root: {
	"--rp-size": rem(size$3),
	"--rp-label-offset": rem(thickness * 2),
	"--rp-transition-duration": transitionDuration ? `${transitionDuration}ms` : void 0
} }));
const RingProgress = factory((_props, ref) => {
	const props = useProps("RingProgress", defaultProps$29, _props);
	const { classNames, className, style, styles, unstyled, vars, label, sections, size: size$3, thickness, roundCaps, rootColor, transitionDuration,...others } = props;
	const getStyles$1 = useStyles({
		name: "RingProgress",
		classes: classes$17,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$17
	});
	const clampedThickness = getClampedThickness(thickness, size$3);
	const curves = getCurves({
		size: size$3,
		thickness: clampedThickness,
		sections,
		renderRoundedLineCaps: roundCaps,
		rootColor
	}).map(({ data, sum, root, lineRoundCaps, offset: offset$3 }, index$4) => /* @__PURE__ */ (0, import_react.createElement)(Curve, {
		...data,
		key: index$4,
		size: size$3,
		thickness: clampedThickness,
		sum,
		offset: offset$3,
		color: data?.color,
		root,
		lineRoundCaps,
		getStyles: getStyles$1
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("root"),
		size: size$3,
		ref,
		...others,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
			...getStyles$1("svg"),
			children: curves
		}), label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...getStyles$1("label"),
			children: label
		})]
	});
});
RingProgress.classes = classes$17;
RingProgress.displayName = "@mantine/core/RingProgress";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SegmentedControl/SegmentedControl.module.css.mjs
var classes$16 = {
	"root": "m_cf365364",
	"indicator": "m_9e182ccd",
	"label": "m_1738fcb2",
	"input": "m_1714d588",
	"control": "m_69686b9b",
	"innerLabel": "m_78882f40"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SegmentedControl/SegmentedControl.mjs
const defaultProps$28 = { withItemsBorders: true };
const varsResolver$16 = createVarsResolver((theme, { radius, color, transitionDuration, size: size$3, transitionTimingFunction }) => ({ root: {
	"--sc-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--sc-color": color ? getThemeColor(color, theme) : void 0,
	"--sc-shadow": color ? void 0 : "var(--mantine-shadow-xs)",
	"--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
	"--sc-transition-timing-function": transitionTimingFunction,
	"--sc-padding": getSize(size$3, "sc-padding"),
	"--sc-font-size": getFontSize(size$3)
} }));
const SegmentedControl = factory((_props, ref) => {
	const props = useProps("SegmentedControl", defaultProps$28, _props);
	const { classNames, className, style, styles, unstyled, vars, data, value, defaultValue, onChange, size: size$3, name, disabled, readOnly, fullWidth, orientation, radius, color, transitionDuration, transitionTimingFunction, variant, autoContrast, withItemsBorders, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "SegmentedControl",
		props,
		classes: classes$16,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$16
	});
	const theme = useMantineTheme();
	const _data = data.map((item) => typeof item === "string" ? {
		label: item,
		value: item
	} : item);
	const initialized = useMounted();
	const [key, setKey] = (0, import_react.useState)(randomId());
	const [parent, setParent] = (0, import_react.useState)(null);
	const [refs, setRefs] = (0, import_react.useState)({});
	const setElementRef = (element, val) => {
		refs[val] = element;
		setRefs(refs);
	};
	const [_value, handleValueChange] = useUncontrolled({
		value,
		defaultValue,
		finalValue: Array.isArray(data) ? _data.find((item) => !item.disabled)?.value ?? data[0]?.value ?? null : null,
		onChange
	});
	const uuid = useId(name);
	const controls = _data.map((item) => /* @__PURE__ */ (0, import_react.createElement)(Box, {
		...getStyles$1("control"),
		mod: {
			active: _value === item.value,
			orientation
		},
		key: item.value
	}, /* @__PURE__ */ (0, import_react.createElement)("input", {
		...getStyles$1("input"),
		disabled: disabled || item.disabled,
		type: "radio",
		name: uuid,
		value: item.value,
		id: `${uuid}-${item.value}`,
		checked: _value === item.value,
		onChange: () => !readOnly && handleValueChange(item.value),
		"data-focus-ring": theme.focusRing,
		key: `${item.value}-input`
	}), /* @__PURE__ */ (0, import_react.createElement)(Box, {
		component: "label",
		...getStyles$1("label"),
		mod: {
			active: _value === item.value && !(disabled || item.disabled),
			disabled: disabled || item.disabled,
			"read-only": readOnly
		},
		htmlFor: `${uuid}-${item.value}`,
		ref: (node) => setElementRef(node, item.value),
		__vars: { "--sc-label-color": color !== void 0 ? getContrastColor({
			color,
			theme,
			autoContrast
		}) : void 0 },
		key: `${item.value}-label`
	}, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		...getStyles$1("innerLabel"),
		children: item.label
	}))));
	const mergedRef = useMergedRef(ref, (node) => setParent(node));
	useShallowEffect(() => {
		setKey(randomId());
	}, [data.length]);
	if (data.length === 0) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("root"),
		variant,
		size: size$3,
		ref: mergedRef,
		mod: [{
			"full-width": fullWidth,
			orientation,
			initialized,
			"with-items-borders": withItemsBorders
		}, mod],
		...others,
		role: "radiogroup",
		"data-disabled": disabled,
		children: [typeof _value === "string" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FloatingIndicator, {
			target: refs[_value],
			parent,
			component: "span",
			transitionDuration: "var(--sc-transition-duration)",
			...getStyles$1("indicator")
		}, key), controls]
	});
});
SegmentedControl.classes = classes$16;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Select/Select.mjs
const defaultProps$27 = {
	searchable: false,
	withCheckIcon: true,
	allowDeselect: true,
	checkIconPosition: "left"
};
const Select = factory((_props, ref) => {
	const props = useProps("Select", defaultProps$27, _props);
	const { classNames, styles, unstyled, vars, dropdownOpened, defaultDropdownOpened, onDropdownClose, onDropdownOpen, onFocus, onBlur, onClick, onChange, data, value, defaultValue, selectFirstOptionOnChange, onOptionSubmit, comboboxProps, readOnly, disabled, filter, limit, withScrollArea, maxDropdownHeight, size: size$3, searchable, rightSection, checkIconPosition, withCheckIcon, nothingFoundMessage, name, form, searchValue, defaultSearchValue, onSearchChange, allowDeselect, error: error$1, rightSectionPointerEvents, id, clearable, clearButtonProps, hiddenInputProps, renderOption, onClear, autoComplete, scrollAreaProps, __defaultRightSection, __clearSection, __clearable, chevronColor,...others } = props;
	const parsedData = (0, import_react.useMemo)(() => getParsedComboboxData(data), [data]);
	const optionsLockup = (0, import_react.useMemo)(() => getOptionsLockup(parsedData), [parsedData]);
	const _id = useId(id);
	const [_value, setValue, controlled] = useUncontrolled({
		value,
		defaultValue,
		finalValue: null,
		onChange
	});
	const selectedOption = typeof _value === "string" ? optionsLockup[_value] : void 0;
	const previousSelectedOption = usePrevious(selectedOption);
	const [search, setSearch, searchControlled] = useUncontrolled({
		value: searchValue,
		defaultValue: defaultSearchValue,
		finalValue: selectedOption ? selectedOption.label : "",
		onChange: onSearchChange
	});
	const combobox = useCombobox({
		opened: dropdownOpened,
		defaultOpened: defaultDropdownOpened,
		onDropdownOpen: () => {
			onDropdownOpen?.();
			combobox.updateSelectedOptionIndex("active", { scrollIntoView: true });
		},
		onDropdownClose: () => {
			onDropdownClose?.();
			combobox.resetSelectedOption();
		}
	});
	const handleSearchChange = (value2) => {
		setSearch(value2);
		combobox.resetSelectedOption();
	};
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		props,
		styles,
		classNames
	});
	(0, import_react.useEffect)(() => {
		if (selectFirstOptionOnChange) combobox.selectFirstOption();
	}, [selectFirstOptionOnChange, search]);
	(0, import_react.useEffect)(() => {
		if (value === null) handleSearchChange("");
		if (typeof value === "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label)) handleSearchChange(selectedOption.label);
	}, [value, selectedOption]);
	(0, import_react.useEffect)(() => {
		if (!controlled && !searchControlled) handleSearchChange(typeof _value === "string" ? optionsLockup[_value]?.label || "" : "");
	}, [data, _value]);
	const clearButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.ClearButton, {
		...clearButtonProps,
		onClear: () => {
			setValue(null, null);
			handleSearchChange("");
			onClear?.();
		}
	});
	const _clearable = clearable && !!_value && !disabled && !readOnly;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox, {
		store: combobox,
		__staticSelector: "Select",
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		readOnly,
		onOptionSubmit: (val) => {
			onOptionSubmit?.(val);
			const optionLockup = allowDeselect ? optionsLockup[val].value === _value ? null : optionsLockup[val] : optionsLockup[val];
			const nextValue = optionLockup ? optionLockup.value : null;
			nextValue !== _value && setValue(nextValue, optionLockup);
			!controlled && handleSearchChange(typeof nextValue === "string" ? optionLockup?.label || "" : "");
			combobox.closeDropdown();
		},
		size: size$3,
		...comboboxProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Target, {
			targetType: searchable ? "input" : "button",
			autoComplete,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
				id: _id,
				ref,
				__defaultRightSection: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Chevron, {
					size: size$3,
					error: error$1,
					unstyled,
					color: chevronColor
				}),
				__clearSection: clearButton,
				__clearable: _clearable,
				rightSection,
				rightSectionPointerEvents: rightSectionPointerEvents || (_clearable ? "all" : "none"),
				...others,
				size: size$3,
				__staticSelector: "Select",
				disabled,
				readOnly: readOnly || !searchable,
				value: search,
				onChange: (event) => {
					handleSearchChange(event.currentTarget.value);
					combobox.openDropdown();
					selectFirstOptionOnChange && combobox.selectFirstOption();
				},
				onFocus: (event) => {
					searchable && combobox.openDropdown();
					onFocus?.(event);
				},
				onBlur: (event) => {
					searchable && combobox.closeDropdown();
					handleSearchChange(_value != null ? optionsLockup[_value]?.label || "" : "");
					onBlur?.(event);
				},
				onClick: (event) => {
					searchable ? combobox.openDropdown() : combobox.toggleDropdown();
					onClick?.(event);
				},
				classNames: resolvedClassNames,
				styles: resolvedStyles,
				unstyled,
				pointer: !searchable,
				error: error$1
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionsDropdown, {
			data: parsedData,
			hidden: readOnly || disabled,
			filter,
			search,
			limit,
			hiddenWhenEmpty: !nothingFoundMessage,
			withScrollArea,
			maxDropdownHeight,
			filterOptions: searchable && selectedOption?.label !== search,
			value: _value,
			checkIconPosition,
			withCheckIcon,
			nothingFoundMessage,
			unstyled,
			labelId: others.label ? `${_id}-label` : void 0,
			"aria-label": others.label ? void 0 : others["aria-label"],
			renderOption,
			scrollAreaProps
		})]
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.HiddenInput, {
		value: _value,
		name,
		form,
		disabled,
		...hiddenInputProps
	})] });
});
Select.classes = {
	...InputBase.classes,
	...Combobox.classes
};
Select.displayName = "@mantine/core/Select";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SemiCircleProgress/SemiCircleProgress.module.css.mjs
var classes$15 = {
	"root": "m_fa528724",
	"svg": "m_62e9e7e2",
	"filledSegment": "m_c573fb6f",
	"label": "m_4fa340f2"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SemiCircleProgress/SemiCircleProgress.mjs
const defaultProps$26 = {
	size: 200,
	thickness: 12,
	orientation: "up",
	fillDirection: "left-to-right",
	labelPosition: "bottom"
};
function getRotation({ orientation, fillDirection }) {
	if (orientation === "down") {
		if (fillDirection === "right-to-left") return "rotate(180deg) rotateY(180deg)";
		return "rotate(180deg)";
	}
	if (fillDirection === "left-to-right") return "rotateY(180deg)";
	return void 0;
}
const varsResolver$15 = createVarsResolver((theme, { filledSegmentColor, emptySegmentColor, orientation, fillDirection, transitionDuration, thickness }) => ({ root: {
	"--scp-filled-segment-color": filledSegmentColor ? getThemeColor(filledSegmentColor, theme) : void 0,
	"--scp-empty-segment-color": emptySegmentColor ? getThemeColor(emptySegmentColor, theme) : void 0,
	"--scp-rotation": getRotation({
		orientation,
		fillDirection
	}),
	"--scp-transition-duration": transitionDuration ? `${transitionDuration}ms` : void 0,
	"--scp-thickness": rem(thickness)
} }));
const SemiCircleProgress = factory((_props, ref) => {
	const props = useProps("SemiCircleProgress", defaultProps$26, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, thickness, value, orientation, fillDirection, filledSegmentColor, emptySegmentColor, transitionDuration, label, labelPosition,...others } = props;
	const getStyles$1 = useStyles({
		name: "SemiCircleProgress",
		classes: classes$15,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$15
	});
	const coordinateForCircle = size$3 / 2;
	const radius = (size$3 - 2 * thickness) / 2;
	const circumference = Math.PI * radius;
	const semiCirclePercentage = clamp(value, 0, 100) * (circumference / 100);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref,
		size: size$3,
		...getStyles$1("root"),
		...others,
		children: [label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			...getStyles$1("label"),
			"data-position": labelPosition,
			"data-orientation": orientation,
			children: label
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", {
			width: size$3,
			height: size$3 / 2,
			...getStyles$1("svg"),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", {
				cx: coordinateForCircle,
				cy: coordinateForCircle,
				r: radius,
				fill: "none",
				stroke: "var(--scp-empty-segment-color)",
				strokeWidth: thickness,
				strokeDasharray: circumference,
				...getStyles$1("emptySegment", { style: { strokeDashoffset: circumference } })
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("circle", {
				cx: coordinateForCircle,
				cy: coordinateForCircle,
				r: radius,
				fill: "none",
				stroke: "var(--scp-filled-segment-color)",
				strokeWidth: thickness,
				strokeDasharray: circumference,
				...getStyles$1("filledSegment", { style: { strokeDashoffset: semiCirclePercentage } })
			})]
		})]
	});
});
SemiCircleProgress.displayName = "@mantine/core/SemiCircleProgress";
SemiCircleProgress.classes = classes$15;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGridVariables.mjs
function SimpleGridMediaVariables({ spacing, verticalSpacing, cols, selector }) {
	const theme = useMantineTheme();
	const _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing;
	const baseStyles = filterProps({
		"--sg-spacing-x": getSpacing(getBaseValue(spacing)),
		"--sg-spacing-y": getSpacing(getBaseValue(_verticalSpacing)),
		"--sg-cols": getBaseValue(cols)?.toString()
	});
	const queries = keys(theme.breakpoints).reduce((acc, breakpoint) => {
		if (!acc[breakpoint]) acc[breakpoint] = {};
		if (typeof spacing === "object" && spacing[breakpoint] !== void 0) acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint]);
		if (typeof _verticalSpacing === "object" && _verticalSpacing[breakpoint] !== void 0) acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint]);
		if (typeof cols === "object" && cols[breakpoint] !== void 0) acc[breakpoint]["--sg-cols"] = cols[breakpoint];
		return acc;
	}, {});
	const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme.breakpoints).filter((breakpoint) => keys(queries[breakpoint.value]).length > 0);
	const media = sortedBreakpoints.map((breakpoint) => ({
		query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
		styles: queries[breakpoint.value]
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		styles: baseStyles,
		media,
		selector
	});
}
function getBreakpoints(values$1) {
	if (typeof values$1 === "object" && values$1 !== null) return keys(values$1);
	return [];
}
function sortBreakpoints(breakpoints) {
	return breakpoints.sort((a, b) => px(a) - px(b));
}
function getUniqueBreakpoints({ spacing, verticalSpacing, cols }) {
	const breakpoints = Array.from(/* @__PURE__ */ new Set([
		...getBreakpoints(spacing),
		...getBreakpoints(verticalSpacing),
		...getBreakpoints(cols)
	]));
	return sortBreakpoints(breakpoints);
}
function SimpleGridContainerVariables({ spacing, verticalSpacing, cols, selector }) {
	const _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing;
	const baseStyles = filterProps({
		"--sg-spacing-x": getSpacing(getBaseValue(spacing)),
		"--sg-spacing-y": getSpacing(getBaseValue(_verticalSpacing)),
		"--sg-cols": getBaseValue(cols)?.toString()
	});
	const uniqueBreakpoints = getUniqueBreakpoints({
		spacing,
		verticalSpacing,
		cols
	});
	const queries = uniqueBreakpoints.reduce((acc, breakpoint) => {
		if (!acc[breakpoint]) acc[breakpoint] = {};
		if (typeof spacing === "object" && spacing[breakpoint] !== void 0) acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint]);
		if (typeof _verticalSpacing === "object" && _verticalSpacing[breakpoint] !== void 0) acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint]);
		if (typeof cols === "object" && cols[breakpoint] !== void 0) acc[breakpoint]["--sg-cols"] = cols[breakpoint];
		return acc;
	}, {});
	const media = uniqueBreakpoints.map((breakpoint) => ({
		query: `simple-grid (min-width: ${breakpoint})`,
		styles: queries[breakpoint]
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		styles: baseStyles,
		container: media,
		selector
	});
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGrid.module.css.mjs
var classes$14 = {
	"container": "m_925c2d2c",
	"root": "m_2415a157"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/SimpleGrid/SimpleGrid.mjs
const defaultProps$25 = {
	cols: 1,
	spacing: "md",
	type: "media"
};
const SimpleGrid = factory((_props, ref) => {
	const props = useProps("SimpleGrid", defaultProps$25, _props);
	const { classNames, className, style, styles, unstyled, vars, cols, verticalSpacing, spacing, type,...others } = props;
	const getStyles$1 = useStyles({
		name: "SimpleGrid",
		classes: classes$14,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars
	});
	const responsiveClassName = useRandomClassName();
	if (type === "container") return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SimpleGridContainerVariables, {
		...props,
		selector: `.${responsiveClassName}`
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...getStyles$1("container"),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			...getStyles$1("root", { className: responsiveClassName }),
			...others
		})
	})] });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SimpleGridMediaVariables, {
		...props,
		selector: `.${responsiveClassName}`
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root", { className: responsiveClassName }),
		...others
	})] });
});
SimpleGrid.classes = classes$14;
SimpleGrid.displayName = "@mantine/core/SimpleGrid";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Skeleton/Skeleton.module.css.mjs
var classes$13 = {
	"root": "m_18320242",
	"skeleton-fade": "m_299c329c"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Skeleton/Skeleton.mjs
const defaultProps$24 = {
	visible: true,
	animate: true
};
const varsResolver$14 = createVarsResolver((_, { width, height, radius, circle }) => ({ root: {
	"--skeleton-height": rem(height),
	"--skeleton-width": circle ? rem(height) : rem(width),
	"--skeleton-radius": circle ? "1000px" : radius === void 0 ? void 0 : getRadius(radius)
} }));
const Skeleton = factory((_props, ref) => {
	const props = useProps("Skeleton", defaultProps$24, _props);
	const { classNames, className, style, styles, unstyled, vars, width, height, circle, visible, radius, animate, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Skeleton",
		classes: classes$13,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$14
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		mod: [{
			visible,
			animate
		}, mod],
		...others
	});
});
Skeleton.classes = classes$13;
Skeleton.displayName = "@mantine/core/Skeleton";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Slider.context.mjs
const [SliderProvider, useSliderContext] = createSafeContext("SliderProvider was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/SliderRoot/SliderRoot.mjs
const SliderRoot = (0, import_react.forwardRef)(({ size: size$3, disabled, variant, color, thumbSize, radius,...others }, ref) => {
	const { getStyles: getStyles$1 } = useSliderContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		tabIndex: -1,
		variant,
		size: size$3,
		ref,
		...getStyles$1("root"),
		...others
	});
});
SliderRoot.displayName = "@mantine/core/SliderRoot";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Thumb/Thumb.mjs
const Thumb = (0, import_react.forwardRef)(({ max: max$1, min: min$1, value, position, label, dragging, onMouseDown, onKeyDownCapture, labelTransitionProps, labelAlwaysOn, thumbLabel, onFocus, onBlur, showLabelOnHover, isHovered, children = null, disabled }, ref) => {
	const { getStyles: getStyles$1 } = useSliderContext();
	const [focused, setFocused] = (0, import_react.useState)(false);
	const isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		tabIndex: 0,
		role: "slider",
		"aria-label": thumbLabel,
		"aria-valuemax": max$1,
		"aria-valuemin": min$1,
		"aria-valuenow": value,
		ref,
		__vars: { "--slider-thumb-offset": `${position}%` },
		...getStyles$1("thumb", { focusable: true }),
		mod: {
			dragging,
			disabled
		},
		onFocus: (event) => {
			setFocused(true);
			typeof onFocus === "function" && onFocus(event);
		},
		onBlur: (event) => {
			setFocused(false);
			typeof onBlur === "function" && onBlur(event);
		},
		onTouchStart: onMouseDown,
		onMouseDown,
		onKeyDownCapture,
		onClick: (event) => event.stopPropagation(),
		children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: label != null && !!isVisible,
			transition: "fade",
			duration: 0,
			...labelTransitionProps,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("label", { style: transitionStyles }),
				children: label
			})
		})]
	});
});
Thumb.displayName = "@mantine/core/SliderThumb";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-position/get-position.mjs
function getPosition({ value, min: min$1, max: max$1 }) {
	const position = (value - min$1) / (max$1 - min$1) * 100;
	return Math.min(Math.max(position, 0), 100);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Marks/is-mark-filled.mjs
function isMarkFilled({ mark, offset: offset$3, value, inverted = false }) {
	return inverted ? typeof offset$3 === "number" ? mark.value <= offset$3 || mark.value >= value : mark.value >= value : typeof offset$3 === "number" ? mark.value >= offset$3 && mark.value <= value : mark.value <= value;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Marks/Marks.mjs
function Marks({ marks, min: min$1, max: max$1, disabled, value, offset: offset$3, inverted }) {
	const { getStyles: getStyles$1 } = useSliderContext();
	if (!marks) return null;
	const items = marks.map((mark, index$4) => /* @__PURE__ */ (0, import_react.createElement)(Box, {
		...getStyles$1("markWrapper"),
		__vars: { "--mark-offset": `${getPosition({
			value: mark.value,
			min: min$1,
			max: max$1
		})}%` },
		key: index$4
	}, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("mark"),
		mod: {
			filled: isMarkFilled({
				mark,
				value,
				offset: offset$3,
				inverted
			}),
			disabled
		}
	}), mark.label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...getStyles$1("markLabel"),
		children: mark.label
	})));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Track/Track.mjs
function Track({ filled, children, offset: offset$3, disabled, marksOffset, inverted, containerProps,...others }) {
	const { getStyles: getStyles$1 } = useSliderContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("trackContainer"),
		mod: { disabled },
		...containerProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("track"),
			mod: {
				inverted,
				disabled
			},
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					mod: {
						inverted,
						disabled
					},
					__vars: {
						"--slider-bar-width": `calc(${filled}% + 2 * var(--slider-size))`,
						"--slider-bar-offset": `calc(${offset$3}% - var(--slider-size))`
					},
					...getStyles$1("bar")
				}),
				children,
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Marks, {
					...others,
					offset: marksOffset,
					disabled,
					inverted
				})
			]
		})
	});
}
Track.displayName = "@mantine/core/SliderTrack";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-change-value/get-change-value.mjs
function getChangeValue({ value, containerWidth, min: min$1, max: max$1, step, precision }) {
	const left = !containerWidth ? value : Math.min(Math.max(value, 0), containerWidth) / containerWidth;
	const dx = left * (max$1 - min$1);
	const nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min$1;
	const nextValueWithinStep = Math.max(nextValue, min$1);
	if (precision !== void 0) return Number(nextValueWithinStep.toFixed(precision));
	return nextValueWithinStep;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-floating-value/get-gloating-value.mjs
function getFloatingValue(value, precision) {
	return parseFloat(value.toFixed(precision));
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-precision/get-precision.mjs
function getPrecision(step) {
	if (!step) return 0;
	const split = step.toString().split(".");
	return split.length > 1 ? split[1].length : 0;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-step-mark-value/get-step-mark-value.mjs
function getNextMarkValue(currentValue, marks) {
	const sortedMarks = [...marks].sort((a, b) => a.value - b.value);
	const nextMark = sortedMarks.find((mark) => mark.value > currentValue);
	return nextMark ? nextMark.value : currentValue;
}
function getPreviousMarkValue(currentValue, marks) {
	const sortedMarks = [...marks].sort((a, b) => b.value - a.value);
	const previousMark = sortedMarks.find((mark) => mark.value < currentValue);
	return previousMark ? previousMark.value : currentValue;
}
function getFirstMarkValue(marks) {
	const sortedMarks = [...marks].sort((a, b) => a.value - b.value);
	return sortedMarks.length > 0 ? sortedMarks[0].value : 0;
}
function getLastMarkValue(marks) {
	const sortedMarks = [...marks].sort((a, b) => a.value - b.value);
	return sortedMarks.length > 0 ? sortedMarks[sortedMarks.length - 1].value : 100;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Slider.module.css.mjs
var classes$12 = {
	"root": "m_dd36362e",
	"label": "m_c9357328",
	"thumb": "m_c9a9a60a",
	"trackContainer": "m_a8645c2",
	"track": "m_c9ade57f",
	"bar": "m_38aeed47",
	"markWrapper": "m_b7b0423a",
	"mark": "m_dd33bc19",
	"markLabel": "m_68c77a5b"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/Slider/Slider.mjs
const defaultProps$23 = {
	radius: "xl",
	min: 0,
	max: 100,
	step: 1,
	marks: [],
	label: (f) => f,
	labelTransitionProps: {
		transition: "fade",
		duration: 0
	},
	labelAlwaysOn: false,
	thumbLabel: "",
	showLabelOnHover: true,
	disabled: false,
	scale: (v) => v
};
const varsResolver$13 = createVarsResolver((theme, { size: size$3, color, thumbSize, radius }) => ({ root: {
	"--slider-size": getSize(size$3, "slider-size"),
	"--slider-color": color ? getThemeColor(color, theme) : void 0,
	"--slider-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
} }));
const Slider = factory((_props, ref) => {
	const props = useProps("Slider", defaultProps$23, _props);
	const { classNames, styles, value, onChange, onChangeEnd, size: size$3, min: min$1, max: max$1, step, precision: _precision, defaultValue, name, marks, label, labelTransitionProps, labelAlwaysOn, thumbLabel, showLabelOnHover, thumbChildren, disabled, unstyled, scale, inverted, className, style, vars, hiddenInputProps, restrictToMarks, thumbProps,...others } = props;
	const getStyles$1 = useStyles({
		name: "Slider",
		props,
		classes: classes$12,
		classNames,
		className,
		styles,
		style,
		vars,
		varsResolver: varsResolver$13,
		unstyled
	});
	const { dir } = useDirection();
	const [hovered, setHovered] = (0, import_react.useState)(false);
	const [_value, setValue] = useUncontrolled({
		value: typeof value === "number" ? clamp(value, min$1, max$1) : value,
		defaultValue: typeof defaultValue === "number" ? clamp(defaultValue, min$1, max$1) : defaultValue,
		finalValue: clamp(0, min$1, max$1),
		onChange
	});
	const valueRef = (0, import_react.useRef)(_value);
	const onChangeEndRef = (0, import_react.useRef)(onChangeEnd);
	(0, import_react.useEffect)(() => {
		onChangeEndRef.current = onChangeEnd;
	}, [onChangeEnd]);
	const root = (0, import_react.useRef)(null);
	const thumb = (0, import_react.useRef)(null);
	const position = getPosition({
		value: _value,
		min: min$1,
		max: max$1
	});
	const scaledValue = scale(_value);
	const _label = typeof label === "function" ? label(scaledValue) : label;
	const precision = _precision ?? getPrecision(step);
	const handleChange = (0, import_react.useCallback)(({ x }) => {
		if (!disabled) {
			const nextValue = getChangeValue({
				value: x,
				min: min$1,
				max: max$1,
				step,
				precision
			});
			setValue(restrictToMarks && marks?.length ? findClosestNumber(nextValue, marks.map((mark) => mark.value)) : nextValue);
			valueRef.current = nextValue;
		}
	}, [
		disabled,
		min$1,
		max$1,
		step,
		precision,
		setValue,
		marks,
		restrictToMarks
	]);
	const handleScrubEnd = (0, import_react.useCallback)(() => {
		if (!disabled && onChangeEndRef.current) {
			const finalValue = restrictToMarks && marks?.length ? findClosestNumber(valueRef.current, marks.map((mark) => mark.value)) : valueRef.current;
			onChangeEndRef.current(finalValue);
		}
	}, [
		disabled,
		marks,
		restrictToMarks
	]);
	const { ref: container, active } = useMove(handleChange, { onScrubEnd: handleScrubEnd }, dir);
	const callOnChangeEnd = (0, import_react.useCallback)((value2) => {
		if (!disabled && onChangeEndRef.current) onChangeEndRef.current(value2);
	}, [disabled]);
	const handleTrackKeydownCapture = (event) => {
		if (!disabled) switch (event.key) {
			case "ArrowUp": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					const nextValue2 = getNextMarkValue(_value, marks);
					setValue(nextValue2);
					callOnChangeEnd(nextValue2);
					break;
				}
				const nextValue = getFloatingValue(Math.min(Math.max(_value + step, min$1), max$1), precision);
				setValue(nextValue);
				callOnChangeEnd(nextValue);
				break;
			}
			case "ArrowRight": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					const nextValue2 = dir === "rtl" ? getPreviousMarkValue(_value, marks) : getNextMarkValue(_value, marks);
					setValue(nextValue2);
					callOnChangeEnd(nextValue2);
					break;
				}
				const nextValue = getFloatingValue(Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min$1), max$1), precision);
				setValue(nextValue);
				callOnChangeEnd(nextValue);
				break;
			}
			case "ArrowDown": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					const nextValue2 = getPreviousMarkValue(_value, marks);
					setValue(nextValue2);
					callOnChangeEnd(nextValue2);
					break;
				}
				const nextValue = getFloatingValue(Math.min(Math.max(_value - step, min$1), max$1), precision);
				setValue(nextValue);
				callOnChangeEnd(nextValue);
				break;
			}
			case "ArrowLeft": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					const nextValue2 = dir === "rtl" ? getNextMarkValue(_value, marks) : getPreviousMarkValue(_value, marks);
					setValue(nextValue2);
					callOnChangeEnd(nextValue2);
					break;
				}
				const nextValue = getFloatingValue(Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min$1), max$1), precision);
				setValue(nextValue);
				callOnChangeEnd(nextValue);
				break;
			}
			case "Home": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					setValue(getFirstMarkValue(marks));
					callOnChangeEnd(getFirstMarkValue(marks));
					break;
				}
				setValue(min$1);
				callOnChangeEnd(min$1);
				break;
			}
			case "End": {
				event.preventDefault();
				thumb.current?.focus();
				if (restrictToMarks && marks) {
					setValue(getLastMarkValue(marks));
					callOnChangeEnd(getLastMarkValue(marks));
					break;
				}
				setValue(max$1);
				callOnChangeEnd(max$1);
				break;
			}
		}
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderProvider, {
		value: { getStyles: getStyles$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SliderRoot, {
			...others,
			ref: useMergedRef(ref, root),
			onKeyDownCapture: handleTrackKeydownCapture,
			onMouseDownCapture: () => root.current?.focus(),
			size: size$3,
			disabled,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Track, {
				inverted,
				offset: 0,
				filled: position,
				marks,
				min: min$1,
				max: max$1,
				value: scaledValue,
				disabled,
				containerProps: {
					ref: container,
					onMouseEnter: showLabelOnHover ? () => setHovered(true) : void 0,
					onMouseLeave: showLabelOnHover ? () => setHovered(false) : void 0
				},
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb, {
					max: max$1,
					min: min$1,
					value: scaledValue,
					position,
					dragging: active,
					label: _label,
					ref: thumb,
					labelTransitionProps,
					labelAlwaysOn,
					thumbLabel,
					showLabelOnHover,
					isHovered: hovered,
					disabled,
					...thumbProps,
					children: thumbChildren
				})
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
				type: "hidden",
				name,
				value: scaledValue,
				...hiddenInputProps
			})]
		})
	});
});
Slider.classes = classes$12;
Slider.displayName = "@mantine/core/Slider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/utils/get-client-position/get-client-position.mjs
function getClientPosition(event) {
	if ("TouchEvent" in window && event instanceof window.TouchEvent) {
		const touch = event.touches[0];
		return touch.clientX;
	}
	return event.clientX;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Slider/RangeSlider/RangeSlider.mjs
const varsResolver$12 = createVarsResolver((theme, { size: size$3, color, thumbSize, radius }) => ({ root: {
	"--slider-size": getSize(size$3, "slider-size"),
	"--slider-color": color ? getThemeColor(color, theme) : void 0,
	"--slider-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
} }));
const defaultProps$22 = {
	min: 0,
	max: 100,
	minRange: 10,
	step: 1,
	marks: [],
	label: (f) => f,
	labelTransitionProps: {
		transition: "fade",
		duration: 0
	},
	labelAlwaysOn: false,
	showLabelOnHover: true,
	disabled: false,
	scale: (v) => v
};
const RangeSlider = factory((_props, ref) => {
	const props = useProps("RangeSlider", defaultProps$22, _props);
	const { classNames, styles, value, onChange, onChangeEnd, size: size$3, min: min$1, max: max$1, minRange, maxRange, step, precision: _precision, defaultValue, name, marks, label, labelTransitionProps, labelAlwaysOn, thumbFromLabel, thumbToLabel, showLabelOnHover, thumbChildren, disabled, unstyled, scale, inverted, className, style, vars, hiddenInputProps, restrictToMarks, thumbProps,...others } = props;
	const getStyles$1 = useStyles({
		name: "Slider",
		props,
		classes: classes$12,
		classNames,
		className,
		styles,
		style,
		vars,
		varsResolver: varsResolver$12,
		unstyled
	});
	const { dir } = useDirection();
	const [focused, setFocused] = (0, import_react.useState)(-1);
	const [hovered, setHovered] = (0, import_react.useState)(false);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [min$1, max$1],
		onChange
	});
	const valueRef = (0, import_react.useRef)(_value);
	const thumbs = (0, import_react.useRef)([]);
	const root = (0, import_react.useRef)(null);
	const thumbIndex = (0, import_react.useRef)(void 0);
	const positions = [getPosition({
		value: _value[0],
		min: min$1,
		max: max$1
	}), getPosition({
		value: _value[1],
		min: min$1,
		max: max$1
	})];
	const precision = _precision ?? getPrecision(step);
	const _setValue = (val) => {
		setValue(val);
		valueRef.current = val;
	};
	(0, import_react.useEffect)(() => {
		if (Array.isArray(value)) valueRef.current = value;
	}, Array.isArray(value) ? [value[0], value[1]] : [null, null]);
	const setRangedValue = (val, index$4, triggerChangeEnd) => {
		if (index$4 === -1) return;
		const clone = [...valueRef.current];
		if (restrictToMarks && marks) {
			const closest = findClosestNumber(val, marks.map((m) => m.value));
			const current = clone[index$4];
			clone[index$4] = closest;
			const otherIndex = index$4 === 0 ? 1 : 0;
			const lastMarkValue = getLastMarkValue(marks);
			const firstMarkValue = getFirstMarkValue(marks);
			if (closest === lastMarkValue && clone[otherIndex] === lastMarkValue) clone[index$4] = current;
			else if (closest === firstMarkValue && clone[otherIndex] === firstMarkValue) clone[index$4] = current;
			else if (closest === clone[otherIndex]) if (current > clone[otherIndex]) clone[otherIndex] = getPreviousMarkValue(closest, marks);
			else clone[otherIndex] = getNextMarkValue(closest, marks);
		} else {
			clone[index$4] = val;
			if (index$4 === 0) {
				if (val > clone[1] - (minRange - 1e-9)) clone[1] = Math.min(val + minRange, max$1);
				if (val > (max$1 - (minRange - 1e-9) || min$1)) clone[index$4] = valueRef.current[index$4];
				if (clone[1] - val > maxRange) clone[1] = val + maxRange;
			}
			if (index$4 === 1) {
				if (val < clone[0] + minRange) clone[0] = Math.max(val - minRange, min$1);
				if (val < clone[0] + minRange) clone[index$4] = valueRef.current[index$4];
				if (val - clone[0] > maxRange) clone[0] = val - maxRange;
			}
		}
		clone[0] = getFloatingValue(clone[0], precision);
		clone[1] = getFloatingValue(clone[1], precision);
		if (clone[0] > clone[1]) {
			const temp = clone[0];
			clone[0] = clone[1];
			clone[1] = temp;
		}
		_setValue(clone);
		if (triggerChangeEnd) onChangeEnd?.(valueRef.current);
	};
	const handleChange = (val) => {
		if (!disabled) {
			const nextValue = getChangeValue({
				value: val,
				min: min$1,
				max: max$1,
				step,
				precision
			});
			setRangedValue(nextValue, thumbIndex.current, false);
		}
	};
	const { ref: container, active } = useMove(({ x }) => handleChange(x), { onScrubEnd: () => !disabled && onChangeEnd?.(valueRef.current) }, dir);
	function handleThumbMouseDown(index$4) {
		thumbIndex.current = index$4;
	}
	const handleTrackMouseDownCapture = (event) => {
		container.current.focus();
		const rect = container.current.getBoundingClientRect();
		const changePosition = getClientPosition(event.nativeEvent);
		const changeValue = getChangeValue({
			value: changePosition - rect.left,
			max: max$1,
			min: min$1,
			step,
			containerWidth: rect.width
		});
		const nearestHandle = Math.abs(_value[0] - changeValue) > Math.abs(_value[1] - changeValue) ? 1 : 0;
		const _nearestHandle = dir === "ltr" ? nearestHandle : nearestHandle === 1 ? 0 : 1;
		thumbIndex.current = _nearestHandle;
	};
	const getFocusedThumbIndex = () => {
		if (focused !== 1 && focused !== 0) {
			setFocused(0);
			return 0;
		}
		return focused;
	};
	const handleTrackKeydownCapture = (event) => {
		if (!disabled) switch (event.key) {
			case "ArrowUp": {
				event.preventDefault();
				const focusedIndex = getFocusedThumbIndex();
				thumbs.current[focusedIndex].focus();
				const nextValue = restrictToMarks && marks ? getNextMarkValue(valueRef.current[focusedIndex], marks) : Math.min(Math.max(valueRef.current[focusedIndex] + step, min$1), max$1);
				setRangedValue(getFloatingValue(nextValue, precision), focusedIndex, true);
				break;
			}
			case "ArrowRight": {
				event.preventDefault();
				const focusedIndex = getFocusedThumbIndex();
				thumbs.current[focusedIndex].focus();
				const nextValue = restrictToMarks && marks ? (dir === "rtl" ? getPreviousMarkValue : getNextMarkValue)(valueRef.current[focusedIndex], marks) : Math.min(Math.max(dir === "rtl" ? valueRef.current[focusedIndex] - step : valueRef.current[focusedIndex] + step, min$1), max$1);
				setRangedValue(getFloatingValue(nextValue, precision), focusedIndex, true);
				break;
			}
			case "ArrowDown": {
				event.preventDefault();
				const focusedIndex = getFocusedThumbIndex();
				thumbs.current[focusedIndex].focus();
				const nextValue = restrictToMarks && marks ? getPreviousMarkValue(valueRef.current[focusedIndex], marks) : Math.min(Math.max(valueRef.current[focusedIndex] - step, min$1), max$1);
				setRangedValue(getFloatingValue(nextValue, precision), focusedIndex, true);
				break;
			}
			case "ArrowLeft": {
				event.preventDefault();
				const focusedIndex = getFocusedThumbIndex();
				thumbs.current[focusedIndex].focus();
				const nextValue = restrictToMarks && marks ? (dir === "rtl" ? getNextMarkValue : getPreviousMarkValue)(valueRef.current[focusedIndex], marks) : Math.min(Math.max(dir === "rtl" ? valueRef.current[focusedIndex] + step : valueRef.current[focusedIndex] - step, min$1), max$1);
				setRangedValue(getFloatingValue(nextValue, precision), focusedIndex, true);
				break;
			}
		}
	};
	const sharedThumbProps = {
		max: max$1,
		min: min$1,
		size: size$3,
		labelTransitionProps,
		labelAlwaysOn,
		onBlur: () => setFocused(-1)
	};
	const hasArrayThumbChildren = Array.isArray(thumbChildren);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderProvider, {
		value: { getStyles: getStyles$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SliderRoot, {
			...others,
			size: size$3,
			ref: useMergedRef(ref, root),
			disabled,
			onMouseDownCapture: () => root.current?.focus(),
			onKeyDownCapture: () => {
				if (thumbs.current[0]?.parentElement?.contains(document.activeElement)) return;
				thumbs.current[0]?.focus();
			},
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Track, {
					offset: positions[0],
					marksOffset: _value[0],
					filled: positions[1] - positions[0],
					marks,
					inverted,
					min: min$1,
					max: max$1,
					value: _value[1],
					disabled,
					containerProps: {
						ref: container,
						onMouseEnter: showLabelOnHover ? () => setHovered(true) : void 0,
						onMouseLeave: showLabelOnHover ? () => setHovered(false) : void 0,
						onTouchStartCapture: handleTrackMouseDownCapture,
						onTouchEndCapture: () => {
							thumbIndex.current = -1;
						},
						onMouseDownCapture: handleTrackMouseDownCapture,
						onMouseUpCapture: () => {
							thumbIndex.current = -1;
						},
						onKeyDownCapture: handleTrackKeydownCapture
					},
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb, {
						...sharedThumbProps,
						value: scale(_value[0]),
						position: positions[0],
						dragging: active,
						label: typeof label === "function" ? label(getFloatingValue(scale(_value[0]), precision)) : label,
						ref: (node) => {
							thumbs.current[0] = node;
						},
						thumbLabel: thumbFromLabel,
						onMouseDown: () => handleThumbMouseDown(0),
						onFocus: () => setFocused(0),
						showLabelOnHover,
						isHovered: hovered,
						disabled,
						...thumbProps?.(0),
						children: hasArrayThumbChildren ? thumbChildren[0] : thumbChildren
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb, {
						...sharedThumbProps,
						thumbLabel: thumbToLabel,
						value: scale(_value[1]),
						position: positions[1],
						dragging: active,
						label: typeof label === "function" ? label(getFloatingValue(scale(_value[1]), precision)) : label,
						ref: (node) => {
							thumbs.current[1] = node;
						},
						onMouseDown: () => handleThumbMouseDown(1),
						onFocus: () => setFocused(1),
						showLabelOnHover,
						isHovered: hovered,
						disabled,
						...thumbProps?.(1),
						children: hasArrayThumbChildren ? thumbChildren[1] : thumbChildren
					})]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
					type: "hidden",
					name: `${name}_from`,
					value: _value[0],
					...hiddenInputProps
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
					type: "hidden",
					name: `${name}_to`,
					value: _value[1],
					...hiddenInputProps
				})
			]
		})
	});
});
RangeSlider.classes = classes$12;
RangeSlider.displayName = "@mantine/core/RangeSlider";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Space/Space.mjs
const defaultProps$21 = {};
const Space = factory((props, ref) => {
	const { w, h, miw, mih,...others } = useProps("Space", defaultProps$21, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...others,
		w,
		miw: miw ?? w,
		h,
		mih: mih ?? h
	});
});
Space.displayName = "@mantine/core/Space";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Spoiler/Spoiler.module.css.mjs
var classes$11 = {
	"root": "m_559cce2d",
	"content": "m_b912df4e",
	"control": "m_b9131032"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Spoiler/Spoiler.mjs
const defaultProps$20 = {
	maxHeight: 100,
	initialState: false
};
const varsResolver$11 = createVarsResolver((_, { transitionDuration }) => ({ root: { "--spoiler-transition-duration": transitionDuration !== void 0 ? `${transitionDuration}ms` : void 0 } }));
const Spoiler = factory((_props, ref) => {
	const props = useProps("Spoiler", defaultProps$20, _props);
	const { classNames, className, style, styles, unstyled, vars, initialState, maxHeight, hideLabel, showLabel, children, controlRef, transitionDuration, id, expanded, onExpandedChange,...others } = props;
	const getStyles$1 = useStyles({
		name: "Spoiler",
		classes: classes$11,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$11
	});
	const _id = useId(id);
	const regionId = `${_id}-region`;
	const [show, setShowState] = useUncontrolled({
		value: expanded,
		defaultValue: initialState,
		finalValue: false,
		onChange: onExpandedChange
	});
	const { ref: contentRef, height } = useElementSize();
	const spoilerMoreContent = show ? hideLabel : showLabel;
	const spoiler = spoilerMoreContent !== null && maxHeight < height;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles$1("root"),
		id: _id,
		ref,
		"data-has-spoiler": spoiler || void 0,
		...others,
		children: [spoiler && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Anchor, {
			component: "button",
			type: "button",
			ref: controlRef,
			onClick: () => setShowState(!show),
			"aria-expanded": show,
			"aria-controls": regionId,
			...getStyles$1("control"),
			children: spoilerMoreContent
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...getStyles$1("content", { style: { maxHeight: !show ? rem(maxHeight) : height ? rem(height) : void 0 } }),
			"data-reduce-motion": true,
			role: "region",
			id: regionId,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				ref: contentRef,
				children
			})
		})]
	});
});
Spoiler.classes = classes$11;
Spoiler.displayName = "@mantine/core/Spoiler";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stack/Stack.module.css.mjs
var classes$10 = { "root": "m_6d731127" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stack/Stack.mjs
const defaultProps$19 = {
	gap: "md",
	align: "stretch",
	justify: "flex-start"
};
const varsResolver$10 = createVarsResolver((_, { gap, align, justify }) => ({ root: {
	"--stack-gap": getSpacing(gap),
	"--stack-align": align,
	"--stack-justify": justify
} }));
const Stack = factory((_props, ref) => {
	const props = useProps("Stack", defaultProps$19, _props);
	const { classNames, className, style, styles, unstyled, vars, align, justify, gap, variant,...others } = props;
	const getStyles$1 = useStyles({
		name: "Stack",
		props,
		classes: classes$10,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$10
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		variant,
		...others
	});
});
Stack.classes = classes$10;
Stack.displayName = "@mantine/core/Stack";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stepper/Stepper.context.mjs
const [StepperProvider, useStepperContext] = createSafeContext("Stepper component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stepper/StepperCompleted/StepperCompleted.mjs
const StepperCompleted = () => null;
StepperCompleted.displayName = "@mantine/core/StepperCompleted";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stepper/Stepper.module.css.mjs
var classes$9 = {
	"root": "m_cbb4ea7e",
	"steps": "m_aaf89d0b",
	"separator": "m_2a371ac9",
	"content": "m_78da155d",
	"step": "m_cbb57068",
	"step--horizontal": "m_f56b1e2c",
	"step--vertical": "m_833edb7e",
	"verticalSeparator": "m_6496b3f3",
	"stepWrapper": "m_818e70b",
	"stepIcon": "m_1959ad01",
	"stepCompletedIcon": "m_a79331dc",
	"stepBody": "m_1956aa2a",
	"stepLabel": "m_12051f6c",
	"stepDescription": "m_164eea74"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stepper/StepperStep/StepperStep.mjs
const getStepFragment = (Fragment$25, step) => {
	if (typeof Fragment$25 === "function") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Fragment$25, { step: step || 0 });
	return Fragment$25;
};
const defaultProps$18 = {
	withIcon: true,
	allowStepClick: true,
	iconPosition: "left"
};
const StepperStep = factory((props, ref) => {
	const { classNames, className, style, styles, vars, step, state, color, icon, completedIcon, progressIcon, label, description, withIcon, iconSize, loading, allowStepClick, allowStepSelect, iconPosition, orientation, mod,...others } = useProps("StepperStep", defaultProps$18, props);
	const ctx = useStepperContext();
	const theme = useMantineTheme();
	const stylesApi = {
		classNames,
		styles
	};
	const _icon = state === "stepCompleted" ? null : state === "stepProgress" ? progressIcon : icon;
	const dataAttributes = {
		"data-progress": state === "stepProgress" || void 0,
		"data-completed": state === "stepCompleted" || void 0
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...ctx.getStyles("step", {
			className,
			style,
			variant: ctx.orientation,
			...stylesApi
		}),
		mod: [{
			"icon-position": iconPosition || ctx.iconPosition,
			"allow-click": allowStepClick
		}, mod],
		ref,
		...dataAttributes,
		...others,
		__vars: { "--step-color": color ? getThemeColor(color, theme) : void 0 },
		tabIndex: allowStepClick ? 0 : -1,
		children: [withIcon && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
			...ctx.getStyles("stepWrapper", stylesApi),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
				...ctx.getStyles("stepIcon", stylesApi),
				...dataAttributes,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
					mounted: state === "stepCompleted",
					transition: "pop",
					duration: 200,
					children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						...ctx.getStyles("stepCompletedIcon", {
							style: transitionStyles,
							...stylesApi
						}),
						children: loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
							color: "var(--mantine-color-white)",
							size: "calc(var(--stepper-icon-size) / 2)",
							...ctx.getStyles("stepLoader", stylesApi)
						}) : getStepFragment(completedIcon, step) || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, { size: "60%" })
					})
				}), state !== "stepCompleted" ? loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
					...ctx.getStyles("stepLoader", stylesApi),
					size: "calc(var(--stepper-icon-size) / 2)",
					color
				}) : getStepFragment(_icon || icon, step) : null]
			}), orientation === "vertical" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("verticalSeparator", stylesApi),
				"data-active": state === "stepCompleted" || void 0
			})]
		}), (label || description) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
			...ctx.getStyles("stepBody", stylesApi),
			"data-orientation": ctx.orientation,
			"data-icon-position": iconPosition || ctx.iconPosition,
			children: [label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("stepLabel", stylesApi),
				children: getStepFragment(label, step)
			}), description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("stepDescription", stylesApi),
				children: getStepFragment(description, step)
			})]
		})]
	});
});
StepperStep.classes = classes$9;
StepperStep.displayName = "@mantine/core/StepperStep";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Stepper/Stepper.mjs
const defaultProps$17 = {
	orientation: "horizontal",
	iconPosition: "left",
	allowNextStepsSelect: true,
	wrap: true
};
const varsResolver$9 = createVarsResolver((theme, { color, iconSize, size: size$3, contentPadding, radius, autoContrast }) => ({ root: {
	"--stepper-color": color ? getThemeColor(color, theme) : void 0,
	"--stepper-icon-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({
		color,
		theme,
		autoContrast
	}) : void 0,
	"--stepper-icon-size": iconSize === void 0 ? getSize(size$3, "stepper-icon-size") : rem(iconSize),
	"--stepper-content-padding": getSpacing(contentPadding),
	"--stepper-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--stepper-fz": getFontSize(size$3),
	"--stepper-spacing": getSpacing(size$3)
} }));
const Stepper = factory((_props, ref) => {
	const props = useProps("Stepper", defaultProps$17, _props);
	const { classNames, className, style, styles, unstyled, vars, children, onStepClick, active, icon, completedIcon, progressIcon, color, iconSize, contentPadding, orientation, iconPosition, size: size$3, radius, allowNextStepsSelect, wrap, autoContrast,...others } = props;
	const getStyles$1 = useStyles({
		name: "Stepper",
		classes: classes$9,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$9
	});
	const convertedChildren = import_react.Children.toArray(children);
	const _children = convertedChildren.filter((child) => child.type !== StepperCompleted);
	const completedStep = convertedChildren.find((item) => item.type === StepperCompleted);
	const items = _children.reduce((acc, item, index$4) => {
		const state = active === index$4 ? "stepProgress" : active > index$4 ? "stepCompleted" : "stepInactive";
		const shouldAllowSelect = () => {
			if (typeof onStepClick !== "function") return false;
			if (typeof item.props.allowStepSelect === "boolean") return item.props.allowStepSelect;
			return state === "stepCompleted" || allowNextStepsSelect;
		};
		const isStepSelectionEnabled = shouldAllowSelect();
		acc.push((0, import_react.cloneElement)(item, {
			icon: item.props.icon || icon || index$4 + 1,
			key: index$4,
			step: index$4,
			state,
			onClick: () => isStepSelectionEnabled && onStepClick?.(index$4),
			allowStepClick: isStepSelectionEnabled,
			completedIcon: item.props.completedIcon || completedIcon,
			progressIcon: item.props.progressIcon || progressIcon,
			color: item.props.color || color,
			iconSize,
			iconPosition: item.props.iconPosition || iconPosition,
			orientation
		}));
		if (orientation === "horizontal" && index$4 !== _children.length - 1) acc.push(/* @__PURE__ */ (0, import_react.createElement)("div", {
			...getStyles$1("separator"),
			"data-active": index$4 < active || void 0,
			"data-orientation": orientation,
			key: `separator-${index$4}`
		}));
		return acc;
	}, []);
	const stepContent = _children[active]?.props?.children;
	const completedContent = completedStep?.props?.children;
	const content = active > _children.length - 1 ? completedContent : stepContent;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(StepperProvider, {
		value: {
			getStyles: getStyles$1,
			orientation,
			iconPosition
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles$1("root"),
			ref,
			size: size$3,
			...others,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				...getStyles$1("steps"),
				mod: {
					orientation,
					"icon-position": iconPosition,
					wrap: wrap && orientation !== "vertical"
				},
				children: items
			}), content && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...getStyles$1("content"),
				children: content
			})]
		})
	});
});
Stepper.classes = classes$9;
Stepper.displayName = "@mantine/core/Stepper";
Stepper.Completed = StepperCompleted;
Stepper.Step = StepperStep;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Switch/SwitchGroup.context.mjs
const SwitchGroupContext = (0, import_react.createContext)(null);
const SwitchGroupProvider = SwitchGroupContext.Provider;
const useSwitchGroupContext = () => (0, import_react.useContext)(SwitchGroupContext);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Switch/SwitchGroup/SwitchGroup.mjs
const defaultProps$16 = {};
const SwitchGroup = factory((props, ref) => {
	const { value, defaultValue, onChange, size: size$3, wrapperProps, children, readOnly,...others } = useProps("SwitchGroup", defaultProps$16, props);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [],
		onChange
	});
	const handleChange = (event) => {
		const itemValue = event.currentTarget.value;
		!readOnly && setValue(_value.includes(itemValue) ? _value.filter((item) => item !== itemValue) : [..._value, itemValue]);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SwitchGroupProvider, {
		value: {
			value: _value,
			onChange: handleChange,
			size: size$3
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
			size: size$3,
			ref,
			...wrapperProps,
			...others,
			labelElement: "div",
			__staticSelector: "SwitchGroup",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputsGroupFieldset, {
				role: "group",
				children
			})
		})
	});
});
SwitchGroup.classes = Input.Wrapper.classes;
SwitchGroup.displayName = "@mantine/core/SwitchGroup";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Switch/Switch.module.css.mjs
var classes$8 = {
	"root": "m_5f93f3bb",
	"input": "m_926b4011",
	"track": "m_9307d992",
	"thumb": "m_93039a1d",
	"trackLabel": "m_8277e082"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Switch/Switch.mjs
const defaultProps$15 = {
	labelPosition: "right",
	withThumbIndicator: true
};
const varsResolver$8 = createVarsResolver((theme, { radius, color, size: size$3 }) => ({ root: {
	"--switch-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--switch-height": getSize(size$3, "switch-height"),
	"--switch-width": getSize(size$3, "switch-width"),
	"--switch-thumb-size": getSize(size$3, "switch-thumb-size"),
	"--switch-label-font-size": getSize(size$3, "switch-label-font-size"),
	"--switch-track-label-padding": getSize(size$3, "switch-track-label-padding"),
	"--switch-color": color ? getThemeColor(color, theme) : void 0
} }));
const Switch = factory((_props, ref) => {
	const props = useProps("Switch", defaultProps$15, _props);
	const { classNames, className, style, styles, unstyled, vars, color, label, offLabel, onLabel, id, size: size$3, radius, wrapperProps, thumbIcon, checked, defaultChecked, onChange, labelPosition, description, error: error$1, disabled, variant, rootRef, mod, withThumbIndicator,...others } = props;
	const ctx = useSwitchGroupContext();
	const _size = size$3 || ctx?.size;
	const getStyles$1 = useStyles({
		name: "Switch",
		props,
		classes: classes$8,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$8
	});
	const { styleProps, rest } = extractStyleProps(others);
	const uuid = useId(id);
	const contextProps = ctx ? {
		checked: ctx.value.includes(rest.value),
		onChange: ctx.onChange
	} : {};
	const [_checked, handleChange] = useUncontrolled({
		value: contextProps.checked ?? checked,
		defaultValue: defaultChecked,
		finalValue: false
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(InlineInput, {
		...getStyles$1("root"),
		__staticSelector: "Switch",
		__stylesApiProps: props,
		id: uuid,
		size: _size,
		labelPosition,
		label,
		description,
		error: error$1,
		disabled,
		bodyElement: "label",
		labelElement: "span",
		classNames,
		styles,
		unstyled,
		"data-checked": contextProps.checked || checked || void 0,
		variant,
		ref: rootRef,
		mod,
		...styleProps,
		...wrapperProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
			...rest,
			disabled,
			checked: _checked,
			"data-checked": contextProps.checked || checked || void 0,
			onChange: (event) => {
				ctx ? contextProps.onChange?.(event) : onChange?.(event);
				handleChange(event.currentTarget.checked);
			},
			id: uuid,
			ref,
			type: "checkbox",
			role: "switch",
			...getStyles$1("input")
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			"aria-hidden": "true",
			component: "span",
			mod: {
				error: error$1,
				"label-position": labelPosition,
				"without-labels": !onLabel && !offLabel
			},
			...getStyles$1("track"),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				mod: {
					"reduce-motion": true,
					"with-thumb-indicator": withThumbIndicator && !thumbIcon
				},
				...getStyles$1("thumb"),
				children: thumbIcon
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles$1("trackLabel"),
				children: _checked ? onLabel : offLabel
			})]
		})]
	});
});
Switch.classes = {
	...classes$8,
	...InlineInputClasses
};
Switch.displayName = "@mantine/core/Switch";
Switch.Group = SwitchGroup;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/Table.context.mjs
const [TableProvider, useTableContext] = createSafeContext("Table component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/Table.module.css.mjs
var classes$7 = {
	"table": "m_b23fa0ef",
	"th": "m_4e7aa4f3",
	"tr": "m_4e7aa4fd",
	"td": "m_4e7aa4ef",
	"tbody": "m_b2404537",
	"thead": "m_b242d975",
	"caption": "m_9e5a3ac7",
	"scrollContainer": "m_a100c15",
	"scrollContainerInner": "m_62259741"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/Table.components.mjs
function getDataAttributes(ctx, options$1) {
	if (!options$1) return void 0;
	const data = {};
	if (options$1.columnBorder && ctx.withColumnBorders) data["data-with-column-border"] = true;
	if (options$1.rowBorder && ctx.withRowBorders) data["data-with-row-border"] = true;
	if (options$1.striped && ctx.striped) data["data-striped"] = ctx.striped;
	if (options$1.highlightOnHover && ctx.highlightOnHover) data["data-hover"] = true;
	if (options$1.captionSide && ctx.captionSide) data["data-side"] = ctx.captionSide;
	if (options$1.stickyHeader && ctx.stickyHeader) data["data-sticky"] = true;
	return data;
}
function tableElement(element, options$1) {
	const name = `Table${element.charAt(0).toUpperCase()}${element.slice(1)}`;
	const Component = factory((_props, ref) => {
		const props = useProps(name, {}, _props);
		const { classNames, className, style, styles,...others } = props;
		const ctx = useTableContext();
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			component: element,
			ref,
			...getDataAttributes(ctx, options$1),
			...ctx.getStyles(element, {
				className,
				classNames,
				style,
				styles,
				props
			}),
			...others
		});
	});
	Component.displayName = `@mantine/core/${name}`;
	Component.classes = classes$7;
	return Component;
}
const TableTh = tableElement("th", { columnBorder: true });
const TableTd = tableElement("td", { columnBorder: true });
const TableTr = tableElement("tr", {
	rowBorder: true,
	striped: true,
	highlightOnHover: true
});
const TableThead = tableElement("thead", { stickyHeader: true });
const TableTbody = tableElement("tbody");
const TableTfoot = tableElement("tfoot");
const TableCaption = tableElement("caption", { captionSide: true });

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/TableDataRenderer.mjs
function TableDataRenderer({ data }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		data.caption && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCaption, { children: data.caption }),
		data.head && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableThead, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTr, { children: data.head.map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTh, { children: item }, index$4)) }) }),
		data.body && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTbody, { children: data.body.map((row, rowIndex) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTr, { children: row.map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTd, { children: item }, index$4)) }, rowIndex)) }),
		data.foot && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTfoot, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTr, { children: data.foot.map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableTh, { children: item }, index$4)) }) })
	] });
}
TableDataRenderer.displayName = "@mantine/core/TableDataRenderer";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/TableScrollContainer.mjs
const defaultProps$14 = { type: "scrollarea" };
const varsResolver$7 = createVarsResolver((_, { minWidth, maxHeight, type }) => ({ scrollContainer: {
	"--table-min-width": rem(minWidth),
	"--table-max-height": rem(maxHeight),
	"--table-overflow": type === "native" ? "auto" : void 0
} }));
const TableScrollContainer = factory((_props, ref) => {
	const props = useProps("TableScrollContainer", defaultProps$14, _props);
	const { classNames, className, style, styles, unstyled, vars, children, minWidth, maxHeight, type, scrollAreaProps,...others } = props;
	const getStyles$1 = useStyles({
		name: "TableScrollContainer",
		classes: classes$7,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$7,
		rootSelector: "scrollContainer"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: type === "scrollarea" ? ScrollArea : "div",
		...type === "scrollarea" ? maxHeight ? {
			offsetScrollbars: "xy",
			...scrollAreaProps
		} : {
			offsetScrollbars: "x",
			...scrollAreaProps
		} : {},
		ref,
		...getStyles$1("scrollContainer"),
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...getStyles$1("scrollContainerInner"),
			children
		})
	});
});
TableScrollContainer.classes = classes$7;
TableScrollContainer.displayName = "@mantine/core/TableScrollContainer";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Table/Table.mjs
const defaultProps$13 = {
	withRowBorders: true,
	verticalSpacing: 7
};
const varsResolver$6 = createVarsResolver((theme, { layout, captionSide, horizontalSpacing, verticalSpacing, borderColor, stripedColor, highlightOnHoverColor, striped, highlightOnHover, stickyHeaderOffset, stickyHeader }) => ({ table: {
	"--table-layout": layout,
	"--table-caption-side": captionSide,
	"--table-horizontal-spacing": getSpacing(horizontalSpacing),
	"--table-vertical-spacing": getSpacing(verticalSpacing),
	"--table-border-color": borderColor ? getThemeColor(borderColor, theme) : void 0,
	"--table-striped-color": striped && stripedColor ? getThemeColor(stripedColor, theme) : void 0,
	"--table-highlight-on-hover-color": highlightOnHover && highlightOnHoverColor ? getThemeColor(highlightOnHoverColor, theme) : void 0,
	"--table-sticky-header-offset": stickyHeader ? rem(stickyHeaderOffset) : void 0
} }));
const Table = factory((_props, ref) => {
	const props = useProps("Table", defaultProps$13, _props);
	const { classNames, className, style, styles, unstyled, vars, horizontalSpacing, verticalSpacing, captionSide, stripedColor, highlightOnHoverColor, striped, highlightOnHover, withColumnBorders, withRowBorders, withTableBorder, borderColor, layout, variant, data, children, stickyHeader, stickyHeaderOffset, mod, tabularNums,...others } = props;
	const getStyles$1 = useStyles({
		name: "Table",
		props,
		className,
		style,
		classes: classes$7,
		classNames,
		styles,
		unstyled,
		rootSelector: "table",
		vars,
		varsResolver: varsResolver$6
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableProvider, {
		value: {
			getStyles: getStyles$1,
			stickyHeader,
			striped: striped === true ? "odd" : striped || void 0,
			highlightOnHover,
			withColumnBorders,
			withRowBorders,
			captionSide: captionSide || "bottom"
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			component: "table",
			variant,
			ref,
			mod: [{
				"data-with-table-border": withTableBorder,
				"data-tabular-nums": tabularNums
			}, mod],
			...getStyles$1("table"),
			...others,
			children: children || !!data && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableDataRenderer, { data })
		})
	});
});
Table.classes = classes$7;
Table.displayName = "@mantine/core/Table";
Table.Td = TableTd;
Table.Th = TableTh;
Table.Tr = TableTr;
Table.Thead = TableThead;
Table.Tbody = TableTbody;
Table.Tfoot = TableTfoot;
Table.Caption = TableCaption;
Table.ScrollContainer = TableScrollContainer;
Table.DataRenderer = TableDataRenderer;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TableOfContents/TableOfContents.module.css.mjs
var classes$6 = {
	"root": "m_bcaa9990",
	"control": "m_375a65ef"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TableOfContents/TableOfContents.mjs
const defaultProps$12 = { getControlProps: ({ data }) => ({ children: data.value }) };
const varsResolver$5 = createVarsResolver((theme, { color, size: size$3, variant, autoContrast, depthOffset, radius }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--toc-bg": variant !== "none" ? colors.background : void 0,
		"--toc-color": variant !== "none" ? colors.color : void 0,
		"--toc-size": getFontSize(size$3),
		"--toc-depth-offset": rem(depthOffset),
		"--toc-radius": getRadius(radius)
	} };
});
const TableOfContents = factory((_props, ref) => {
	const props = useProps("TableOfContents", defaultProps$12, _props);
	const { classNames, className, style, styles, unstyled, vars, color, autoContrast, scrollSpyOptions, initialData, getControlProps, minDepthToOffset, depthOffset, variant, radius, reinitializeRef,...others } = props;
	const getStyles$1 = useStyles({
		name: "TableOfContents",
		classes: classes$6,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$5
	});
	const idBase = useId();
	const spy = useScrollSpy(scrollSpyOptions);
	assignRef(reinitializeRef, spy.reinitialize);
	const headingsData = spy.initialized ? spy.data : initialData || [];
	const controls = headingsData.map((data, index$4) => {
		const controlProps = getControlProps?.({
			active: index$4 === spy.active,
			data: {
				...data,
				getNode: data.getNode || (() => {})
			}
		});
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			__vars: { "--depth-offset": `${data.depth - (minDepthToOffset || 1)}` },
			"data-active": index$4 === spy.active || void 0,
			variant,
			...controlProps,
			...getStyles$1("control", {
				className: controlProps?.className,
				style: controlProps?.style
			})
		}, data.id || `${idBase}-${index$4}`);
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		variant,
		...getStyles$1("root"),
		...others,
		children: controls
	});
});
TableOfContents.displayName = "@mantine/core/TableOfContents";
TableOfContents.classes = classes$6;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/Tabs.context.mjs
const [TabsProvider, useTabsContext] = createSafeContext("Tabs component was not found in the tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/Tabs.module.css.mjs
var classes$5 = {
	"root": "m_89d60db1",
	"list--default": "m_576c9d4",
	"list": "m_89d33d6d",
	"tab": "m_4ec4dce6",
	"panel": "m_b0c91715",
	"tabSection": "m_fc420b1f",
	"tabLabel": "m_42bbd1ae",
	"tab--default": "m_539e827b",
	"list--outline": "m_6772fbd5",
	"tab--outline": "m_b59ab47c",
	"tab--pills": "m_c3381914"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/TabsList/TabsList.mjs
const defaultProps$11 = {};
const TabsList = factory((_props, ref) => {
	const props = useProps("TabsList", defaultProps$11, _props);
	const { children, className, grow, justify, classNames, styles, style, mod,...others } = props;
	const ctx = useTabsContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		...ctx.getStyles("list", {
			className,
			style,
			classNames,
			styles,
			props,
			variant: ctx.variant
		}),
		ref,
		role: "tablist",
		variant: ctx.variant,
		mod: [{
			grow,
			orientation: ctx.orientation,
			placement: ctx.orientation === "vertical" && ctx.placement,
			inverted: ctx.inverted
		}, mod],
		"aria-orientation": ctx.orientation,
		__vars: { "--tabs-justify": justify },
		children
	});
});
TabsList.classes = classes$5;
TabsList.displayName = "@mantine/core/TabsList";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/TabsPanel/TabsPanel.mjs
const defaultProps$10 = {};
const TabsPanel = factory((_props, ref) => {
	const props = useProps("TabsPanel", defaultProps$10, _props);
	const { children, className, value, classNames, styles, style, mod, keepMounted,...others } = props;
	const ctx = useTabsContext();
	const active = ctx.value === value;
	const content = ctx.keepMounted || keepMounted ? children : active ? children : null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		...ctx.getStyles("panel", {
			className,
			classNames,
			styles,
			style: [style, !active ? { display: "none" } : void 0],
			props
		}),
		ref,
		mod: [{ orientation: ctx.orientation }, mod],
		role: "tabpanel",
		id: ctx.getPanelId(value),
		"aria-labelledby": ctx.getTabId(value),
		children: content
	});
});
TabsPanel.classes = classes$5;
TabsPanel.displayName = "@mantine/core/TabsPanel";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/TabsTab/TabsTab.mjs
const defaultProps$9 = {};
const TabsTab = factory((_props, ref) => {
	const props = useProps("TabsTab", defaultProps$9, _props);
	const { className, children, rightSection, leftSection, value, onClick, onKeyDown, disabled, color, style, classNames, styles, vars, mod, tabIndex,...others } = props;
	const theme = useMantineTheme();
	const { dir } = useDirection();
	const ctx = useTabsContext();
	const active = value === ctx.value;
	const activateTab = (event) => {
		ctx.onChange(ctx.allowTabDeactivation ? value === ctx.value ? null : value : value);
		onClick?.(event);
	};
	const stylesApiProps = {
		classNames,
		styles,
		props
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		...others,
		...ctx.getStyles("tab", {
			className,
			style,
			variant: ctx.variant,
			...stylesApiProps
		}),
		disabled,
		unstyled: ctx.unstyled,
		variant: ctx.variant,
		mod: [{
			active,
			disabled,
			orientation: ctx.orientation,
			inverted: ctx.inverted,
			placement: ctx.orientation === "vertical" && ctx.placement
		}, mod],
		ref,
		role: "tab",
		id: ctx.getTabId(value),
		"aria-selected": active,
		tabIndex: tabIndex !== void 0 ? tabIndex : active || ctx.value === null ? 0 : -1,
		"aria-controls": ctx.getPanelId(value),
		onClick: activateTab,
		__vars: { "--tabs-color": color ? getThemeColor(color, theme) : void 0 },
		onKeyDown: createScopedKeydownHandler({
			siblingSelector: "[role=\"tab\"]",
			parentSelector: "[role=\"tablist\"]",
			activateOnFocus: ctx.activateTabWithKeyboard,
			loop: ctx.loop,
			orientation: ctx.orientation || "horizontal",
			dir,
			onKeyDown
		}),
		children: [
			leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("tabSection", stylesApiProps),
				"data-position": "left",
				children: leftSection
			}),
			children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("tabLabel", stylesApiProps),
				children
			}),
			rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...ctx.getStyles("tabSection", stylesApiProps),
				"data-position": "right",
				children: rightSection
			})
		]
	});
});
TabsTab.classes = classes$5;
TabsTab.displayName = "@mantine/core/TabsTab";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tabs/Tabs.mjs
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value";
const defaultProps$8 = {
	keepMounted: true,
	orientation: "horizontal",
	loop: true,
	activateTabWithKeyboard: true,
	allowTabDeactivation: false,
	unstyled: false,
	inverted: false,
	variant: "default",
	placement: "left"
};
const varsResolver$4 = createVarsResolver((theme, { radius, color, autoContrast }) => ({ root: {
	"--tabs-radius": getRadius(radius),
	"--tabs-color": getThemeColor(color, theme),
	"--tabs-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({
		color,
		theme,
		autoContrast
	}) : void 0
} }));
const Tabs = factory((_props, ref) => {
	const props = useProps("Tabs", defaultProps$8, _props);
	const { defaultValue, value, onChange, orientation, children, loop, id, activateTabWithKeyboard, allowTabDeactivation, variant, color, radius, inverted, placement, keepMounted, classNames, styles, unstyled, className, style, vars, autoContrast, mod,...others } = props;
	const uid = useId(id);
	const [currentTab, setCurrentTab] = useUncontrolled({
		value,
		defaultValue,
		finalValue: null,
		onChange
	});
	const getStyles$1 = useStyles({
		name: "Tabs",
		props,
		classes: classes$5,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$4
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabsProvider, {
		value: {
			placement,
			value: currentTab,
			orientation,
			id: uid,
			loop,
			activateTabWithKeyboard,
			getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
			getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
			onChange: setCurrentTab,
			allowTabDeactivation,
			variant,
			color,
			radius,
			inverted,
			keepMounted,
			unstyled,
			getStyles: getStyles$1
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			id: uid,
			variant,
			mod: [{
				orientation,
				inverted: orientation === "horizontal" && inverted,
				placement: orientation === "vertical" && placement
			}, mod],
			...getStyles$1("root"),
			...others,
			children
		})
	});
});
Tabs.classes = classes$5;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TagsInput/filter-picked-tags.mjs
function filterPickedTags({ data, value }) {
	const normalizedValue = value.map((item) => item.trim().toLowerCase());
	const filtered = data.reduce((acc, item) => {
		if (isOptionsGroup(item)) acc.push({
			group: item.group,
			items: item.items.filter((option) => normalizedValue.indexOf(option.label.toLowerCase().trim()) === -1)
		});
		else if (normalizedValue.indexOf(item.label.toLowerCase().trim()) === -1) acc.push(item);
		return acc;
	}, []);
	return filtered;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TagsInput/get-splitted-tags.mjs
function splitTags(splitChars, value) {
	if (!splitChars) return [value];
	return value.split(new RegExp(`[${splitChars.join("")}]`)).map((tag) => tag.trim()).filter((tag) => tag !== "");
}
function getSplittedTags({ splitChars, allowDuplicates, maxTags, value, currentTags }) {
	const splitted = splitTags(splitChars, value);
	const merged = allowDuplicates ? [...currentTags, ...splitted] : [.../* @__PURE__ */ new Set([...currentTags, ...splitted])];
	return maxTags ? merged.slice(0, maxTags) : merged;
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TagsInput/TagsInput.mjs
const defaultProps$7 = {
	maxTags: Infinity,
	allowDuplicates: false,
	acceptValueOnBlur: true,
	splitChars: [","],
	hiddenInputValuesDivider: ","
};
const TagsInput = factory((_props, ref) => {
	const props = useProps("TagsInput", defaultProps$7, _props);
	const { classNames, className, style, styles, unstyled, vars, size: size$3, value, defaultValue, onChange, onKeyDown, maxTags, allowDuplicates, onDuplicate, variant, data, dropdownOpened, defaultDropdownOpened, onDropdownOpen, onDropdownClose, selectFirstOptionOnChange, onOptionSubmit, comboboxProps, filter, limit, withScrollArea, maxDropdownHeight, searchValue, defaultSearchValue, onSearchChange, readOnly, disabled, splitChars, onFocus, onBlur, onPaste, radius, rightSection, rightSectionWidth, rightSectionPointerEvents, rightSectionProps, leftSection, leftSectionWidth, leftSectionPointerEvents, leftSectionProps, inputContainer, inputWrapperOrder, withAsterisk, required, labelProps, descriptionProps, errorProps, wrapperProps, description, label, error: error$1, withErrorStyles, name, form, id, clearable, clearButtonProps, hiddenInputProps, hiddenInputValuesDivider, mod, renderOption, onRemove, onClear, scrollAreaProps, acceptValueOnBlur,...others } = props;
	const _id = useId(id);
	const parsedData = getParsedComboboxData(data);
	const optionsLockup = getOptionsLockup(parsedData);
	const inputRef = (0, import_react.useRef)(null);
	const _ref = useMergedRef(inputRef, ref);
	const combobox = useCombobox({
		opened: dropdownOpened,
		defaultOpened: defaultDropdownOpened,
		onDropdownOpen,
		onDropdownClose: () => {
			onDropdownClose?.();
			combobox.resetSelectedOption();
		}
	});
	const { styleProps, rest: { type, autoComplete,...rest } } = extractStyleProps(others);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [],
		onChange
	});
	const [_searchValue, setSearchValue] = useUncontrolled({
		value: searchValue,
		defaultValue: defaultSearchValue,
		finalValue: "",
		onChange: onSearchChange
	});
	const handleSearchChange = (value2) => {
		setSearchValue(value2);
		combobox.resetSelectedOption();
	};
	const getStyles$1 = useStyles({
		name: "TagsInput",
		classes: {},
		props,
		classNames,
		styles,
		unstyled
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		props,
		styles,
		classNames
	});
	const handleValueSelect = (val) => {
		const isDuplicate = _value.some((tag) => tag.toLowerCase() === val.toLowerCase());
		if (isDuplicate) onDuplicate?.(val);
		if ((!isDuplicate || isDuplicate && allowDuplicates) && _value.length < maxTags) {
			onOptionSubmit?.(val);
			handleSearchChange("");
			if (val.length > 0) setValue([..._value, val]);
		}
	};
	const handleInputKeydown = (event) => {
		onKeyDown?.(event);
		if (event.isPropagationStopped()) return;
		const inputValue = _searchValue.trim();
		const { length } = inputValue;
		if (splitChars.includes(event.key) && length > 0) {
			setValue(getSplittedTags({
				splitChars,
				allowDuplicates,
				maxTags,
				value: _searchValue,
				currentTags: _value
			}));
			handleSearchChange("");
			event.preventDefault();
		}
		if (event.key === "Enter" && length > 0 && !event.nativeEvent.isComposing) {
			event.preventDefault();
			const hasActiveSelection = !!document.querySelector(`#${combobox.listId} [data-combobox-option][data-combobox-selected]`);
			if (hasActiveSelection) return;
			handleValueSelect(inputValue);
		}
		if (event.key === "Backspace" && length === 0 && _value.length > 0 && !event.nativeEvent.isComposing) {
			onRemove?.(_value[_value.length - 1]);
			setValue(_value.slice(0, _value.length - 1));
		}
	};
	const handlePaste = (event) => {
		onPaste?.(event);
		event.preventDefault();
		if (event.clipboardData) {
			const pastedText = event.clipboardData.getData("text/plain");
			setValue(getSplittedTags({
				splitChars,
				allowDuplicates,
				maxTags,
				value: `${_searchValue}${pastedText}`,
				currentTags: _value
			}));
			handleSearchChange("");
		}
	};
	const values$1 = _value.map((item, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pill, {
		withRemoveButton: !readOnly,
		onRemove: () => {
			const next_value = _value.slice();
			next_value.splice(index$4, 1);
			setValue(next_value);
			onRemove?.(item);
		},
		unstyled,
		disabled,
		...getStyles$1("pill"),
		children: item
	}, `${item}-${index$4}`));
	(0, import_react.useEffect)(() => {
		if (selectFirstOptionOnChange) combobox.selectFirstOption();
	}, [
		selectFirstOptionOnChange,
		_value,
		_searchValue
	]);
	const clearButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.ClearButton, {
		...clearButtonProps,
		onClear: () => {
			setValue([]);
			handleSearchChange("");
			inputRef.current?.focus();
			combobox.openDropdown();
			onClear?.();
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox, {
		store: combobox,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		size: size$3,
		readOnly,
		__staticSelector: "TagsInput",
		onOptionSubmit: (val) => {
			onOptionSubmit?.(val);
			handleSearchChange("");
			_value.length < maxTags && setValue([..._value, optionsLockup[val].label]);
			combobox.resetSelectedOption();
		},
		...comboboxProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.DropdownTarget, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillsInput, {
			...styleProps,
			__staticSelector: "TagsInput",
			classNames: resolvedClassNames,
			styles: resolvedStyles,
			unstyled,
			size: size$3,
			className,
			style,
			variant,
			disabled,
			radius,
			rightSection,
			__clearSection: clearButton,
			__clearable: clearable && _value.length > 0 && !disabled && !readOnly,
			rightSectionWidth,
			rightSectionPointerEvents,
			rightSectionProps,
			leftSection,
			leftSectionWidth,
			leftSectionPointerEvents,
			leftSectionProps,
			inputContainer,
			inputWrapperOrder,
			withAsterisk,
			required,
			labelProps,
			descriptionProps,
			errorProps,
			wrapperProps,
			description,
			label,
			error: error$1,
			withErrorStyles,
			__stylesApiProps: {
				...props,
				multiline: true
			},
			id: _id,
			mod,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Pill.Group, {
				disabled,
				unstyled,
				...getStyles$1("pillsList"),
				children: [values$1, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.EventsTarget, {
					autoComplete,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PillsInput.Field, {
						...rest,
						ref: _ref,
						...getStyles$1("inputField"),
						unstyled,
						onKeyDown: handleInputKeydown,
						onFocus: (event) => {
							onFocus?.(event);
							combobox.openDropdown();
						},
						onBlur: (event) => {
							onBlur?.(event);
							acceptValueOnBlur && handleValueSelect(_searchValue);
							combobox.closeDropdown();
						},
						onPaste: handlePaste,
						value: _searchValue,
						onChange: (event) => handleSearchChange(event.currentTarget.value),
						required: required && _value.length === 0,
						disabled,
						readOnly,
						id: _id
					})
				})]
			})
		}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionsDropdown, {
			data: filterPickedTags({
				data: parsedData,
				value: _value
			}),
			hidden: readOnly || disabled,
			filter,
			search: _searchValue,
			limit,
			hiddenWhenEmpty: true,
			withScrollArea,
			maxDropdownHeight,
			unstyled,
			labelId: label ? `${_id}-label` : void 0,
			"aria-label": label ? void 0 : others["aria-label"],
			renderOption,
			scrollAreaProps
		})]
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.HiddenInput, {
		name,
		form,
		value: _value,
		valuesDivider: hiddenInputValuesDivider,
		disabled,
		...hiddenInputProps
	})] });
});
TagsInput.classes = {
	...InputBase.classes,
	...Combobox.classes
};
TagsInput.displayName = "@mantine/core/TagsInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TextInput/TextInput.mjs
const defaultProps$6 = {};
const TextInput = factory((props, ref) => {
	const _props = useProps("TextInput", defaultProps$6, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: "input",
		ref,
		..._props,
		__staticSelector: "TextInput"
	});
});
TextInput.classes = InputBase.classes;
TextInput.displayName = "@mantine/core/TextInput";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ThemeIcon/ThemeIcon.module.css.mjs
var classes$4 = { "root": "m_7341320d" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/ThemeIcon/ThemeIcon.mjs
const defaultProps$5 = {};
const varsResolver$3 = createVarsResolver((theme, { size: size$3, radius, variant, gradient, color, autoContrast }) => {
	const colors = theme.variantColorResolver({
		color: color || theme.primaryColor,
		theme,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--ti-size": getSize(size$3, "ti-size"),
		"--ti-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--ti-bg": color || variant ? colors.background : void 0,
		"--ti-color": color || variant ? colors.color : void 0,
		"--ti-bd": color || variant ? colors.border : void 0
	} };
});
const ThemeIcon = factory((_props, ref) => {
	const props = useProps("ThemeIcon", defaultProps$5, _props);
	const { classNames, className, style, styles, unstyled, vars, autoContrast,...others } = props;
	const getStyles$1 = useStyles({
		name: "ThemeIcon",
		classes: classes$4,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$3
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		...others
	});
});
ThemeIcon.classes = classes$4;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Timeline/Timeline.context.mjs
const [TimelineProvider, useTimelineContext] = createSafeContext("Timeline component was not found in tree");

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Timeline/Timeline.module.css.mjs
var classes$3 = {
	"root": "m_43657ece",
	"itemTitle": "m_2ebe8099",
	"item": "m_436178ff",
	"itemBullet": "m_8affcee1",
	"itemBody": "m_540e8f41"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Timeline/TimelineItem/TimelineItem.mjs
const defaultProps$4 = {};
const TimelineItem = factory((_props, ref) => {
	const props = useProps("TimelineItem", defaultProps$4, _props);
	const { classNames, className, style, styles, vars, __active, __align, __lineActive, __vars, bullet, radius, color, lineVariant, children, title, mod,...others } = props;
	const ctx = useTimelineContext();
	const theme = useMantineTheme();
	const stylesApiProps = {
		classNames,
		styles
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...ctx.getStyles("item", {
			...stylesApiProps,
			className,
			style
		}),
		mod: [{
			"line-active": __lineActive,
			active: __active
		}, mod],
		ref,
		__vars: {
			"--tli-radius": radius ? getRadius(radius) : void 0,
			"--tli-color": color ? getThemeColor(color, theme) : void 0,
			"--tli-border-style": lineVariant || void 0
		},
		...others,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...ctx.getStyles("itemBullet", stylesApiProps),
			mod: {
				"with-child": !!bullet,
				align: __align,
				active: __active
			},
			children: bullet
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			...ctx.getStyles("itemBody", stylesApiProps),
			children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemTitle", stylesApiProps),
				children: title
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				...ctx.getStyles("itemContent", stylesApiProps),
				children
			})]
		})]
	});
});
TimelineItem.classes = classes$3;
TimelineItem.displayName = "@mantine/core/TimelineItem";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Timeline/Timeline.mjs
const defaultProps$3 = {
	active: -1,
	align: "left",
	reverseActive: false
};
const varsResolver$2 = createVarsResolver((theme, { bulletSize, lineWidth, radius, color, autoContrast }) => ({ root: {
	"--tl-bullet-size": rem(bulletSize),
	"--tl-line-width": rem(lineWidth),
	"--tl-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--tl-color": color ? getThemeColor(color, theme) : void 0,
	"--tl-icon-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({
		color,
		theme,
		autoContrast
	}) : void 0
} }));
const Timeline = factory((_props, ref) => {
	const props = useProps("Timeline", defaultProps$3, _props);
	const { classNames, className, style, styles, unstyled, vars, children, active, color, radius, bulletSize, align, lineWidth, reverseActive, mod, autoContrast,...others } = props;
	const getStyles$1 = useStyles({
		name: "Timeline",
		classes: classes$3,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$2
	});
	const _children = import_react.Children.toArray(children);
	const items = _children.map((item, index$4) => (0, import_react.cloneElement)(item, {
		unstyled,
		__align: align,
		__active: item.props?.active || (reverseActive ? active >= _children.length - index$4 - 1 : active >= index$4),
		__lineActive: item.props?.lineActive || (reverseActive ? active >= _children.length - index$4 - 1 : active - 1 >= index$4)
	}));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TimelineProvider, {
		value: { getStyles: getStyles$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...getStyles$1("root"),
			mod: [{ align }, mod],
			ref,
			...others,
			children: items
		})
	});
});
Timeline.classes = classes$3;
Timeline.displayName = "@mantine/core/Timeline";
Timeline.Item = TimelineItem;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Title/get-title-size.mjs
const headings = [
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6"
];
const sizes = [
	"xs",
	"sm",
	"md",
	"lg",
	"xl"
];
function getTitleSize(order, size$3) {
	const titleSize = size$3 !== void 0 ? size$3 : `h${order}`;
	if (headings.includes(titleSize)) return {
		fontSize: `var(--mantine-${titleSize}-font-size)`,
		fontWeight: `var(--mantine-${titleSize}-font-weight)`,
		lineHeight: `var(--mantine-${titleSize}-line-height)`
	};
	else if (sizes.includes(titleSize)) return {
		fontSize: `var(--mantine-font-size-${titleSize})`,
		fontWeight: `var(--mantine-h${order}-font-weight)`,
		lineHeight: `var(--mantine-h${order}-line-height)`
	};
	return {
		fontSize: rem(titleSize),
		fontWeight: `var(--mantine-h${order}-font-weight)`,
		lineHeight: `var(--mantine-h${order}-line-height)`
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Title/Title.module.css.mjs
var classes$2 = { "root": "m_8a5d1357" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Title/Title.mjs
const defaultProps$2 = { order: 1 };
const varsResolver$1 = createVarsResolver((_, { order, size: size$3, lineClamp, textWrap }) => {
	const sizeVariables = getTitleSize(order, size$3);
	return { root: {
		"--title-fw": sizeVariables.fontWeight,
		"--title-lh": sizeVariables.lineHeight,
		"--title-fz": sizeVariables.fontSize,
		"--title-line-clamp": typeof lineClamp === "number" ? lineClamp.toString() : void 0,
		"--title-text-wrap": textWrap
	} };
});
const Title = factory((_props, ref) => {
	const props = useProps("Title", defaultProps$2, _props);
	const { classNames, className, style, styles, unstyled, order, vars, size: size$3, variant, lineClamp, textWrap, mod,...others } = props;
	const getStyles$1 = useStyles({
		name: "Title",
		props,
		classes: classes$2,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$1
	});
	if (![
		1,
		2,
		3,
		4,
		5,
		6
	].includes(order)) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles$1("root"),
		component: `h${order}`,
		variant,
		ref,
		mod: [{
			order,
			"data-line-clamp": typeof lineClamp === "number"
		}, mod],
		size: size$3,
		...others
	});
});
Title.classes = classes$2;
Title.displayName = "@mantine/core/Title";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/TreeNode.mjs
function getValuesRange(anchor, value, flatValues) {
	if (!anchor || !value) return [];
	const anchorIndex = flatValues.indexOf(anchor);
	const valueIndex = flatValues.indexOf(value);
	const start = Math.min(anchorIndex, valueIndex);
	const end = Math.max(anchorIndex, valueIndex);
	return flatValues.slice(start, end + 1);
}
function TreeNode({ node, getStyles: getStyles$1, rootIndex, controller, expandOnClick, selectOnClick, isSubtree, level = 1, renderNode, flatValues, allowRangeSelection, expandOnSpace, checkOnSpace }) {
	const ref = (0, import_react.useRef)(null);
	const nested = (node.children || []).map((child) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TreeNode, {
		node: child,
		flatValues,
		getStyles: getStyles$1,
		rootIndex: void 0,
		level: level + 1,
		controller,
		expandOnClick,
		isSubtree: true,
		renderNode,
		selectOnClick,
		allowRangeSelection,
		expandOnSpace,
		checkOnSpace
	}, child.value));
	const handleKeyDown = (event) => {
		if (event.nativeEvent.code === "ArrowRight") {
			event.stopPropagation();
			event.preventDefault();
			if (controller.expandedState[node.value]) event.currentTarget.querySelector("[role=treeitem]")?.focus();
			else controller.expand(node.value);
		}
		if (event.nativeEvent.code === "ArrowLeft") {
			event.stopPropagation();
			event.preventDefault();
			if (controller.expandedState[node.value] && (node.children || []).length > 0) controller.collapse(node.value);
			else if (isSubtree) findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus();
		}
		if (event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
			const root = findElementAncestor(event.currentTarget, "[data-tree-root]");
			if (!root) return;
			event.stopPropagation();
			event.preventDefault();
			const nodes = Array.from(root.querySelectorAll("[role=treeitem]"));
			const index$4 = nodes.indexOf(event.currentTarget);
			if (index$4 === -1) return;
			const nextIndex = event.nativeEvent.code === "ArrowDown" ? index$4 + 1 : index$4 - 1;
			nodes[nextIndex]?.focus();
			if (event.shiftKey) {
				const selectNode = nodes[nextIndex];
				if (selectNode) controller.setSelectedState(getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues));
			}
		}
		if (event.nativeEvent.code === "Space") {
			if (expandOnSpace) {
				event.stopPropagation();
				event.preventDefault();
				controller.toggleExpanded(node.value);
			}
			if (checkOnSpace) {
				event.stopPropagation();
				event.preventDefault();
				controller.isNodeChecked(node.value) ? controller.uncheckNode(node.value) : controller.checkNode(node.value);
			}
		}
	};
	const handleNodeClick = (event) => {
		event.stopPropagation();
		if (allowRangeSelection && event.shiftKey && controller.anchorNode) {
			controller.setSelectedState(getValuesRange(controller.anchorNode, node.value, flatValues));
			ref.current?.focus();
		} else {
			expandOnClick && controller.toggleExpanded(node.value);
			selectOnClick && controller.select(node.value);
			ref.current?.focus();
		}
	};
	const selected = controller.selectedState.includes(node.value);
	const elementProps = {
		...getStyles$1("label"),
		onClick: handleNodeClick,
		"data-selected": selected || void 0,
		"data-value": node.value,
		"data-hovered": controller.hoveredNode === node.value || void 0
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("li", {
		...getStyles$1("node", { style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` } }),
		role: "treeitem",
		"aria-selected": selected,
		"data-value": node.value,
		"data-selected": selected || void 0,
		"data-hovered": controller.hoveredNode === node.value || void 0,
		"data-level": level,
		tabIndex: rootIndex === 0 ? 0 : -1,
		onKeyDown: handleKeyDown,
		ref,
		onMouseOver: (event) => {
			event.stopPropagation();
			controller.setHoveredNode(node.value);
		},
		onMouseLeave: (event) => {
			event.stopPropagation();
			controller.setHoveredNode(null);
		},
		children: [typeof renderNode === "function" ? renderNode({
			node,
			level,
			selected,
			tree: controller,
			expanded: controller.expandedState[node.value] || false,
			hasChildren: Array.isArray(node.children) && node.children.length > 0,
			elementProps
		}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...elementProps,
			children: node.label
		}), controller.expandedState[node.value] && nested.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
			role: "group",
			...getStyles$1("subtree"),
			"data-level": level,
			children: nested
		})]
	});
}
TreeNode.displayName = "@mantine/core/TreeNode";

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/get-all-checked-nodes/get-all-checked-nodes.mjs
function getAllCheckedNodes(data, checkedState, acc = []) {
	const currentTreeChecked = [];
	for (const node of data) if (Array.isArray(node.children) && node.children.length > 0) {
		const innerChecked = getAllCheckedNodes(node.children, checkedState, acc);
		if (innerChecked.currentTreeChecked.length === node.children.length) {
			const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked);
			const item = {
				checked: isChecked,
				indeterminate: !isChecked,
				value: node.value,
				hasChildren: true
			};
			currentTreeChecked.push(item);
			acc.push(item);
		} else if (innerChecked.currentTreeChecked.length > 0) {
			const item = {
				checked: false,
				indeterminate: true,
				value: node.value,
				hasChildren: true
			};
			currentTreeChecked.push(item);
			acc.push(item);
		}
	} else if (checkedState.includes(node.value)) {
		const item = {
			checked: true,
			indeterminate: false,
			value: node.value,
			hasChildren: false
		};
		currentTreeChecked.push(item);
		acc.push(item);
	}
	return {
		result: acc,
		currentTreeChecked
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/get-children-nodes-values/get-children-nodes-values.mjs
function findTreeNode(value, data) {
	for (const node of data) {
		if (node.value === value) return node;
		if (Array.isArray(node.children)) {
			const childNode = findTreeNode(value, node.children);
			if (childNode) return childNode;
		}
	}
	return null;
}
function getChildrenNodesValues(value, data, acc = []) {
	const node = findTreeNode(value, data);
	if (!node) return acc;
	if (!Array.isArray(node.children) || node.children.length === 0) return [node.value];
	node.children.forEach((child) => {
		if (Array.isArray(child.children) && child.children.length > 0) getChildrenNodesValues(child.value, data, acc);
		else acc.push(child.value);
	});
	return acc;
}
function getAllChildrenNodes(data) {
	return data.reduce((acc, node) => {
		if (Array.isArray(node.children) && node.children.length > 0) acc.push(...getAllChildrenNodes(node.children));
		else acc.push(node.value);
		return acc;
	}, []);
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/is-node-checked/is-node-checked.mjs
function isNodeChecked(value, data, checkedState) {
	if (checkedState.length === 0) return false;
	if (checkedState.includes(value)) return true;
	const checkedNodes = getAllCheckedNodes(data, checkedState).result;
	return checkedNodes.some((node) => node.value === value && node.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/is-node-indeterminate/is-node-indeterminate.mjs
function isNodeIndeterminate(value, data, checkedState) {
	if (checkedState.length === 0) return false;
	const checkedNodes = getAllCheckedNodes(data, checkedState).result;
	return checkedNodes.some((node) => node.value === value && node.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/use-tree.mjs
function getInitialTreeExpandedState(initialState, data, value, acc = {}) {
	data.forEach((node) => {
		acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value;
		if (Array.isArray(node.children)) getInitialTreeExpandedState(initialState, node.children, value, acc);
	});
	return acc;
}
function getTreeExpandedState(data, expandedNodesValues) {
	const state = getInitialTreeExpandedState({}, data, []);
	if (expandedNodesValues === "*") return Object.keys(state).reduce((acc, key) => ({
		...acc,
		[key]: true
	}), {});
	expandedNodesValues.forEach((node) => {
		state[node] = true;
	});
	return state;
}
function getInitialCheckedState(initialState, data) {
	const acc = [];
	initialState.forEach((node) => acc.push(...getChildrenNodesValues(node, data)));
	return Array.from(new Set(acc));
}
function useTree({ initialSelectedState = [], initialCheckedState = [], initialExpandedState = {}, multiple = false, onNodeCollapse, onNodeExpand } = {}) {
	const [data, setData] = (0, import_react.useState)([]);
	const [expandedState, setExpandedState] = (0, import_react.useState)(initialExpandedState);
	const [selectedState, setSelectedState] = (0, import_react.useState)(initialSelectedState);
	const [checkedState, setCheckedState] = (0, import_react.useState)(initialCheckedState);
	const [anchorNode, setAnchorNode] = (0, import_react.useState)(null);
	const [hoveredNode, setHoveredNode] = (0, import_react.useState)(null);
	const initialize = (0, import_react.useCallback)((_data) => {
		setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState));
		setCheckedState((current) => getInitialCheckedState(current, _data));
		setData(_data);
	}, [selectedState, checkedState]);
	const toggleExpanded = (0, import_react.useCallback)((value) => {
		setExpandedState((current) => {
			const nextState = {
				...current,
				[value]: !current[value]
			};
			nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);
			return nextState;
		});
	}, [onNodeCollapse, onNodeExpand]);
	const collapse = (0, import_react.useCallback)((value) => {
		setExpandedState((current) => {
			if (current[value] !== false) onNodeCollapse?.(value);
			return {
				...current,
				[value]: false
			};
		});
	}, [onNodeCollapse]);
	const expand = (0, import_react.useCallback)((value) => {
		setExpandedState((current) => {
			if (current[value] !== true) onNodeExpand?.(value);
			return {
				...current,
				[value]: true
			};
		});
	}, [onNodeExpand]);
	const expandAllNodes = (0, import_react.useCallback)(() => {
		setExpandedState((current) => {
			const next = { ...current };
			Object.keys(next).forEach((key) => {
				next[key] = true;
			});
			return next;
		});
	}, []);
	const collapseAllNodes = (0, import_react.useCallback)(() => {
		setExpandedState((current) => {
			const next = { ...current };
			Object.keys(next).forEach((key) => {
				next[key] = false;
			});
			return next;
		});
	}, []);
	const toggleSelected = (0, import_react.useCallback)((value) => setSelectedState((current) => {
		if (!multiple) {
			if (current.includes(value)) {
				setAnchorNode(null);
				return [];
			}
			setAnchorNode(value);
			return [value];
		}
		if (current.includes(value)) {
			setAnchorNode(null);
			return current.filter((item) => item !== value);
		}
		setAnchorNode(value);
		return [...current, value];
	}), []);
	const select = (0, import_react.useCallback)((value) => {
		setAnchorNode(value);
		setSelectedState((current) => multiple ? current.includes(value) ? current : [...current, value] : [value]);
	}, []);
	const deselect = (0, import_react.useCallback)((value) => {
		anchorNode === value && setAnchorNode(null);
		setSelectedState((current) => current.filter((item) => item !== value));
	}, []);
	const clearSelected = (0, import_react.useCallback)(() => {
		setSelectedState([]);
		setAnchorNode(null);
	}, []);
	const checkNode = (0, import_react.useCallback)((value) => {
		const checkedNodes = getChildrenNodesValues(value, data);
		setCheckedState((current) => Array.from(/* @__PURE__ */ new Set([...current, ...checkedNodes])));
	}, [data]);
	const uncheckNode = (0, import_react.useCallback)((value) => {
		const checkedNodes = getChildrenNodesValues(value, data);
		setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));
	}, [data]);
	const checkAllNodes = (0, import_react.useCallback)(() => {
		setCheckedState(() => getAllChildrenNodes(data));
	}, [data]);
	const uncheckAllNodes = (0, import_react.useCallback)(() => {
		setCheckedState([]);
	}, []);
	const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;
	const isNodeChecked$1 = (value) => memoizedIsNodeChecked(value, data, checkedState);
	const isNodeIndeterminate$1 = (value) => memoizedIsNodeIndeterminate(value, data, checkedState);
	return {
		multiple,
		expandedState,
		selectedState,
		checkedState,
		anchorNode,
		initialize,
		toggleExpanded,
		collapse,
		expand,
		expandAllNodes,
		collapseAllNodes,
		setExpandedState,
		checkNode,
		uncheckNode,
		checkAllNodes,
		uncheckAllNodes,
		setCheckedState,
		toggleSelected,
		select,
		deselect,
		clearSelected,
		setSelectedState,
		hoveredNode,
		setHoveredNode,
		getCheckedNodes,
		isNodeChecked: isNodeChecked$1,
		isNodeIndeterminate: isNodeIndeterminate$1
	};
}

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/Tree.module.css.mjs
var classes$1 = {
	"root": "m_f698e191",
	"subtree": "m_75f3ecf",
	"node": "m_f6970eb1",
	"label": "m_dc283425"
};

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/Tree/Tree.mjs
function getFlatValues(data) {
	return data.reduce((acc, item) => {
		acc.push(item.value);
		if (item.children) acc.push(...getFlatValues(item.children));
		return acc;
	}, []);
}
const defaultProps$1 = {
	expandOnClick: true,
	allowRangeSelection: true,
	expandOnSpace: true
};
const varsResolver = createVarsResolver((_theme, { levelOffset }) => ({ root: { "--level-offset": getSpacing(levelOffset) } }));
const Tree = factory((_props, ref) => {
	const props = useProps("Tree", defaultProps$1, _props);
	const { classNames, className, style, styles, unstyled, vars, data, expandOnClick, tree, renderNode, selectOnClick, clearSelectionOnOutsideClick, allowRangeSelection, expandOnSpace, levelOffset, checkOnSpace,...others } = props;
	const defaultController = useTree();
	const controller = tree || defaultController;
	const getStyles$1 = useStyles({
		name: "Tree",
		classes: classes$1,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver
	});
	const clickOutsideRef = useClickOutside(() => clearSelectionOnOutsideClick && controller.clearSelected());
	const mergedRef = useMergedRef(ref, clickOutsideRef);
	const flatValues = (0, import_react.useMemo)(() => getFlatValues(data), [data]);
	(0, import_react.useEffect)(() => {
		controller.initialize(data);
	}, [data]);
	const nodes = data.map((node, index$4) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TreeNode, {
		node,
		getStyles: getStyles$1,
		rootIndex: index$4,
		expandOnClick,
		selectOnClick,
		controller,
		renderNode,
		flatValues,
		allowRangeSelection,
		expandOnSpace,
		checkOnSpace
	}, node.value));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "ul",
		ref: mergedRef,
		...getStyles$1("root"),
		...others,
		role: "tree",
		"aria-multiselectable": controller.multiple,
		"data-tree-root": true,
		children: nodes
	});
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes$1;

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TypographyStylesProvider/TypographyStylesProvider.module.css.mjs
var classes = { "root": "m_d6493fad" };

//#endregion
//#region node_modules/.pnpm/@mantine+core@8.0.2_@mantine+hooks@8.0.2_react@19.1.0__@types+react@19.1.6_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@mantine/core/esm/components/TypographyStylesProvider/TypographyStylesProvider.mjs
const defaultProps = {};
const TypographyStylesProvider = factory((_props, ref) => {
	const props = useProps("TypographyStylesProvider", defaultProps, _props);
	const { classNames, className, style, styles, unstyled,...others } = props;
	const getStyles$1 = useStyles({
		name: "TypographyStylesProvider",
		classes,
		props,
		className,
		style,
		classNames,
		styles,
		unstyled
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles$1("root"),
		...others
	});
});
TypographyStylesProvider.classes = classes;
TypographyStylesProvider.displayName = "@mantine/core/TypographyStylesProvider";

//#endregion
export { Accordion, AccordionChevron, AccordionControl, AccordionItem, AccordionPanel, ActionIcon, ActionIconGroup, ActionIconGroupSection, Affix, Alert, AlphaSlider, Anchor, AngleSlider, AppShell, AppShellAside, AppShellFooter, AppShellHeader, AppShellMain, AppShellNavbar, AppShellSection, AspectRatio, Autocomplete, Avatar, AvatarGroup, BackgroundImage, Badge, Blockquote, Box, Breadcrumbs, Burger, Button, ButtonGroup, ButtonGroupSection, Card, CardSection, Center, CheckIcon, Checkbox, CheckboxCard, CheckboxGroup, CheckboxIndicator, Chip, ChipGroup, CloseButton, CloseIcon, Code, Collapse, ColorInput, ColorPicker, ColorSchemeScript, ColorSwatch, Combination_default, Combobox, ComboboxChevron, ComboboxClearButton, ComboboxDropdown, ComboboxDropdownTarget, ComboboxEmpty, ComboboxEventsTarget, ComboboxFooter, ComboboxGroup, ComboboxHeader, ComboboxHiddenInput, ComboboxOption, ComboboxOptions, ComboboxSearch, ComboboxTarget, Container, CopyButton, DEFAULT_THEME, Dialog, DirectionContext, DirectionProvider, Divider, Drawer, DrawerBody, DrawerCloseButton, DrawerContent, DrawerHeader, DrawerOverlay, DrawerRoot, DrawerStack, DrawerTitle, FLEX_STYLE_PROPS_DATA, FOCUS_CLASS_NAMES, Fieldset, FileButton, FileInput, Flex, FloatingArrow, FloatingIndicator, FocusTrap, FocusTrapInitialFocus, Grid, GridCol, Group, HeadlessMantineProvider, Highlight, HoverCard, HoverCardDropdown, HoverCardTarget, HueSlider, Image, Indicator, InlineStyles, Input, InputBase, InputClearButton, InputDescription, InputError, InputLabel, InputPlaceholder, InputWrapper, JsonInput, Kbd, List, ListItem, Loader, LoadingOverlay, MantineContext, MantineProvider, MantineThemeContext, MantineThemeProvider, Mark, Menu, MenuDivider, MenuDropdown, MenuItem, MenuLabel, MenuTarget, Modal, ModalBase, ModalBaseBody, ModalBaseCloseButton, ModalBaseContent, ModalBaseHeader, ModalBaseOverlay, ModalBaseTitle, ModalBody, ModalCloseButton, ModalContent, ModalHeader, ModalOverlay, ModalRoot, ModalStack, ModalTitle, MultiSelect, NativeScrollArea, NativeSelect, NavLink, Notification, NumberFormatter, NumberInput, OptionalPortal, OptionsDropdown, Overlay, Pagination, PaginationControl, PaginationDots, PaginationFirst, PaginationItems, PaginationLast, PaginationNext, PaginationPrevious, PaginationRoot, Paper, PasswordInput, Pill, PillGroup, PillsInput, PillsInputField, PinInput, Popover, PopoverDropdown, PopoverTarget, Portal, Progress, ProgressLabel, ProgressRoot, ProgressSection, Radio, RadioCard, RadioGroup, RadioIcon, RadioIndicator, RangeSlider, Rating, RingProgress, STYlE_PROPS_DATA, ScrollArea, ScrollAreaAutosize, SegmentedControl, Select, SemiCircleProgress, SimpleGrid, Skeleton, Slider, Space, Spoiler, Stack, Stepper, StepperCompleted, StepperStep, Switch, SwitchGroup, Table, TableCaption, TableOfContents, TableScrollContainer, TableTbody, TableTd, TableTfoot, TableTh, TableThead, TableTr, Tabs, TabsList, TabsPanel, TabsTab, TagsInput, Text, TextInput, Textarea, ThemeIcon, Timeline, TimelineItem, Title, Tooltip, TooltipFloating, TooltipGroup, Transition, Tree, TypographyStylesProvider, UnstyledButton, VisuallyHidden, _extends, _objectWithoutPropertiesLoose, alpha, camelToKebabCase, closeOnEscape, clsx_default, colorsTuple, convertCssVariables, convertHsvaTo, createEventHandler, createOptionalContext, createPolymorphicComponent, createSafeContext, createScopedKeydownHandler, createTheme, createUseExternalEvents, createVarsResolver, darken, deepMerge, defaultCssVariablesResolver, defaultLoaders, defaultOptionsFilter, defaultVariantColorsResolver, em, extractStyleProps, factory, filterProps, findClosestNumber, findElementAncestor, getAutoContrastValue, getBaseValue, getBreakpointValue, getCSSColorVariables, getContextItemIndex, getContrastColor, getDefaultZIndex, getEnv, getFloatingPosition, getFontSize, getGradient, getLabelsLockup, getLineHeight, getOptionsLockup, getParsedComboboxData, getPrimaryContrastColor, getPrimaryShade, getRadius, getRefProp, getSafeId, getShadow, getSize, getSortedBreakpoints, getSpacing, getStyleObject, getThemeColor, getTransitionProps, getTreeExpandedState, getWithProps, isColorValid, isElement, isLightColor, isMantineColorScheme, isNumberLike, isOptionsGroup, isVirtualColor, keys, lighten, localStorageColorSchemeManager, luminance, mantineHtmlProps, memoize, mergeMantineTheme, mergeThemeOverrides, noop, parseColor, parseStyleProps, parseThemeColor, polymorphicFactory, px, rem, resolveClassNames, resolveStyles, rgba, stylesToString, toRgba, transitions$1 as transitions, useCheckboxCardContext, useCheckboxGroupContext, useCombobox, useComboboxTargetProps, useComputedColorScheme, useDelayedHover, useDirection, useDrawerStackContext, useDrawersStack, useFloatingAutoUpdate, useHovered, useInputProps, useInputWrapperContext, useMantineClassNamesPrefix, useMantineColorScheme, useMantineContext, useMantineCssVariablesResolver, useMantineEnv, useMantineIsHeadless, useMantineStyleNonce, useMantineStylesTransform, useMantineSxTransform, useMantineTheme, useMantineWithStaticClasses, useMatches, useModalStackContext, useModalsStack, useProps, useProviderColorScheme, useRadioCardContext, useRandomClassName, useResolvedStylesApi, useSafeMantineTheme, useStyles, useTree, useVirtualizedCombobox, validateMantineTheme, virtualColor };
//# sourceMappingURL=esm-CVXcWmma.js.map