import { AST_NODE_TYPES } from '@typescript-eslint/types';
import { or, dual, _ } from '@eslint-react/eff';
import { ASTUtils } from '@typescript-eslint/utils';
import { simpleTraverse } from '@typescript-eslint/typescript-estree';
import { toLowerCase, delimiterCase, replace } from 'string-ts';

// src/ast-array-method.ts
function isArrayFromCall(node, loose = true) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  if (node.callee.type !== AST_NODE_TYPES.MemberExpression) return false;
  if (node.callee.property.type !== AST_NODE_TYPES.Identifier) return false;
  const name = node.callee.property.name;
  return name === "from" || loose && name.startsWith("from");
}
function isArrayMapCall(node, loose = true) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  if (node.callee.type !== AST_NODE_TYPES.MemberExpression) return false;
  if (node.callee.property.type !== AST_NODE_TYPES.Identifier) return false;
  const name = node.callee.property.name;
  return name === "map" || loose && name.endsWith("Map");
}

// src/ast-array-method-callback.ts
var indexParamPosition = /* @__PURE__ */ new Map([
  ["every", 1],
  ["filter", 1],
  ["find", 1],
  ["findIndex", 1],
  ["findLast", 1],
  ["findLastIndex", 1],
  ["flatMap", 1],
  ["forEach", 1],
  ["map", 1],
  ["reduce", 2],
  ["reduceRight", 2],
  ["some", 1]
]);
function getArrayMethodCallbackIndexParamPosition(methodName) {
  return indexParamPosition.get(methodName) ?? -1;
}
function getClassId(node) {
  if (node.id != null) return node.id;
  if (node.parent.type === AST_NODE_TYPES.VariableDeclarator && node.parent.id.type === AST_NODE_TYPES.Identifier) {
    return node.parent.id;
  }
  return _;
}
var is = ASTUtils.isNodeOfType;
var isOneOf = ASTUtils.isNodeOfTypes;
var isFunction = isOneOf([
  AST_NODE_TYPES.ArrowFunctionExpression,
  AST_NODE_TYPES.FunctionDeclaration,
  AST_NODE_TYPES.FunctionExpression
]);
var isFunctionType = isOneOf([
  AST_NODE_TYPES.ArrowFunctionExpression,
  AST_NODE_TYPES.FunctionDeclaration,
  AST_NODE_TYPES.FunctionExpression,
  AST_NODE_TYPES.TSCallSignatureDeclaration,
  AST_NODE_TYPES.TSConstructSignatureDeclaration,
  AST_NODE_TYPES.TSDeclareFunction,
  AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
  AST_NODE_TYPES.TSFunctionType,
  AST_NODE_TYPES.TSMethodSignature
]);
var isClass = isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression]);
var isMethodOrProperty = isOneOf([
  AST_NODE_TYPES.PropertyDefinition,
  AST_NODE_TYPES.MethodDefinition
]);
var isLoop = isOneOf([
  AST_NODE_TYPES.DoWhileStatement,
  AST_NODE_TYPES.ForInStatement,
  AST_NODE_TYPES.ForOfStatement,
  AST_NODE_TYPES.ForStatement,
  AST_NODE_TYPES.WhileStatement
]);
var isControlFlow = or(
  isLoop,
  isOneOf([
    AST_NODE_TYPES.IfStatement,
    AST_NODE_TYPES.SwitchStatement
  ])
);
var isConditional = or(
  isControlFlow,
  isOneOf([
    AST_NODE_TYPES.LogicalExpression,
    AST_NODE_TYPES.ConditionalExpression
  ])
);
var isArrayTupleType = isOneOf([AST_NODE_TYPES.TSArrayType, AST_NODE_TYPES.TSTupleType]);
var isProperty = isOneOf([
  AST_NODE_TYPES.PropertyDefinition,
  AST_NODE_TYPES.TSIndexSignature,
  AST_NODE_TYPES.TSParameterProperty,
  AST_NODE_TYPES.TSPropertySignature
]);
var isJSXElement = is(AST_NODE_TYPES.JSXElement);
var isJSXFragment = is(AST_NODE_TYPES.JSXFragment);
var isJSXTagNameExpression = isOneOf([
  AST_NODE_TYPES.JSXIdentifier,
  AST_NODE_TYPES.JSXMemberExpression,
  AST_NODE_TYPES.JSXNamespacedName
]);
var isJSX = isOneOf([
  AST_NODE_TYPES.JSXAttribute,
  AST_NODE_TYPES.JSXClosingElement,
  AST_NODE_TYPES.JSXClosingFragment,
  AST_NODE_TYPES.JSXElement,
  AST_NODE_TYPES.JSXEmptyExpression,
  AST_NODE_TYPES.JSXExpressionContainer,
  AST_NODE_TYPES.JSXFragment,
  AST_NODE_TYPES.JSXIdentifier,
  AST_NODE_TYPES.JSXMemberExpression,
  AST_NODE_TYPES.JSXNamespacedName,
  AST_NODE_TYPES.JSXOpeningElement,
  AST_NODE_TYPES.JSXOpeningFragment,
  AST_NODE_TYPES.JSXSpreadAttribute,
  AST_NODE_TYPES.JSXSpreadChild,
  AST_NODE_TYPES.JSXText
]);
var isDestructuringPattern = isOneOf([
  AST_NODE_TYPES.ArrayPattern,
  AST_NODE_TYPES.AssignmentPattern,
  AST_NODE_TYPES.ObjectPattern,
  AST_NODE_TYPES.RestElement
]);
var isTypeDeclaration = isOneOf([
  AST_NODE_TYPES.TSInterfaceDeclaration,
  AST_NODE_TYPES.TSTypeAliasDeclaration
]);
var isLeftHandSideExpression = isOneOf([
  AST_NODE_TYPES.ArrayExpression,
  AST_NODE_TYPES.ArrayPattern,
  AST_NODE_TYPES.ArrowFunctionExpression,
  AST_NODE_TYPES.CallExpression,
  AST_NODE_TYPES.ClassExpression,
  AST_NODE_TYPES.FunctionExpression,
  AST_NODE_TYPES.Identifier,
  AST_NODE_TYPES.JSXElement,
  AST_NODE_TYPES.JSXFragment,
  AST_NODE_TYPES.Literal,
  AST_NODE_TYPES.TemplateLiteral,
  AST_NODE_TYPES.MemberExpression,
  AST_NODE_TYPES.MetaProperty,
  AST_NODE_TYPES.ObjectExpression,
  AST_NODE_TYPES.ObjectPattern,
  AST_NODE_TYPES.SequenceExpression,
  AST_NODE_TYPES.Super,
  AST_NODE_TYPES.TaggedTemplateExpression,
  AST_NODE_TYPES.ThisExpression
]);
var isLeftHandSideExpressionType = isOneOf([
  AST_NODE_TYPES.ArrayExpression,
  AST_NODE_TYPES.ArrayPattern,
  AST_NODE_TYPES.ArrowFunctionExpression,
  AST_NODE_TYPES.CallExpression,
  AST_NODE_TYPES.ClassExpression,
  AST_NODE_TYPES.FunctionExpression,
  AST_NODE_TYPES.Identifier,
  AST_NODE_TYPES.JSXElement,
  AST_NODE_TYPES.JSXFragment,
  AST_NODE_TYPES.Literal,
  AST_NODE_TYPES.TemplateLiteral,
  AST_NODE_TYPES.MemberExpression,
  AST_NODE_TYPES.MetaProperty,
  AST_NODE_TYPES.ObjectExpression,
  AST_NODE_TYPES.ObjectPattern,
  AST_NODE_TYPES.SequenceExpression,
  AST_NODE_TYPES.Super,
  AST_NODE_TYPES.TaggedTemplateExpression,
  AST_NODE_TYPES.ThisExpression,
  AST_NODE_TYPES.TSAsExpression,
  AST_NODE_TYPES.TSNonNullExpression,
  AST_NODE_TYPES.TSTypeAssertion
]);
var isTypeExpression = isOneOf([
  AST_NODE_TYPES.TSAsExpression,
  AST_NODE_TYPES.TSTypeAssertion,
  AST_NODE_TYPES.TSNonNullExpression,
  AST_NODE_TYPES.TSSatisfiesExpression,
  AST_NODE_TYPES.TSInstantiationExpression
]);
var isTypeAssertionExpression = isOneOf([
  AST_NODE_TYPES.TSAsExpression,
  AST_NODE_TYPES.TSTypeAssertion,
  AST_NODE_TYPES.TSNonNullExpression,
  AST_NODE_TYPES.TSSatisfiesExpression
]);

// src/ast-expression.ts
function getJSExpression(node) {
  if (isTypeExpression(node)) {
    return getJSExpression(node.expression);
  }
  return node;
}
function isThisExpression(node) {
  return getJSExpression(node).type === AST_NODE_TYPES.ThisExpression;
}
function getFunctionId(node) {
  switch (true) {
    // function MaybeComponent() {}
    case ("id" in node && node.id != null):
      return node.id;
    // const whatever = function MaybeComponent() {};
    case (node.parent.type === AST_NODE_TYPES.VariableDeclarator && node.parent.init === node && node.parent.id.type === AST_NODE_TYPES.Identifier):
      return node.parent.id;
    // MaybeComponent = () => {};
    case (node.parent.type === AST_NODE_TYPES.AssignmentExpression && node.parent.right === node && node.parent.operator === "=" && node.parent.left.type === AST_NODE_TYPES.Identifier):
      return node.parent.left;
    // {MaybeComponent: () => {}}
    // {MaybeComponent() {}}
    case (node.parent.type === AST_NODE_TYPES.Property && node.parent.value === node && !node.parent.computed && node.parent.key.type === AST_NODE_TYPES.Identifier):
      return node.parent.key;
    // class {MaybeComponent = () => {}}
    // class {MaybeComponent() {}}
    case (isMethodOrProperty(node.parent) && node.parent.value === node && node.parent.key.type === AST_NODE_TYPES.Identifier):
      return node.parent.key;
    // Follow spec convention for `IsAnonymousFunctionDefinition()` usage.
    //
    // const {MaybeComponent = () => {}} = {};
    // ({MaybeComponent = () => {}} = {});
    case (node.parent.type === AST_NODE_TYPES.AssignmentPattern && node.parent.right === node && node.parent.left.type === AST_NODE_TYPES.Identifier):
      return node.parent.left;
    // const MaybeComponent = (() => {})!;
    // const MaybeComponent = (() => {}) as FunctionComponent;
    // const MaybeComponent = (() => {}) satisfies FunctionComponent;
    case isTypeAssertionExpression(node.parent):
      return getFunctionId(node.parent);
  }
  return _;
}
function getFunctionInitPath(node) {
  if (node.type === AST_NODE_TYPES.FunctionDeclaration) {
    return [node];
  }
  const { parent } = node;
  switch (true) {
    case parent.type === AST_NODE_TYPES.VariableDeclarator:
      return [parent.parent, parent, node];
    case (parent.type === AST_NODE_TYPES.CallExpression && parent.parent.type === AST_NODE_TYPES.VariableDeclarator):
      return [parent.parent.parent, parent.parent, parent, node];
    case (parent.type === AST_NODE_TYPES.CallExpression && parent.parent.type === AST_NODE_TYPES.CallExpression && parent.parent.parent.type === AST_NODE_TYPES.VariableDeclarator):
      return [parent.parent.parent.parent, parent.parent.parent, parent.parent, parent, node];
    case (parent.type === AST_NODE_TYPES.Property && parent.parent.type === AST_NODE_TYPES.ObjectExpression && parent.parent.parent.type === AST_NODE_TYPES.VariableDeclarator):
      return [parent.parent.parent.parent, parent.parent.parent, parent.parent, parent, node];
    case (parent.type === AST_NODE_TYPES.MethodDefinition && parent.parent.parent.type === AST_NODE_TYPES.ClassDeclaration):
      return [parent.parent.parent, parent.parent, parent, node];
    case (parent.type === AST_NODE_TYPES.PropertyDefinition && parent.parent.parent.type === AST_NODE_TYPES.ClassDeclaration):
      return [parent.parent.parent, parent.parent, parent, node];
  }
  return _;
}
function hasCallInFunctionInitPath(callName, initPath) {
  return initPath.some((n) => {
    if (n.type !== AST_NODE_TYPES.CallExpression) {
      return false;
    }
    switch (n.callee.type) {
      case AST_NODE_TYPES.Identifier:
        return n.callee.name === callName;
      case AST_NODE_TYPES.MemberExpression:
        return "name" in n.callee.property && n.callee.property.name === callName;
      default:
        return false;
    }
  });
}
function isEmptyFunction(node) {
  return node.body.type === AST_NODE_TYPES.BlockStatement && node.body.body.length === 0;
}
function findParentNode(node, test) {
  if (node == null) return _;
  let parent = node.parent;
  while (parent != null && parent.type !== AST_NODE_TYPES.Program) {
    if (test(parent)) {
      return parent;
    }
    parent = parent.parent;
  }
  return _;
}
function getNestedIdentifiers(node) {
  const identifiers = [];
  if (node.type === AST_NODE_TYPES.Identifier) {
    identifiers.push(node);
  }
  if ("arguments" in node) {
    const chunk = node.arguments.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("elements" in node) {
    const chunk = node.elements.filter((x) => x != null).map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("properties" in node) {
    const chunk = node.properties.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("expressions" in node) {
    const chunk = node.expressions.map(getNestedIdentifiers).flat(1);
    identifiers.push(...chunk);
  }
  if ("left" in node) {
    const chunk = getNestedIdentifiers(node.left);
    identifiers.push(...chunk);
  }
  if ("right" in node) {
    const chunk = getNestedIdentifiers(node.right);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.Property) {
    const chunk = getNestedIdentifiers(node.value);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.SpreadElement) {
    const chunk = getNestedIdentifiers(node.argument);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.MemberExpression) {
    const chunk = getNestedIdentifiers(node.object);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.UnaryExpression) {
    const chunk = getNestedIdentifiers(node.argument);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.ChainExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.TSNonNullExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.TSAsExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  if (node.type === AST_NODE_TYPES.TSSatisfiesExpression) {
    const chunk = getNestedIdentifiers(node.expression);
    identifiers.push(...chunk);
  }
  return identifiers;
}
function getNestedReturnStatements(node) {
  const statements = [];
  const boundaryNode = isFunction(node) ? node : findParentNode(node, isFunction);
  simpleTraverse(node, {
    enter(node2) {
      if (node2.type !== AST_NODE_TYPES.ReturnStatement) {
        return;
      }
      const parentFunction = findParentNode(node2, isFunction);
      if (parentFunction !== boundaryNode) {
        return;
      }
      statements.push(node2);
    }
  });
  return statements;
}
function getNestedExpressionsOfType(type) {
  const isNodeOfType = is(type);
  return function(node) {
    const boundGetNestedExpressionsOfType = getNestedExpressionsOfType(type);
    const expressions = [];
    if (isNodeOfType(node)) {
      expressions.push(node);
    }
    if ("arguments" in node) {
      const chunk = node.arguments.map(getNestedExpressionsOfType(type)).flat(1);
      expressions.push(...chunk);
    }
    if ("expression" in node && node.expression !== true && node.expression !== false) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if ("left" in node) {
      const chunk = boundGetNestedExpressionsOfType(node.left);
      expressions.push(...chunk);
    }
    if ("right" in node) {
      const chunk = boundGetNestedExpressionsOfType(node.right);
      expressions.push(...chunk);
    }
    if ("test" in node && node.test != null) {
      const chunk = boundGetNestedExpressionsOfType(node.test);
      expressions.push(...chunk);
    }
    if ("consequent" in node) {
      const chunk = Array.isArray(node.consequent) ? node.consequent.map(boundGetNestedExpressionsOfType).flat(1) : boundGetNestedExpressionsOfType(node.consequent);
      expressions.push(...chunk);
    }
    if ("alternate" in node && node.alternate != null) {
      const chunk = Array.isArray(node.alternate) ? node.alternate.map(boundGetNestedExpressionsOfType).flat(1) : boundGetNestedExpressionsOfType(node.alternate);
      expressions.push(...chunk);
    }
    if ("elements" in node) {
      const chunk = node.elements.filter((x) => x != null).map(getNestedExpressionsOfType(type)).flat(1);
      expressions.push(...chunk);
    }
    if ("properties" in node) {
      const chunk = node.properties.map(boundGetNestedExpressionsOfType).flat(1);
      expressions.push(...chunk);
    }
    if ("expressions" in node) {
      const chunk = node.expressions.map(boundGetNestedExpressionsOfType).flat(1);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.Property) {
      const chunk = boundGetNestedExpressionsOfType(node.value);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.SpreadElement) {
      const chunk = boundGetNestedExpressionsOfType(node.argument);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.MemberExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.object);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.UnaryExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.argument);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.ChainExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.TSNonNullExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.TSAsExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    if (node.type === AST_NODE_TYPES.TSSatisfiesExpression) {
      const chunk = boundGetNestedExpressionsOfType(node.expression);
      expressions.push(...chunk);
    }
    return expressions;
  };
}
var getNestedNewExpressions = getNestedExpressionsOfType(AST_NODE_TYPES.NewExpression);
var getNestedCallExpressions = getNestedExpressionsOfType(AST_NODE_TYPES.CallExpression);
function isMultiLine(node) {
  return node.loc.start.line !== node.loc.end.line;
}
function isLineBreak(node) {
  return isOneOf([AST_NODE_TYPES.Literal, AST_NODE_TYPES.JSXText])(node) && typeof node.value === "string" && node.value.trim() === "" && isMultiLine(node);
}
function isLiteral(node, type) {
  if (node.type !== AST_NODE_TYPES.Literal) return false;
  if (type == null) return true;
  switch (type) {
    case "boolean":
      return typeof node.value === "boolean";
    case "null":
      return node.value === null;
    case "number":
      return typeof node.value === "number";
    case "regexp":
      return "regex" in node;
    case "string":
      return typeof node.value === "string";
  }
}
var isNodeEqual = dual(2, (a, b) => {
  switch (true) {
    case a === b:
      return true;
    case a.type !== b.type:
      return false;
    case (a.type === AST_NODE_TYPES.Literal && b.type === AST_NODE_TYPES.Literal):
      return a.value === b.value;
    case (a.type === AST_NODE_TYPES.TemplateElement && b.type === AST_NODE_TYPES.TemplateElement):
      return a.value.raw === b.value.raw;
    case (a.type === AST_NODE_TYPES.TemplateLiteral && b.type === AST_NODE_TYPES.TemplateLiteral): {
      if (a.quasis.length !== b.quasis.length || a.expressions.length !== b.expressions.length) {
        return false;
      }
      let i = a.quasis.length;
      while (i--) {
        if (a.quasis[i]?.value.raw !== b.quasis[i]?.value.raw) {
          return false;
        }
      }
      i = a.expressions.length;
      while (i--) {
        const exprA = a.expressions[i];
        const exprB = b.expressions[i];
        if (!isNodeEqual(exprA, exprB)) {
          return false;
        }
      }
      return true;
    }
    case (a.type === AST_NODE_TYPES.Identifier && b.type === AST_NODE_TYPES.Identifier):
      return a.name === b.name;
    case (a.type === AST_NODE_TYPES.PrivateIdentifier && b.type === AST_NODE_TYPES.PrivateIdentifier):
      return a.name === b.name;
    case (a.type === AST_NODE_TYPES.MemberExpression && b.type === AST_NODE_TYPES.MemberExpression):
      return isNodeEqual(a.property, b.property) && isNodeEqual(a.object, b.object);
    case (a.type === AST_NODE_TYPES.JSXAttribute && b.type === AST_NODE_TYPES.JSXAttribute): {
      if (a.name.name !== b.name.name) {
        return false;
      }
      if (a.value == null || b.value == null) {
        return a.value === b.value;
      }
      return isNodeEqual(a.value, b.value);
    }
    case (a.type === AST_NODE_TYPES.ThisExpression && b.type === AST_NODE_TYPES.ThisExpression):
      return true;
    default:
      return false;
  }
});
function isProcessEnvNodeEnv(node) {
  return node != null && node.type === AST_NODE_TYPES.MemberExpression && node.object.type === AST_NODE_TYPES.MemberExpression && node.object.object.type === AST_NODE_TYPES.Identifier && node.object.object.name === "process" && node.object.property.type === AST_NODE_TYPES.Identifier && node.object.property.name === "env" && node.property.type === AST_NODE_TYPES.Identifier && node.property.name === "NODE_ENV";
}
function isProcessEnvNodeEnvCompare(node, operator, value) {
  if (node == null) return false;
  if (node.type !== AST_NODE_TYPES.BinaryExpression) return false;
  if (node.operator !== operator) return false;
  if (isProcessEnvNodeEnv(node.left) && isLiteral(node.right, "string")) {
    return node.right.value === value;
  }
  if (isLiteral(node.left, "string") && isProcessEnvNodeEnv(node.right)) {
    return node.left.value === value;
  }
  return false;
}
function getPropertyName(node) {
  if (isTypeExpression(node)) {
    return getPropertyName(getJSExpression(node));
  }
  if (node.type === AST_NODE_TYPES.Identifier || node.type === AST_NODE_TYPES.PrivateIdentifier) {
    return node.name;
  }
  if (node.type === AST_NODE_TYPES.Literal) {
    return String(node.value);
  }
  if (node.type === AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return node.quasis[0]?.value.raw;
  }
  return _;
}
function getLiteralValueType(input) {
  if (input === null) return "null";
  return typeof input;
}
function toDelimiterCaseType(node, delimiter = " ") {
  if (node.type === AST_NODE_TYPES.Literal) {
    if ("regex" in node) {
      return "RegExp literal";
    }
    return `${getLiteralValueType(node.value)} literal`;
  }
  if (isJSX(node)) {
    return `JSX ${toLowerCase(delimiterCase(replace(node.type, "JSX", ""), delimiter))}`;
  }
  return toLowerCase(delimiterCase(node.type, delimiter));
}
function toString(node, getText) {
  switch (node.type) {
    case AST_NODE_TYPES.Identifier:
    case AST_NODE_TYPES.JSXIdentifier:
    case AST_NODE_TYPES.PrivateIdentifier:
      return node.name;
    case AST_NODE_TYPES.MemberExpression:
    case AST_NODE_TYPES.JSXMemberExpression:
      return `${toString(node.object, getText)}.${toString(node.property, getText)}`;
    case AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case AST_NODE_TYPES.JSXText:
      return node.value;
    case AST_NODE_TYPES.Literal:
      return node.raw;
    default:
      return getText(node);
  }
}

export { findParentNode, getArrayMethodCallbackIndexParamPosition, getClassId, getFunctionId, getFunctionInitPath, getJSExpression, getNestedCallExpressions, getNestedExpressionsOfType, getNestedIdentifiers, getNestedNewExpressions, getNestedReturnStatements, getPropertyName, hasCallInFunctionInitPath, is, isArrayFromCall, isArrayMapCall, isArrayTupleType, isClass, isConditional, isControlFlow, isDestructuringPattern, isEmptyFunction, isFunction, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isLeftHandSideExpression, isLeftHandSideExpressionType, isLineBreak, isLiteral, isLoop, isMethodOrProperty, isMultiLine, isNodeEqual, isOneOf, isProcessEnvNodeEnv, isProcessEnvNodeEnvCompare, isProperty, isThisExpression, isTypeAssertionExpression, isTypeDeclaration, isTypeExpression, toDelimiterCaseType, toString };
