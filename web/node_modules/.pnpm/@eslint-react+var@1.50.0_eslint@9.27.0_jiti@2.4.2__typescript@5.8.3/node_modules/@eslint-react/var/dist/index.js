'use strict';

var eff = require('@eslint-react/eff');
var scopeManager = require('@typescript-eslint/scope-manager');
var types = require('@typescript-eslint/types');
var ASTUtils = require('@typescript-eslint/utils/ast-utils');
var AST = require('@eslint-react/ast');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var ASTUtils__namespace = /*#__PURE__*/_interopNamespace(ASTUtils);
var AST__namespace = /*#__PURE__*/_interopNamespace(AST);

// src/var-collect.ts
function getVariableInitNode(variable, at) {
  if (variable == null) return eff._;
  const def = variable.defs.at(at);
  if (def == null) return eff._;
  switch (true) {
    case (def.type === scopeManager.DefinitionType.FunctionName && def.node.type === types.AST_NODE_TYPES.FunctionDeclaration):
      return def.node;
    case (def.type === scopeManager.DefinitionType.ClassName && def.node.type === types.AST_NODE_TYPES.ClassDeclaration):
      return def.node;
    case ("init" in def.node && def.node.init != null && !("declarations" in def.node.init)):
      return def.node.init;
    default:
      return eff._;
  }
}

// src/var-collect.ts
function getVariables(initialScope) {
  let scope = initialScope;
  const variables = [...scope.variables];
  while (scope.type !== scopeManager.ScopeType.global) {
    scope = scope.upper;
    variables.push(...scope.variables);
  }
  return variables.reverse();
}
var findVariable2 = eff.dual(2, (nameOrNode, initialScope) => {
  if (nameOrNode == null) return eff._;
  return ASTUtils__namespace.findVariable(initialScope, nameOrNode) ?? eff._;
});
function findPropertyInProperties(name, properties, initialScope, seen = /* @__PURE__ */ new Set()) {
  return properties.findLast((prop) => {
    if (prop.type === types.AST_NODE_TYPES.Property) {
      return "name" in prop.key && prop.key.name === name;
    }
    if (prop.type === types.AST_NODE_TYPES.SpreadElement) {
      switch (prop.argument.type) {
        case types.AST_NODE_TYPES.Identifier: {
          if (seen.has(prop.argument.name)) return false;
          const variable = findVariable2(prop.argument.name, initialScope);
          const variableNode = getVariableInitNode(variable, 0);
          if (variableNode?.type === types.AST_NODE_TYPES.ObjectExpression) {
            seen.add(prop.argument.name);
            return findPropertyInProperties(
              name,
              variableNode.properties,
              initialScope,
              seen
            ) != null;
          }
          return false;
        }
        case types.AST_NODE_TYPES.ObjectExpression: {
          return findPropertyInProperties(
            name,
            prop.argument.properties,
            initialScope,
            seen
          ) != null;
        }
        default:
          return false;
      }
    }
    return false;
  });
}
var ConstructionDetectionHint = {
  None: 0n,
  StrictCallExpression: 1n << 0n
};
function getConstruction(node, initialScope, hint = ConstructionDetectionHint.None) {
  if (node == null) return eff._;
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXElement:
    case types.AST_NODE_TYPES.JSXFragment:
      return { kind: "JSXElement", node };
    case types.AST_NODE_TYPES.ArrayExpression:
      return { kind: "ArrayExpression", node };
    case types.AST_NODE_TYPES.ObjectExpression:
      return { kind: "ObjectExpression", node };
    case types.AST_NODE_TYPES.ClassExpression:
      return { kind: "ClassExpression", node };
    case types.AST_NODE_TYPES.NewExpression:
      return { kind: "NewExpression", node };
    case types.AST_NODE_TYPES.FunctionExpression:
    case types.AST_NODE_TYPES.ArrowFunctionExpression:
      return { kind: "FunctionExpression", node };
    case types.AST_NODE_TYPES.CallExpression: {
      if (hint & ConstructionDetectionHint.StrictCallExpression) {
        return { kind: "CallExpression", node };
      }
      return eff._;
    }
    case types.AST_NODE_TYPES.MemberExpression: {
      if (!("object" in node)) return eff._;
      return getConstruction(node.object, initialScope, hint);
    }
    case types.AST_NODE_TYPES.AssignmentExpression:
    case types.AST_NODE_TYPES.AssignmentPattern: {
      if (!("right" in node)) return eff._;
      return getConstruction(node.right, initialScope, hint);
    }
    case types.AST_NODE_TYPES.LogicalExpression: {
      const lvc = getConstruction(node.left, initialScope, hint);
      if (lvc == null) return eff._;
      return getConstruction(node.right, initialScope, hint);
    }
    case types.AST_NODE_TYPES.ConditionalExpression: {
      const cvc = getConstruction(node.consequent, initialScope, hint);
      if (cvc == null) return eff._;
      return getConstruction(node.alternate, initialScope, hint);
    }
    case types.AST_NODE_TYPES.Identifier: {
      if (!("name" in node) || typeof node.name !== "string") {
        return eff._;
      }
      const variable = initialScope.set.get(node.name);
      const variableNode = getVariableInitNode(variable, -1);
      return getConstruction(variableNode, initialScope, hint);
    }
    case types.AST_NODE_TYPES.Literal: {
      if ("regex" in node) {
        return { kind: "RegExpLiteral", node };
      }
      return eff._;
    }
    default: {
      if (!("expression" in node) || typeof node.expression !== "object") {
        return eff._;
      }
      return getConstruction(node.expression, initialScope, hint);
    }
  }
}
function getVariableDeclaratorId(node, prev) {
  if (node == null) return eff._;
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return node.id;
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return node.left;
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return eff._;
    default:
      return getVariableDeclaratorId(node.parent, node);
  }
}

// src/var-scope.ts
function getChidScopes(scope) {
  const scopes = [scope];
  for (const childScope of scope.childScopes) {
    scopes.push(...getChidScopes(childScope));
  }
  return scopes;
}
function toStaticValue(lazyValue) {
  const { kind, node, initialScope } = lazyValue;
  if (kind !== "lazy") {
    return lazyValue;
  }
  const staticValue = initialScope == null ? ASTUtils.getStaticValue(node) : ASTUtils.getStaticValue(node, initialScope);
  return staticValue == null ? { kind: "none", node, initialScope } : { kind: "some", node, initialScope, value: staticValue.value };
}
var thisBlockTypes = [
  types.AST_NODE_TYPES.FunctionDeclaration,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.ClassBody,
  types.AST_NODE_TYPES.Program
];
function isNodeValueEqual(a, b, initialScopes) {
  const [aScope, bScope] = initialScopes;
  switch (true) {
    case a === b: {
      return true;
    }
    case (a.type === types.AST_NODE_TYPES.Literal && b.type === types.AST_NODE_TYPES.Literal): {
      return a.value === b.value;
    }
    case (a.type === types.AST_NODE_TYPES.TemplateElement && b.type === types.AST_NODE_TYPES.TemplateElement): {
      return a.value.cooked === b.value.cooked;
    }
    case (a.type === types.AST_NODE_TYPES.Identifier && b.type === types.AST_NODE_TYPES.Identifier): {
      const aVar = findVariable2(a, aScope);
      const bVar = findVariable2(b, bScope);
      const aVarNode = getVariableInitNodeLoose(aVar, 0);
      const bVarNode = getVariableInitNodeLoose(bVar, 0);
      const aVarNodeParent = aVarNode?.parent;
      const bVarNodeParent = bVarNode?.parent;
      const aDef = aVar?.defs.at(0);
      const bDef = bVar?.defs.at(0);
      const aDefParentParent = aDef?.parent?.parent;
      const bDefParentParent = bDef?.parent?.parent;
      switch (true) {
        case (aVarNodeParent?.type === types.AST_NODE_TYPES.CallExpression && bVarNodeParent?.type === types.AST_NODE_TYPES.CallExpression && AST__namespace.isFunction(aVarNode) && AST__namespace.isFunction(bVarNode)): {
          if (!AST__namespace.isNodeEqual(aVarNodeParent.callee, bVarNodeParent.callee)) {
            return false;
          }
          const aParams = aVarNode.params;
          const bParams = bVarNode.params;
          const aPos = aParams.findIndex((x) => AST__namespace.isNodeEqual(x, a));
          const bPos = bParams.findIndex((x) => AST__namespace.isNodeEqual(x, b));
          return aPos !== -1 && bPos !== -1 && aPos === bPos;
        }
        case (aDefParentParent?.type === types.AST_NODE_TYPES.ForOfStatement && bDefParentParent?.type === types.AST_NODE_TYPES.ForOfStatement): {
          const aLeft = aDefParentParent.left;
          const bLeft = bDefParentParent.left;
          if (aLeft.type !== bLeft.type) {
            return false;
          }
          const aRight = aDefParentParent.right;
          const bRight = bDefParentParent.right;
          return AST__namespace.isNodeEqual(aRight, bRight);
        }
        default: {
          return aVar != null && bVar != null && aVar === bVar;
        }
      }
    }
    case (a.type === types.AST_NODE_TYPES.MemberExpression && b.type === types.AST_NODE_TYPES.MemberExpression): {
      return AST__namespace.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
    }
    case (a.type === types.AST_NODE_TYPES.ThisExpression && b.type === types.AST_NODE_TYPES.ThisExpression): {
      if (aScope.block === bScope.block) {
        return true;
      }
      const aFunction = AST__namespace.findParentNode(a, AST__namespace.isOneOf(thisBlockTypes));
      const bFunction = AST__namespace.findParentNode(b, AST__namespace.isOneOf(thisBlockTypes));
      return aFunction === bFunction;
    }
    default: {
      const aStatic = toStaticValue({ kind: "lazy", node: a, initialScope: aScope });
      const bStatic = toStaticValue({ kind: "lazy", node: b, initialScope: bScope });
      return aStatic.kind !== "none" && bStatic.kind !== "none" && aStatic.value === bStatic.value;
    }
  }
}
function getVariableInitNodeLoose(variable, at) {
  if (variable == null) return eff._;
  const node = getVariableInitNode(variable, at);
  if (node != null) return node;
  const def = variable.defs.at(at);
  if (def?.type === scopeManager.DefinitionType.Parameter && AST__namespace.isFunction(def.node)) return def.node;
  return eff._;
}

exports.ConstructionDetectionHint = ConstructionDetectionHint;
exports.findPropertyInProperties = findPropertyInProperties;
exports.findVariable = findVariable2;
exports.getChidScopes = getChidScopes;
exports.getConstruction = getConstruction;
exports.getVariableDeclaratorId = getVariableDeclaratorId;
exports.getVariableInitNode = getVariableInitNode;
exports.getVariables = getVariables;
exports.isNodeValueEqual = isNodeValueEqual;
exports.toStaticValue = toStaticValue;
