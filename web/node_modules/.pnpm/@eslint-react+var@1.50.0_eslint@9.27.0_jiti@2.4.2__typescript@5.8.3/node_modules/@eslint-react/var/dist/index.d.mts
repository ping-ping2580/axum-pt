import { Scope, Variable } from '@typescript-eslint/scope-manager';
import { TSESTree } from '@typescript-eslint/types';
import { _ } from '@eslint-react/eff';

/**
 * Get all variables from the given scope up to the global scope
 * @param initialScope The scope to start from
 * @returns All variables from the given scope up to the global scope
 */
declare function getVariables(initialScope: Scope): Variable[];
declare const findVariable: {
    (initialScope: Scope): (nameOrNode: string | TSESTree.Identifier | _) => Variable | _;
    (nameOrNode: string | TSESTree.Identifier | _, initialScope: Scope): Variable | _;
};
declare function findPropertyInProperties(name: string, properties: (TSESTree.Property | TSESTree.RestElement | TSESTree.SpreadElement)[], initialScope: Scope, seen?: Set<string>): (typeof properties)[number] | _;

declare const ConstructionDetectionHint: {
    None: bigint;
    StrictCallExpression: bigint;
};
type Construction = {
    kind: "ArrayExpression";
    node: TSESTree.ArrayExpression;
} | {
    kind: "CallExpression";
    node: TSESTree.CallExpression;
} | {
    kind: "ClassExpression";
    node: TSESTree.ClassExpression;
} | {
    kind: "FunctionDeclaration";
    node: TSESTree.FunctionDeclaration;
} | {
    kind: "FunctionExpression";
    node: TSESTree.FunctionExpression | TSESTree.ArrowFunctionExpression;
} | {
    kind: "JSXElement";
    node: TSESTree.JSXElement | TSESTree.JSXFragment;
} | {
    kind: "NewExpression";
    node: TSESTree.NewExpression;
} | {
    kind: "ObjectExpression";
    node: TSESTree.ObjectExpression;
} | {
    kind: "RegExpLiteral";
    node: TSESTree.RegExpLiteral;
};
/**
 * Detects the construction type of a given node.
 * @param node The node to check.
 * @param initialScope  The initial scope to check for variable declarations.
 * @param hint Optional hint to control the detection behavior.
 * @returns The construction type of the node, or `_` if not found.
 */
declare function getConstruction(node: TSESTree.Node | _, initialScope: Scope, hint?: bigint): Construction | _;

declare function getVariableDeclaratorId(node: TSESTree.Node | _, prev?: TSESTree.Node): TSESTree.BindingName | TSESTree.Expression | _;

declare function getVariableInitNode(variable: Variable | _, at: number): _ | TSESTree.ClassDeclaration | TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.Expression | TSESTree.FunctionDeclaration | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName;

declare function getChidScopes(scope: Scope): readonly Scope[];

type LazyValue = {
    kind: "lazy";
    node: TSESTree.Node;
    initialScope: Scope | _;
} | {
    kind: "none";
    node: TSESTree.Node;
    initialScope: Scope | _;
} | {
    kind: "some";
    node: TSESTree.Node;
    value: unknown;
    initialScope: Scope | _;
};
declare function toStaticValue(lazyValue: LazyValue): {
    readonly kind: "none";
    readonly node: TSESTree.Node;
    readonly initialScope: Scope | undefined;
    readonly value?: never;
} | {
    readonly kind: "some";
    readonly node: TSESTree.Node;
    readonly initialScope: Scope | undefined;
    readonly value: unknown;
};

/**
 * Determines whether node value equals to another node value
 * @param a node to compare
 * @param b node to compare
 * @param initialScopes initial scopes of the two nodes
 * @returns `true` if node value equal
 */
declare function isNodeValueEqual(a: TSESTree.Node, b: TSESTree.Node, initialScopes: [
    aScope: Scope,
    bScope: Scope
]): boolean;

export { type Construction, ConstructionDetectionHint, type LazyValue, findPropertyInProperties, findVariable, getChidScopes, getConstruction, getVariableDeclaratorId, getVariableInitNode, getVariables, isNodeValueEqual, toStaticValue };
