import { dual, _ } from '@eslint-react/eff';
import { DefinitionType, ScopeType } from '@typescript-eslint/scope-manager';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import * as ASTUtils from '@typescript-eslint/utils/ast-utils';
import { getStaticValue } from '@typescript-eslint/utils/ast-utils';
import * as AST from '@eslint-react/ast';

// src/var-collect.ts
function getVariableInitNode(variable, at) {
  if (variable == null) return _;
  const def = variable.defs.at(at);
  if (def == null) return _;
  switch (true) {
    case (def.type === DefinitionType.FunctionName && def.node.type === AST_NODE_TYPES.FunctionDeclaration):
      return def.node;
    case (def.type === DefinitionType.ClassName && def.node.type === AST_NODE_TYPES.ClassDeclaration):
      return def.node;
    case ("init" in def.node && def.node.init != null && !("declarations" in def.node.init)):
      return def.node.init;
    default:
      return _;
  }
}

// src/var-collect.ts
function getVariables(initialScope) {
  let scope = initialScope;
  const variables = [...scope.variables];
  while (scope.type !== ScopeType.global) {
    scope = scope.upper;
    variables.push(...scope.variables);
  }
  return variables.reverse();
}
var findVariable2 = dual(2, (nameOrNode, initialScope) => {
  if (nameOrNode == null) return _;
  return ASTUtils.findVariable(initialScope, nameOrNode) ?? _;
});
function findPropertyInProperties(name, properties, initialScope, seen = /* @__PURE__ */ new Set()) {
  return properties.findLast((prop) => {
    if (prop.type === AST_NODE_TYPES.Property) {
      return "name" in prop.key && prop.key.name === name;
    }
    if (prop.type === AST_NODE_TYPES.SpreadElement) {
      switch (prop.argument.type) {
        case AST_NODE_TYPES.Identifier: {
          if (seen.has(prop.argument.name)) return false;
          const variable = findVariable2(prop.argument.name, initialScope);
          const variableNode = getVariableInitNode(variable, 0);
          if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) {
            seen.add(prop.argument.name);
            return findPropertyInProperties(
              name,
              variableNode.properties,
              initialScope,
              seen
            ) != null;
          }
          return false;
        }
        case AST_NODE_TYPES.ObjectExpression: {
          return findPropertyInProperties(
            name,
            prop.argument.properties,
            initialScope,
            seen
          ) != null;
        }
        default:
          return false;
      }
    }
    return false;
  });
}
var ConstructionDetectionHint = {
  None: 0n,
  StrictCallExpression: 1n << 0n
};
function getConstruction(node, initialScope, hint = ConstructionDetectionHint.None) {
  if (node == null) return _;
  switch (node.type) {
    case AST_NODE_TYPES.JSXElement:
    case AST_NODE_TYPES.JSXFragment:
      return { kind: "JSXElement", node };
    case AST_NODE_TYPES.ArrayExpression:
      return { kind: "ArrayExpression", node };
    case AST_NODE_TYPES.ObjectExpression:
      return { kind: "ObjectExpression", node };
    case AST_NODE_TYPES.ClassExpression:
      return { kind: "ClassExpression", node };
    case AST_NODE_TYPES.NewExpression:
      return { kind: "NewExpression", node };
    case AST_NODE_TYPES.FunctionExpression:
    case AST_NODE_TYPES.ArrowFunctionExpression:
      return { kind: "FunctionExpression", node };
    case AST_NODE_TYPES.CallExpression: {
      if (hint & ConstructionDetectionHint.StrictCallExpression) {
        return { kind: "CallExpression", node };
      }
      return _;
    }
    case AST_NODE_TYPES.MemberExpression: {
      if (!("object" in node)) return _;
      return getConstruction(node.object, initialScope, hint);
    }
    case AST_NODE_TYPES.AssignmentExpression:
    case AST_NODE_TYPES.AssignmentPattern: {
      if (!("right" in node)) return _;
      return getConstruction(node.right, initialScope, hint);
    }
    case AST_NODE_TYPES.LogicalExpression: {
      const lvc = getConstruction(node.left, initialScope, hint);
      if (lvc == null) return _;
      return getConstruction(node.right, initialScope, hint);
    }
    case AST_NODE_TYPES.ConditionalExpression: {
      const cvc = getConstruction(node.consequent, initialScope, hint);
      if (cvc == null) return _;
      return getConstruction(node.alternate, initialScope, hint);
    }
    case AST_NODE_TYPES.Identifier: {
      if (!("name" in node) || typeof node.name !== "string") {
        return _;
      }
      const variable = initialScope.set.get(node.name);
      const variableNode = getVariableInitNode(variable, -1);
      return getConstruction(variableNode, initialScope, hint);
    }
    case AST_NODE_TYPES.Literal: {
      if ("regex" in node) {
        return { kind: "RegExpLiteral", node };
      }
      return _;
    }
    default: {
      if (!("expression" in node) || typeof node.expression !== "object") {
        return _;
      }
      return getConstruction(node.expression, initialScope, hint);
    }
  }
}
function getVariableDeclaratorId(node, prev) {
  if (node == null) return _;
  switch (true) {
    case (node.type === AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return node.id;
    case (node.type === AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return node.left;
    case (node.type === AST_NODE_TYPES.BlockStatement || node.type === AST_NODE_TYPES.Program || node.parent === node):
      return _;
    default:
      return getVariableDeclaratorId(node.parent, node);
  }
}

// src/var-scope.ts
function getChidScopes(scope) {
  const scopes = [scope];
  for (const childScope of scope.childScopes) {
    scopes.push(...getChidScopes(childScope));
  }
  return scopes;
}
function toStaticValue(lazyValue) {
  const { kind, node, initialScope } = lazyValue;
  if (kind !== "lazy") {
    return lazyValue;
  }
  const staticValue = initialScope == null ? getStaticValue(node) : getStaticValue(node, initialScope);
  return staticValue == null ? { kind: "none", node, initialScope } : { kind: "some", node, initialScope, value: staticValue.value };
}
var thisBlockTypes = [
  AST_NODE_TYPES.FunctionDeclaration,
  AST_NODE_TYPES.FunctionExpression,
  AST_NODE_TYPES.ClassBody,
  AST_NODE_TYPES.Program
];
function isNodeValueEqual(a, b, initialScopes) {
  const [aScope, bScope] = initialScopes;
  switch (true) {
    case a === b: {
      return true;
    }
    case (a.type === AST_NODE_TYPES.Literal && b.type === AST_NODE_TYPES.Literal): {
      return a.value === b.value;
    }
    case (a.type === AST_NODE_TYPES.TemplateElement && b.type === AST_NODE_TYPES.TemplateElement): {
      return a.value.cooked === b.value.cooked;
    }
    case (a.type === AST_NODE_TYPES.Identifier && b.type === AST_NODE_TYPES.Identifier): {
      const aVar = findVariable2(a, aScope);
      const bVar = findVariable2(b, bScope);
      const aVarNode = getVariableInitNodeLoose(aVar, 0);
      const bVarNode = getVariableInitNodeLoose(bVar, 0);
      const aVarNodeParent = aVarNode?.parent;
      const bVarNodeParent = bVarNode?.parent;
      const aDef = aVar?.defs.at(0);
      const bDef = bVar?.defs.at(0);
      const aDefParentParent = aDef?.parent?.parent;
      const bDefParentParent = bDef?.parent?.parent;
      switch (true) {
        case (aVarNodeParent?.type === AST_NODE_TYPES.CallExpression && bVarNodeParent?.type === AST_NODE_TYPES.CallExpression && AST.isFunction(aVarNode) && AST.isFunction(bVarNode)): {
          if (!AST.isNodeEqual(aVarNodeParent.callee, bVarNodeParent.callee)) {
            return false;
          }
          const aParams = aVarNode.params;
          const bParams = bVarNode.params;
          const aPos = aParams.findIndex((x) => AST.isNodeEqual(x, a));
          const bPos = bParams.findIndex((x) => AST.isNodeEqual(x, b));
          return aPos !== -1 && bPos !== -1 && aPos === bPos;
        }
        case (aDefParentParent?.type === AST_NODE_TYPES.ForOfStatement && bDefParentParent?.type === AST_NODE_TYPES.ForOfStatement): {
          const aLeft = aDefParentParent.left;
          const bLeft = bDefParentParent.left;
          if (aLeft.type !== bLeft.type) {
            return false;
          }
          const aRight = aDefParentParent.right;
          const bRight = bDefParentParent.right;
          return AST.isNodeEqual(aRight, bRight);
        }
        default: {
          return aVar != null && bVar != null && aVar === bVar;
        }
      }
    }
    case (a.type === AST_NODE_TYPES.MemberExpression && b.type === AST_NODE_TYPES.MemberExpression): {
      return AST.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
    }
    case (a.type === AST_NODE_TYPES.ThisExpression && b.type === AST_NODE_TYPES.ThisExpression): {
      if (aScope.block === bScope.block) {
        return true;
      }
      const aFunction = AST.findParentNode(a, AST.isOneOf(thisBlockTypes));
      const bFunction = AST.findParentNode(b, AST.isOneOf(thisBlockTypes));
      return aFunction === bFunction;
    }
    default: {
      const aStatic = toStaticValue({ kind: "lazy", node: a, initialScope: aScope });
      const bStatic = toStaticValue({ kind: "lazy", node: b, initialScope: bScope });
      return aStatic.kind !== "none" && bStatic.kind !== "none" && aStatic.value === bStatic.value;
    }
  }
}
function getVariableInitNodeLoose(variable, at) {
  if (variable == null) return _;
  const node = getVariableInitNode(variable, at);
  if (node != null) return node;
  const def = variable.defs.at(at);
  if (def?.type === DefinitionType.Parameter && AST.isFunction(def.node)) return def.node;
  return _;
}

export { ConstructionDetectionHint, findPropertyInProperties, findVariable2 as findVariable, getChidScopes, getConstruction, getVariableDeclaratorId, getVariableInitNode, getVariables, isNodeValueEqual, toStaticValue };
