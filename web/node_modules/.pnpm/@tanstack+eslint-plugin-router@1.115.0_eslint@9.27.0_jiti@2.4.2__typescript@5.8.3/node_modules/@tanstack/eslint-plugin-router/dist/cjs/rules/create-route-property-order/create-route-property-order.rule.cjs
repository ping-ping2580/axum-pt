"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const utils = require("@typescript-eslint/utils");
const getDocsUrl = require("../../utils/get-docs-url.cjs");
const detectRouterImports = require("../../utils/detect-router-imports.cjs");
const createRoutePropertyOrder_utils = require("./create-route-property-order.utils.cjs");
const constants = require("./constants.cjs");
const createRule = utils.ESLintUtils.RuleCreator(getDocsUrl.getDocsUrl);
const createRouteFunctionSet = new Set(constants.createRouteFunctions);
function isCreateRouteFunction(node) {
  return createRouteFunctionSet.has(node);
}
const name = "create-route-property-order";
const rule = createRule({
  name,
  meta: {
    type: "problem",
    docs: {
      description: "Ensure correct order of inference sensitive properties for createRoute functions",
      recommended: "error"
    },
    messages: {
      invalidOrder: "Invalid order of properties for `{{function}}`."
    },
    schema: [],
    hasSuggestions: true,
    fixable: "code"
  },
  defaultOptions: [],
  create: detectRouterImports.detectTanstackRouterImports((context) => {
    return {
      CallExpression(node) {
        if (node.callee.type !== utils.AST_NODE_TYPES.Identifier) {
          return;
        }
        const createRouteFunction = node.callee.name;
        if (!isCreateRouteFunction(createRouteFunction)) {
          return;
        }
        let args = node.arguments;
        if (constants.createRouteFunctionsIndirect.includes(createRouteFunction)) {
          if (node.parent.type === utils.AST_NODE_TYPES.CallExpression) {
            args = node.parent.arguments;
          } else {
            return;
          }
        }
        const argument = args[0];
        if (argument === void 0 || argument.type !== "ObjectExpression") {
          return;
        }
        const allProperties = argument.properties;
        if (allProperties.length < 2) {
          return;
        }
        const properties = allProperties.flatMap((p) => {
          if (p.type === utils.AST_NODE_TYPES.Property && p.key.type === utils.AST_NODE_TYPES.Identifier) {
            return { name: p.key.name, property: p };
          } else if (p.type === utils.AST_NODE_TYPES.SpreadElement) {
            if (p.argument.type === utils.AST_NODE_TYPES.Identifier) {
              return { name: p.argument.name, property: p };
            } else {
              throw new Error("Unsupported spread element");
            }
          }
          return [];
        });
        const sortedProperties = createRoutePropertyOrder_utils.sortDataByOrder(properties, constants.sortRules, "name");
        if (sortedProperties === null) {
          return;
        }
        context.report({
          node: argument,
          data: { function: node.callee.name },
          messageId: "invalidOrder",
          fix(fixer) {
            const sourceCode = context.sourceCode;
            const text = sortedProperties.reduce(
              (sourceText, specifier, index) => {
                let text2 = "";
                if (index < allProperties.length - 1) {
                  text2 = sourceCode.getText().slice(
                    allProperties[index].range[1],
                    allProperties[index + 1].range[0]
                  );
                }
                return sourceText + sourceCode.getText(specifier.property) + text2;
              },
              ""
            );
            return fixer.replaceTextRange(
              [allProperties[0].range[0], allProperties.at(-1).range[1]],
              text
            );
          }
        });
      }
    };
  })
});
exports.name = name;
exports.rule = rule;
//# sourceMappingURL=create-route-property-order.rule.cjs.map
