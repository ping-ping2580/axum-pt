'use strict';

var AST9 = require('@eslint-react/ast');
var eff = require('@eslint-react/eff');
var kit = require('@eslint-react/kit');
var shared = require('@eslint-react/shared');
var types = require('@typescript-eslint/types');
var VAR3 = require('@eslint-react/var');
var tsPattern = require('ts-pattern');
var birecord = require('birecord');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST9__namespace = /*#__PURE__*/_interopNamespace(AST9);
var VAR3__namespace = /*#__PURE__*/_interopNamespace(VAR3);
var birecord__default = /*#__PURE__*/_interopDefault(birecord);

// src/component/component-collector.ts
function getInstanceId(node, prev) {
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return node.id;
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return node.left;
    case (node.type === types.AST_NODE_TYPES.PropertyDefinition && node.value === prev):
      return node.key;
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return eff._;
    default:
      return getInstanceId(node.parent, node);
  }
}
function getRequireExpressionArguments(node) {
  return tsPattern.match(node).with({ type: types.AST_NODE_TYPES.CallExpression, arguments: tsPattern.P.select(), callee: { type: types.AST_NODE_TYPES.Identifier, name: "require" } }, eff.identity).with({ type: types.AST_NODE_TYPES.MemberExpression, object: tsPattern.P.select() }, getRequireExpressionArguments).otherwise(() => null);
}
function isInitializedFromReact(name, importSource, initialScope) {
  if (name.toLowerCase() === "react") return true;
  const latestDef = VAR3__namespace.findVariable(name, initialScope)?.defs.at(-1);
  if (latestDef == null) return false;
  const { node, parent } = latestDef;
  if (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init != null) {
    const { init } = node;
    if (init.type === types.AST_NODE_TYPES.MemberExpression && init.object.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.object.name, importSource, initialScope);
    }
    if (init.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.name, importSource, initialScope);
    }
    const args = getRequireExpressionArguments(init);
    const arg0 = args?.[0];
    if (arg0 == null || !AST9__namespace.isLiteral(arg0, "string")) {
      return false;
    }
    return arg0.value === importSource || arg0.value.startsWith(`${importSource}/`);
  }
  return parent?.type === types.AST_NODE_TYPES.ImportDeclaration && parent.source.value === importSource;
}
function isInstanceIdEqual(context, a, b) {
  return AST9__namespace.isNodeEqual(a, b) || VAR3__namespace.isNodeValueEqual(a, b, [
    context.sourceCode.getScope(a),
    context.sourceCode.getScope(b)
  ]);
}
function isReactAPI(api) {
  const func = (context, node) => {
    if (node == null) return false;
    const getText = (n) => context.sourceCode.getText(n);
    const name = AST9__namespace.toString(node, getText);
    if (name === api) return true;
    if (name.substring(name.indexOf(".") + 1) === api) return true;
    return false;
  };
  return eff.dual(2, func);
}
function isReactAPICall(api) {
  const func = (context, node) => {
    if (node == null) return false;
    if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
    return isReactAPI(api)(context, node.callee);
  };
  return eff.dual(2, func);
}
var isCaptureOwnerStack = isReactAPI("captureOwnerStack");
var isChildrenCount = isReactAPI("Children.count");
var isChildrenForEach = isReactAPI("Children.forEach");
var isChildrenMap = isReactAPI("Children.map");
var isChildrenOnly = isReactAPI("Children.only");
var isChildrenToArray = isReactAPI("Children.toArray");
var isCloneElement = isReactAPI("cloneElement");
var isCreateContext = isReactAPI("createContext");
var isCreateElement = isReactAPI("createElement");
var isCreateRef = isReactAPI("createRef");
var isForwardRef = isReactAPI("forwardRef");
var isMemo = isReactAPI("memo");
var isLazy = isReactAPI("lazy");
var isCaptureOwnerStackCall = isReactAPICall("captureOwnerStack");
var isChildrenCountCall = isReactAPICall("Children.count");
var isChildrenForEachCall = isReactAPICall("Children.forEach");
var isChildrenMapCall = isReactAPICall("Children.map");
var isChildrenOnlyCall = isReactAPICall("Children.only");
var isChildrenToArrayCall = isReactAPICall("Children.toArray");
var isCloneElementCall = isReactAPICall("cloneElement");
var isCreateContextCall = isReactAPICall("createContext");
var isCreateElementCall = isReactAPICall("createElement");
var isCreateRefCall = isReactAPICall("createRef");
var isForwardRefCall = isReactAPICall("forwardRef");
var isMemoCall = isReactAPICall("memo");
var isLazyCall = isReactAPICall("lazy");

// src/hook/hook-name.ts
function isReactHookName(name) {
  return name === "use" || /^use[A-Z0-9]/.test(name);
}

// src/hook/hook-is.ts
function isReactHook(node) {
  if (node == null) return false;
  const id = AST9__namespace.getFunctionId(node);
  return id?.name != null && isReactHookName(id.name);
}
function isReactHookCall(node) {
  if (node == null) return false;
  if (node.type !== types.AST_NODE_TYPES.CallExpression) {
    return false;
  }
  if (node.callee.type === types.AST_NODE_TYPES.Identifier) {
    return isReactHookName(node.callee.name);
  }
  if (node.callee.type === types.AST_NODE_TYPES.MemberExpression) {
    return node.callee.property.type === types.AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
  }
  return false;
}
function isReactHookCallWithName(context, node) {
  if (node == null || node.type !== types.AST_NODE_TYPES.CallExpression) return eff.constFalse;
  const {
    importSource = shared.DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = shared.coerceSettings(context.settings);
  const initialScope = context.sourceCode.getScope(node);
  return (name) => {
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameLoose(node) {
  if (node == null || node.type !== types.AST_NODE_TYPES.CallExpression) return eff.constFalse;
  return (name) => {
    switch (node.callee.type) {
      case types.AST_NODE_TYPES.Identifier:
        return node.callee.name === name;
      case types.AST_NODE_TYPES.MemberExpression:
        return node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name;
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameAlias(context, name, alias = []) {
  const {
    importSource = shared.DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = shared.coerceSettings(context.settings);
  return (node) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return alias.some(isReactHookCallWithNameLoose(node));
    }
  };
}
function isUseEffectCallLoose(node) {
  if (node == null) return false;
  if (node.type !== types.AST_NODE_TYPES.CallExpression) {
    return false;
  }
  switch (node.callee.type) {
    case types.AST_NODE_TYPES.Identifier:
      return /^use\w*Effect$/u.test(node.callee.name);
    case types.AST_NODE_TYPES.MemberExpression:
      return node.callee.property.type === types.AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
    default:
      return false;
  }
}
var isUseCall = eff.flip(isReactHookCallWithName)("use");
var isUseActionStateCall = eff.flip(isReactHookCallWithName)("useActionState");
var isUseCallbackCall = eff.flip(isReactHookCallWithName)("useCallback");
var isUseContextCall = eff.flip(isReactHookCallWithName)("useContext");
var isUseDebugValueCall = eff.flip(isReactHookCallWithName)("useDebugValue");
var isUseDeferredValueCall = eff.flip(isReactHookCallWithName)("useDeferredValue");
var isUseEffectCall = eff.flip(isReactHookCallWithName)("useEffect");
var isUseFormStatusCall = eff.flip(isReactHookCallWithName)("useFormStatus");
var isUseIdCall = eff.flip(isReactHookCallWithName)("useId");
var isUseImperativeHandleCall = eff.flip(isReactHookCallWithName)("useImperativeHandle");
var isUseInsertionEffectCall = eff.flip(isReactHookCallWithName)("useInsertionEffect");
var isUseLayoutEffectCall = eff.flip(isReactHookCallWithName)("useLayoutEffect");
var isUseMemoCall = eff.flip(isReactHookCallWithName)("useMemo");
var isUseOptimisticCall = eff.flip(isReactHookCallWithName)("useOptimistic");
var isUseReducerCall = eff.flip(isReactHookCallWithName)("useReducer");
var isUseRefCall = eff.flip(isReactHookCallWithName)("useRef");
var isUseStateCall = eff.flip(isReactHookCallWithName)("useState");
var isUseSyncExternalStoreCall = eff.flip(isReactHookCallWithName)("useSyncExternalStore");
var isUseTransitionCall = eff.flip(isReactHookCallWithName)("useTransition");

// src/hook/hook-collector.ts
function useHookCollector() {
  const hooks = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const onFunctionEnter = (node) => {
    const id = AST9__namespace.getFunctionId(node);
    const key = shared.getId();
    const name = id?.name;
    if (name != null && isReactHookName(name)) {
      functionEntries.push({ key, node, isHook: true });
      hooks.set(key, {
        id,
        key,
        kind: "function",
        name,
        node,
        flag: 0n,
        hint: 0n,
        hookCalls: []
      });
      return;
    }
    functionEntries.push({ key, node, isHook: false });
  };
  const onFunctionExit = () => {
    functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllHooks(node) {
      return hooks;
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "CallExpression[type]"(node) {
      if (!isReactHookCall(node)) {
        return;
      }
      const fEntry = functionEntries.at(-1);
      if (fEntry?.key == null) {
        return;
      }
      const hook = hooks.get(fEntry.key);
      if (hook == null) {
        return;
      }
      hook.hookCalls.push(node);
    }
  };
  return { ctx, listeners };
}
function isFunctionOfUseEffectSetup(node) {
  if (node == null) return false;
  return node.parent?.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee !== node && node.parent.callee.type === types.AST_NODE_TYPES.Identifier && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isFunctionOfUseEffectCleanup(node) {
  if (node == null) return false;
  const pReturn = AST9__namespace.findParentNode(node, AST9__namespace.is(types.AST_NODE_TYPES.ReturnStatement));
  const pFunction = AST9__namespace.findParentNode(node, AST9__namespace.isFunction);
  const pFunctionOfReturn = AST9__namespace.findParentNode(pReturn, AST9__namespace.isFunction);
  if (pFunction !== pFunctionOfReturn) return false;
  return isFunctionOfUseEffectSetup(pFunction);
}
function stringifyJsx(node) {
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXIdentifier:
      return node.name;
    case types.AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case types.AST_NODE_TYPES.JSXMemberExpression:
      return `${stringifyJsx(node.object)}.${stringifyJsx(node.property)}`;
    case types.AST_NODE_TYPES.JSXText:
      return node.value;
    case types.AST_NODE_TYPES.JSXOpeningElement:
      return `<${stringifyJsx(node.name)}>`;
    case types.AST_NODE_TYPES.JSXClosingElement:
      return `</${stringifyJsx(node.name)}>`;
    case types.AST_NODE_TYPES.JSXOpeningFragment:
      return "<>";
    case types.AST_NODE_TYPES.JSXClosingFragment:
      return "</>";
  }
}

// src/jsx/jsx-attribute-name.ts
function getAttributeName(context, node) {
  return stringifyJsx(node.name);
}

// src/jsx/jsx-attribute.ts
function getAttribute(context, name, attributes, initialScope) {
  return attributes.findLast((attr) => {
    if (attr.type === types.AST_NODE_TYPES.JSXAttribute) {
      return getAttributeName(context, attr) === name;
    }
    if (initialScope == null) return false;
    switch (attr.argument.type) {
      case types.AST_NODE_TYPES.Identifier: {
        const variable = VAR3__namespace.findVariable(attr.argument.name, initialScope);
        const variableNode = VAR3__namespace.getVariableInitNode(variable, 0);
        if (variableNode?.type === types.AST_NODE_TYPES.ObjectExpression) {
          return VAR3__namespace.findPropertyInProperties(name, variableNode.properties, initialScope) != null;
        }
        return false;
      }
      case types.AST_NODE_TYPES.ObjectExpression:
        return VAR3__namespace.findPropertyInProperties(name, attr.argument.properties, initialScope) != null;
    }
    return false;
  });
}
function getAttributeValue(context, node, name) {
  const initialScope = context.sourceCode.getScope(node);
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXAttribute:
      if (node.value?.type === types.AST_NODE_TYPES.Literal) {
        return {
          kind: "some",
          node: node.value,
          initialScope,
          value: node.value.value
        };
      }
      if (node.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer) {
        return VAR3__namespace.toStaticValue({
          kind: "lazy",
          node: node.value.expression,
          initialScope
        });
      }
      return { kind: "none", node, initialScope };
    case types.AST_NODE_TYPES.JSXSpreadAttribute: {
      const staticValue = VAR3__namespace.toStaticValue({
        kind: "lazy",
        node: node.argument,
        initialScope
      });
      if (staticValue.kind === "none") {
        return staticValue;
      }
      return tsPattern.match(staticValue.value).with({ [name]: tsPattern.P.select(tsPattern.P.any) }, (value) => ({
        kind: "some",
        node: node.argument,
        initialScope,
        value
      })).otherwise(() => ({ kind: "none", node, initialScope }));
    }
    default:
      return { kind: "none", node, initialScope };
  }
}

// src/jsx/jsx-detection-hint.ts
var JSXDetectionHint = {
  None: 0n,
  SkipUndefined: 1n << 0n,
  SkipNullLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipBigIntLiteral: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  SkipCreateElement: 1n << 7n,
  StrictArray: 1n << 8n,
  StrictLogical: 1n << 9n,
  StrictConditional: 1n << 10n
};
var DEFAULT_JSX_DETECTION_HINT = 0n | JSXDetectionHint.SkipUndefined | JSXDetectionHint.SkipBooleanLiteral;

// src/jsx/jsx-detection.ts
function isJsxText(node) {
  if (node == null) return false;
  return node.type === types.AST_NODE_TYPES.JSXText || node.type === types.AST_NODE_TYPES.Literal;
}
function isJsxLike(code, node, hint = DEFAULT_JSX_DETECTION_HINT) {
  if (node == null) return false;
  if (AST9__namespace.isJSX(node)) return true;
  switch (node.type) {
    case types.AST_NODE_TYPES.Literal: {
      switch (typeof node.value) {
        case "boolean":
          return !(hint & JSXDetectionHint.SkipBooleanLiteral);
        case "string":
          return !(hint & JSXDetectionHint.SkipStringLiteral);
        case "number":
          return !(hint & JSXDetectionHint.SkipNumberLiteral);
        case "bigint":
          return !(hint & JSXDetectionHint.SkipBigIntLiteral);
      }
      if (node.value == null) {
        return !(hint & JSXDetectionHint.SkipNullLiteral);
      }
      return false;
    }
    case types.AST_NODE_TYPES.TemplateLiteral: {
      return !(hint & JSXDetectionHint.SkipStringLiteral);
    }
    case types.AST_NODE_TYPES.ArrayExpression: {
      if (hint & JSXDetectionHint.StrictArray) {
        return node.elements.every((n) => isJsxLike(code, n, hint));
      }
      return node.elements.some((n) => isJsxLike(code, n, hint));
    }
    case types.AST_NODE_TYPES.LogicalExpression: {
      if (hint & JSXDetectionHint.StrictLogical) {
        return isJsxLike(code, node.left, hint) && isJsxLike(code, node.right, hint);
      }
      return isJsxLike(code, node.left, hint) || isJsxLike(code, node.right, hint);
    }
    case types.AST_NODE_TYPES.ConditionalExpression: {
      let leftHasJSX2 = function(node2) {
        if (Array.isArray(node2.consequent)) {
          if (node2.consequent.length === 0) {
            return !(hint & JSXDetectionHint.SkipEmptyArray);
          }
          if (hint & JSXDetectionHint.StrictArray) {
            return node2.consequent.every((n) => isJsxLike(code, n, hint));
          }
          return node2.consequent.some((n) => isJsxLike(code, n, hint));
        }
        return isJsxLike(code, node2.consequent, hint);
      }, rightHasJSX2 = function(node2) {
        return isJsxLike(code, node2.alternate, hint);
      };
      if (hint & JSXDetectionHint.StrictConditional) {
        return leftHasJSX2(node) && rightHasJSX2(node);
      }
      return leftHasJSX2(node) || rightHasJSX2(node);
    }
    case types.AST_NODE_TYPES.SequenceExpression: {
      const exp = node.expressions.at(-1);
      return isJsxLike(code, exp, hint);
    }
    case types.AST_NODE_TYPES.CallExpression: {
      if (hint & JSXDetectionHint.SkipCreateElement) {
        return false;
      }
      switch (node.callee.type) {
        case types.AST_NODE_TYPES.Identifier:
          return node.callee.name === "createElement";
        case types.AST_NODE_TYPES.MemberExpression:
          return node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
      }
      return false;
    }
    case types.AST_NODE_TYPES.Identifier: {
      const { name } = node;
      if (name === "undefined") {
        return !(hint & JSXDetectionHint.SkipUndefined);
      }
      if (AST9__namespace.isJSXTagNameExpression(node)) {
        return true;
      }
      const variable = VAR3__namespace.findVariable(name, code.getScope(node));
      const variableNode = variable && VAR3__namespace.getVariableInitNode(variable, 0);
      return !!variableNode && isJsxLike(code, variableNode, hint);
    }
  }
  return false;
}
function getElementType(context, node) {
  if (node.type === types.AST_NODE_TYPES.JSXFragment) {
    return "";
  }
  return stringifyJsx(node.openingElement.name);
}

// src/jsx/jsx-has.ts
function hasAttribute(context, name, attributes, initialScope) {
  return getAttribute(context, name, attributes, initialScope) != null;
}
function hasAnyAttribute(context, names, attributes, initialScope) {
  return names.some((n) => hasAttribute(context, n, attributes, initialScope));
}
function hasEveryAttribute(context, names, attributes, initialScope) {
  return names.every((n) => hasAttribute(context, n, attributes, initialScope));
}
function findParentAttribute(node, test = eff.constTrue) {
  const guard = (node2) => {
    return node2.type === types.AST_NODE_TYPES.JSXAttribute && test(node2);
  };
  return AST9__namespace.findParentNode(node, guard);
}
function isHostElement(context, node) {
  return node.type === types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === types.AST_NODE_TYPES.JSXIdentifier && /^[a-z]/u.test(node.openingElement.name.name);
}
function isKeyedElement(context, node, initialScope) {
  return node.type === types.AST_NODE_TYPES.JSXElement && hasAttribute(context, "key", node.openingElement.attributes, initialScope);
}
function isFragmentElement(context, node, allowJSXFragment = false) {
  if (node == null) return false;
  if (node.type !== types.AST_NODE_TYPES.JSXElement && node.type !== types.AST_NODE_TYPES.JSXFragment) return false;
  if (node.type === types.AST_NODE_TYPES.JSXFragment) return allowJSXFragment;
  return getElementType(context, node).split(".").at(-1) === "Fragment";
}

// src/component/component-detection-hint.ts
var ComponentDetectionHint = {
  /**
   * 1n << 0n - 1n << 63n are reserved for JSXDetectionHint
   */
  ...JSXDetectionHint,
  /**
   * Skip function component created by React.memo
   */
  SkipMemo: 1n << 64n,
  /**
   * Skip function component created by React.forwardRef
   */
  SkipForwardRef: 1n << 65n,
  /**
   * Skip function component defined as array map argument
   */
  SkipArrayMapArgument: 1n << 66n,
  /**
   * Skip function component defined on object method
   */
  SkipObjectMethod: 1n << 67n,
  /**
   * Skip function component defined on class method
   */
  SkipClassMethod: 1n << 68n,
  /**
   * Skip function component defined on class property
   */
  SkipClassProperty: 1n << 69n
};
var DEFAULT_COMPONENT_DETECTION_HINT = 0n | ComponentDetectionHint.SkipBooleanLiteral | ComponentDetectionHint.SkipEmptyArray | ComponentDetectionHint.SkipArrayMapArgument | ComponentDetectionHint.SkipNumberLiteral | ComponentDetectionHint.SkipStringLiteral | ComponentDetectionHint.SkipUndefined | ComponentDetectionHint.StrictArray | ComponentDetectionHint.StrictConditional | ComponentDetectionHint.StrictLogical;
function isClassComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^(?:Pure)?Component$/u;
    switch (true) {
      case node.superClass.type === types.AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === types.AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}
function isPureComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^PureComponent$/u;
    switch (true) {
      case node.superClass.type === types.AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === types.AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}
function isComponentDidCatch(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidCatch";
}
function isComponentDidMount(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentDidUpdate(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
function isComponentWillMount(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
function isComponentWillReceiveProps(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
function isComponentWillUnmount(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentWillUpdate(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
function isGetChildContext(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getChildContext";
}
function isGetDefaultProps(node) {
  return AST9__namespace.isMethodOrProperty(node) && node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getDefaultProps";
}
function isGetInitialState(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getInitialState";
}
function isGetSnapshotBeforeUpdate(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getSnapshotBeforeUpdate";
}
function isShouldComponentUpdate(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
function isUnsafeComponentWillMount(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
function isUnsafeComponentWillReceiveProps(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
function isUnsafeComponentWillUpdate(node) {
  return AST9__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
function isGetDerivedStateFromProps(node) {
  return AST9__namespace.isMethodOrProperty(node) && node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromProps";
}
function isGetDerivedStateFromError(node) {
  return AST9__namespace.isMethodOrProperty(node) && node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromError";
}
function isRenderLike(node) {
  return AST9__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "render" && node.parent.parent.type === types.AST_NODE_TYPES.ClassDeclaration;
}
function isFunctionOfRender(node) {
  if (!isRenderLike(node.parent)) {
    return false;
  }
  return isClassComponent(node.parent.parent.parent);
}
function isRenderMethodLike(node) {
  return AST9__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name.startsWith("render") && node.parent.parent.type === types.AST_NODE_TYPES.ClassDeclaration;
}

// src/component/component-hierarchy.ts
function isChildrenOfCreateElement(context, node) {
  const parent = node.parent;
  if (parent == null || parent.type !== types.AST_NODE_TYPES.CallExpression) return false;
  if (!isCreateElementCall(context, parent)) return false;
  return parent.arguments.slice(2).some((arg) => arg === node);
}
function isInsideRenderMethod(node) {
  return AST9__namespace.findParentNode(node, (n) => isRenderLike(n) && isClassComponent(n.parent.parent)) != null;
}
function isFunctionOfComponentDidMount(node) {
  return AST9__namespace.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isFunctionOfComponentWillUnmount(node) {
  return AST9__namespace.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
function isFunctionOfRenderMethod(node) {
  if (!isRenderMethodLike(node.parent)) {
    return false;
  }
  return isClassComponent(node.parent.parent.parent);
}

// src/component/component-definition.ts
var isFunctionOfClassMethod = tsPattern.isMatching({
  type: tsPattern.P.union(types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression),
  parent: types.AST_NODE_TYPES.MethodDefinition
});
var isFunctionOfClassProperty = tsPattern.isMatching({
  type: tsPattern.P.union(types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression),
  parent: types.AST_NODE_TYPES.Property
});
var isFunctionOfObjectMethod = tsPattern.isMatching({
  type: tsPattern.P.union(types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression),
  parent: {
    type: types.AST_NODE_TYPES.Property,
    parent: {
      type: types.AST_NODE_TYPES.ObjectExpression
    }
  }
});
function isValidComponentDefinition(context, node, hint) {
  if (isChildrenOfCreateElement(context, node) || isFunctionOfRenderMethod(node)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipObjectMethod && isFunctionOfObjectMethod(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipClassMethod && isFunctionOfClassMethod(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipClassProperty && isFunctionOfClassProperty(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipArrayMapArgument && AST9__namespace.isArrayMapCall(node.parent)) {
    return false;
  }
  const significantParent = AST9__namespace.findParentNode(
    node,
    AST9__namespace.isOneOf([
      types.AST_NODE_TYPES.JSXExpressionContainer,
      types.AST_NODE_TYPES.ArrowFunctionExpression,
      types.AST_NODE_TYPES.FunctionExpression,
      types.AST_NODE_TYPES.Property,
      types.AST_NODE_TYPES.ClassBody
    ])
  );
  return significantParent == null || significantParent.type !== types.AST_NODE_TYPES.JSXExpressionContainer;
}
function isComponentWrapperCall(context, node) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
  return isMemoCall(context, node) || isForwardRefCall(context, node);
}
function isComponentWrapperCallLoose(context, node) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
  return isComponentWrapperCall(context, node) || isUseCallbackCall(context, node);
}

// src/component/component-id.ts
function getFunctionComponentId(context, node) {
  const functionId = AST9__namespace.getFunctionId(node);
  if (functionId != null) {
    return functionId;
  }
  const { parent } = node;
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return parent.parent.id;
  }
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent.parent) && parent.parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return parent.parent.parent.id;
  }
  return eff._;
}

// src/component/component-flag.ts
var ComponentFlag = {
  None: 0n,
  PureComponent: 1n << 0n,
  CreateElement: 1n << 1n,
  Memo: 1n << 2n,
  ForwardRef: 1n << 3n,
  Async: 1n << 4n
};

// src/component/component-init-path.ts
function getComponentFlagFromInitPath(initPath) {
  let flag = ComponentFlag.None;
  if (initPath != null && AST9__namespace.hasCallInFunctionInitPath("memo", initPath)) {
    flag |= ComponentFlag.Memo;
  }
  if (initPath != null && AST9__namespace.hasCallInFunctionInitPath("forwardRef", initPath)) {
    flag |= ComponentFlag.ForwardRef;
  }
  return flag;
}
function isComponentName(name) {
  return kit.RegExp.COMPONENT_NAME.test(name);
}
function isComponentNameLoose(name) {
  return kit.RegExp.COMPONENT_NAME_LOOSE.test(name);
}
function getComponentNameFromId(id) {
  if (id == null) return eff._;
  return Array.isArray(id) ? id.map((n) => n.name).join(".") : id.name;
}
function hasNoneOrLooseComponentName(context, fn) {
  const id = getFunctionComponentId(context, fn);
  if (id == null) return true;
  const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
  return name != null && isComponentNameLoose(name);
}

// src/component/component-collector.ts
function useComponentCollector(context, options = {}) {
  const {
    collectDisplayName = false,
    collectHookCalls = false,
    hint = DEFAULT_COMPONENT_DETECTION_HINT
  } = options;
  const components = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const getCurrentEntry = () => functionEntries.at(-1);
  const onFunctionEnter = (node) => {
    const key = shared.getId();
    functionEntries.push({ key, node, hookCalls: [], isComponent: false });
  };
  const onFunctionExit = () => {
    const entry = functionEntries.at(-1);
    if (entry == null) return;
    if (!entry.isComponent) return functionEntries.pop();
    const shouldDrop = AST9__namespace.getNestedReturnStatements(entry.node.body).slice().reverse().some((r) => {
      return context.sourceCode.getScope(r).block === entry.node && r.argument != null && !isJsxLike(context.sourceCode, r.argument, hint);
    });
    if (shouldDrop) {
      components.delete(entry.key);
    }
    return functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    },
    getCurrentEntries() {
      return [...functionEntries];
    },
    getCurrentEntry
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "ArrowFunctionExpression[body.type!='BlockStatement']"() {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const { body } = entry.node;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, body, hint) && isValidComponentDefinition(context, entry.node, hint);
      if (!isComponent) return;
      const initPath = AST9__namespace.getFunctionInitPath(entry.node);
      const id = getFunctionComponentId(context, entry.node);
      const name = getComponentNameFromId(id);
      const key = shared.getId();
      components.set(key, {
        id,
        key,
        kind: "function",
        name,
        node: entry.node,
        displayName: eff._,
        flag: getComponentFlagFromInitPath(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    },
    ...collectDisplayName ? {
      [kit.Selector.DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
        const { left, right } = node;
        if (left.type !== types.AST_NODE_TYPES.MemberExpression) return;
        const componentName = left.object.type === types.AST_NODE_TYPES.Identifier ? left.object.name : eff._;
        const component = [...components.values()].findLast(({ name }) => name != null && name === componentName);
        if (component == null) return;
        component.displayName = right;
      }
    } : {},
    ...collectHookCalls ? {
      "CallExpression[type]:exit"(node) {
        if (!isReactHookCall(node)) return;
        const entry = getCurrentEntry();
        if (entry == null) return;
        entry.hookCalls.push(node);
      }
    } : {},
    "ReturnStatement[type]"(node) {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, node.argument, hint) && isValidComponentDefinition(context, entry.node, hint);
      if (!isComponent) return;
      entry.isComponent = true;
      const initPath = AST9__namespace.getFunctionInitPath(entry.node);
      const id = getFunctionComponentId(context, entry.node);
      const name = getComponentNameFromId(id);
      components.set(entry.key, {
        id,
        key: entry.key,
        kind: "function",
        name,
        node: entry.node,
        displayName: eff._,
        flag: getComponentFlagFromInitPath(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    }
  };
  return { ctx, listeners };
}
function useComponentCollectorLegacy() {
  const components = /* @__PURE__ */ new Map();
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    }
  };
  const collect = (node) => {
    if (!isClassComponent(node)) {
      return;
    }
    const id = AST9__namespace.getClassId(node);
    const key = shared.getId();
    const flag = isPureComponent(node) ? ComponentFlag.PureComponent : ComponentFlag.None;
    components.set(
      key,
      {
        id,
        key,
        kind: "class",
        name: id?.name,
        node,
        // TODO: Get displayName of class component
        displayName: eff._,
        flag,
        hint: 0n,
        // TODO: Get methods of class component
        methods: []
      }
    );
  };
  const listeners = {
    "ClassDeclaration[type]": collect,
    "ClassExpression[type]": collect
  };
  return { ctx, listeners };
}
var ComponentPhaseRelevance = birecord__default.default({
  mount: "unmount",
  setup: "cleanup"
});
var isInversePhase = eff.dual(2, (a, b) => ComponentPhaseRelevance.get(a) === b);
function isRenderFunctionLoose(context, node) {
  const { body, parent } = node;
  if (AST9__namespace.getFunctionId(node)?.name.startsWith("render")) {
    return parent.type === types.AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === types.AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === types.AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
  }
  return isJsxLike(
    context.sourceCode,
    body,
    JSXDetectionHint.SkipNullLiteral | JSXDetectionHint.SkipUndefined | JSXDetectionHint.StrictLogical | JSXDetectionHint.StrictConditional
  );
}
function isRenderPropLoose(context, node) {
  if (node.name.type !== types.AST_NODE_TYPES.JSXIdentifier) {
    return false;
  }
  return node.name.name.startsWith("render") && node.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer && AST9__namespace.isFunction(node.value.expression) && isRenderFunctionLoose(context, node.value.expression);
}
function isDirectValueOfRenderPropertyLoose(node) {
  const matching = (node2) => {
    return node2.type === types.AST_NODE_TYPES.Property && node2.key.type === types.AST_NODE_TYPES.Identifier && node2.key.name.startsWith("render");
  };
  return matching(node) || node.parent != null && matching(node.parent);
}
function isDeclaredInRenderPropLoose(node) {
  if (isDirectValueOfRenderPropertyLoose(node)) {
    return true;
  }
  const parent = AST9__namespace.findParentNode(node, AST9__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer))?.parent;
  if (parent?.type !== types.AST_NODE_TYPES.JSXAttribute) {
    return false;
  }
  return parent.name.type === types.AST_NODE_TYPES.JSXIdentifier && parent.name.name.startsWith("render");
}
function isThisSetState(node) {
  const { callee } = node;
  return callee.type === types.AST_NODE_TYPES.MemberExpression && AST9__namespace.isThisExpression(callee.object) && callee.property.type === types.AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}
function isAssignmentToThisState(node) {
  const { left } = node;
  return left.type === types.AST_NODE_TYPES.MemberExpression && AST9__namespace.isThisExpression(left.object) && AST9__namespace.getPropertyName(left.property) === "state";
}

exports.ComponentDetectionHint = ComponentDetectionHint;
exports.ComponentFlag = ComponentFlag;
exports.ComponentPhaseRelevance = ComponentPhaseRelevance;
exports.DEFAULT_COMPONENT_DETECTION_HINT = DEFAULT_COMPONENT_DETECTION_HINT;
exports.DEFAULT_JSX_DETECTION_HINT = DEFAULT_JSX_DETECTION_HINT;
exports.JSXDetectionHint = JSXDetectionHint;
exports.findParentAttribute = findParentAttribute;
exports.getAttribute = getAttribute;
exports.getAttributeName = getAttributeName;
exports.getAttributeValue = getAttributeValue;
exports.getComponentFlagFromInitPath = getComponentFlagFromInitPath;
exports.getComponentNameFromId = getComponentNameFromId;
exports.getElementType = getElementType;
exports.getFunctionComponentId = getFunctionComponentId;
exports.getInstanceId = getInstanceId;
exports.hasAnyAttribute = hasAnyAttribute;
exports.hasAttribute = hasAttribute;
exports.hasEveryAttribute = hasEveryAttribute;
exports.hasNoneOrLooseComponentName = hasNoneOrLooseComponentName;
exports.isAssignmentToThisState = isAssignmentToThisState;
exports.isCaptureOwnerStack = isCaptureOwnerStack;
exports.isCaptureOwnerStackCall = isCaptureOwnerStackCall;
exports.isChildrenCount = isChildrenCount;
exports.isChildrenCountCall = isChildrenCountCall;
exports.isChildrenForEach = isChildrenForEach;
exports.isChildrenForEachCall = isChildrenForEachCall;
exports.isChildrenMap = isChildrenMap;
exports.isChildrenMapCall = isChildrenMapCall;
exports.isChildrenOfCreateElement = isChildrenOfCreateElement;
exports.isChildrenOnly = isChildrenOnly;
exports.isChildrenOnlyCall = isChildrenOnlyCall;
exports.isChildrenToArray = isChildrenToArray;
exports.isChildrenToArrayCall = isChildrenToArrayCall;
exports.isClassComponent = isClassComponent;
exports.isCloneElement = isCloneElement;
exports.isCloneElementCall = isCloneElementCall;
exports.isComponentDidCatch = isComponentDidCatch;
exports.isComponentDidMount = isComponentDidMount;
exports.isComponentDidUpdate = isComponentDidUpdate;
exports.isComponentName = isComponentName;
exports.isComponentNameLoose = isComponentNameLoose;
exports.isComponentWillMount = isComponentWillMount;
exports.isComponentWillReceiveProps = isComponentWillReceiveProps;
exports.isComponentWillUnmount = isComponentWillUnmount;
exports.isComponentWillUpdate = isComponentWillUpdate;
exports.isComponentWrapperCall = isComponentWrapperCall;
exports.isComponentWrapperCallLoose = isComponentWrapperCallLoose;
exports.isCreateContext = isCreateContext;
exports.isCreateContextCall = isCreateContextCall;
exports.isCreateElement = isCreateElement;
exports.isCreateElementCall = isCreateElementCall;
exports.isCreateRef = isCreateRef;
exports.isCreateRefCall = isCreateRefCall;
exports.isDeclaredInRenderPropLoose = isDeclaredInRenderPropLoose;
exports.isDirectValueOfRenderPropertyLoose = isDirectValueOfRenderPropertyLoose;
exports.isForwardRef = isForwardRef;
exports.isForwardRefCall = isForwardRefCall;
exports.isFragmentElement = isFragmentElement;
exports.isFunctionOfComponentDidMount = isFunctionOfComponentDidMount;
exports.isFunctionOfComponentWillUnmount = isFunctionOfComponentWillUnmount;
exports.isFunctionOfRender = isFunctionOfRender;
exports.isFunctionOfRenderMethod = isFunctionOfRenderMethod;
exports.isFunctionOfUseEffectCleanup = isFunctionOfUseEffectCleanup;
exports.isFunctionOfUseEffectSetup = isFunctionOfUseEffectSetup;
exports.isGetChildContext = isGetChildContext;
exports.isGetDefaultProps = isGetDefaultProps;
exports.isGetDerivedStateFromError = isGetDerivedStateFromError;
exports.isGetDerivedStateFromProps = isGetDerivedStateFromProps;
exports.isGetInitialState = isGetInitialState;
exports.isGetSnapshotBeforeUpdate = isGetSnapshotBeforeUpdate;
exports.isHostElement = isHostElement;
exports.isInitializedFromReact = isInitializedFromReact;
exports.isInsideRenderMethod = isInsideRenderMethod;
exports.isInstanceIdEqual = isInstanceIdEqual;
exports.isInversePhase = isInversePhase;
exports.isJsxLike = isJsxLike;
exports.isJsxText = isJsxText;
exports.isKeyedElement = isKeyedElement;
exports.isLazy = isLazy;
exports.isLazyCall = isLazyCall;
exports.isMemo = isMemo;
exports.isMemoCall = isMemoCall;
exports.isPureComponent = isPureComponent;
exports.isReactAPI = isReactAPI;
exports.isReactAPICall = isReactAPICall;
exports.isReactHook = isReactHook;
exports.isReactHookCall = isReactHookCall;
exports.isReactHookCallWithName = isReactHookCallWithName;
exports.isReactHookCallWithNameAlias = isReactHookCallWithNameAlias;
exports.isReactHookCallWithNameLoose = isReactHookCallWithNameLoose;
exports.isReactHookName = isReactHookName;
exports.isRenderFunctionLoose = isRenderFunctionLoose;
exports.isRenderLike = isRenderLike;
exports.isRenderMethodLike = isRenderMethodLike;
exports.isRenderPropLoose = isRenderPropLoose;
exports.isShouldComponentUpdate = isShouldComponentUpdate;
exports.isThisSetState = isThisSetState;
exports.isUnsafeComponentWillMount = isUnsafeComponentWillMount;
exports.isUnsafeComponentWillReceiveProps = isUnsafeComponentWillReceiveProps;
exports.isUnsafeComponentWillUpdate = isUnsafeComponentWillUpdate;
exports.isUseActionStateCall = isUseActionStateCall;
exports.isUseCall = isUseCall;
exports.isUseCallbackCall = isUseCallbackCall;
exports.isUseContextCall = isUseContextCall;
exports.isUseDebugValueCall = isUseDebugValueCall;
exports.isUseDeferredValueCall = isUseDeferredValueCall;
exports.isUseEffectCall = isUseEffectCall;
exports.isUseEffectCallLoose = isUseEffectCallLoose;
exports.isUseFormStatusCall = isUseFormStatusCall;
exports.isUseIdCall = isUseIdCall;
exports.isUseImperativeHandleCall = isUseImperativeHandleCall;
exports.isUseInsertionEffectCall = isUseInsertionEffectCall;
exports.isUseLayoutEffectCall = isUseLayoutEffectCall;
exports.isUseMemoCall = isUseMemoCall;
exports.isUseOptimisticCall = isUseOptimisticCall;
exports.isUseReducerCall = isUseReducerCall;
exports.isUseRefCall = isUseRefCall;
exports.isUseStateCall = isUseStateCall;
exports.isUseSyncExternalStoreCall = isUseSyncExternalStoreCall;
exports.isUseTransitionCall = isUseTransitionCall;
exports.isValidComponentDefinition = isValidComponentDefinition;
exports.stringifyJsx = stringifyJsx;
exports.useComponentCollector = useComponentCollector;
exports.useComponentCollectorLegacy = useComponentCollectorLegacy;
exports.useHookCollector = useHookCollector;
