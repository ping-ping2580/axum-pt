import * as AST9 from '@eslint-react/ast';
import { flip, dual, constFalse, identity, constTrue, _ } from '@eslint-react/eff';
import { RegExp, Selector } from '@eslint-react/kit';
import { coerceSettings, DEFAULT_ESLINT_REACT_SETTINGS, getId } from '@eslint-react/shared';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import * as VAR3 from '@eslint-react/var';
import { isMatching, P, match } from 'ts-pattern';
import birecord from 'birecord';

// src/component/component-collector.ts
function getInstanceId(node, prev) {
  switch (true) {
    case (node.type === AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return node.id;
    case (node.type === AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return node.left;
    case (node.type === AST_NODE_TYPES.PropertyDefinition && node.value === prev):
      return node.key;
    case (node.type === AST_NODE_TYPES.BlockStatement || node.type === AST_NODE_TYPES.Program || node.parent === node):
      return _;
    default:
      return getInstanceId(node.parent, node);
  }
}
function getRequireExpressionArguments(node) {
  return match(node).with({ type: AST_NODE_TYPES.CallExpression, arguments: P.select(), callee: { type: AST_NODE_TYPES.Identifier, name: "require" } }, identity).with({ type: AST_NODE_TYPES.MemberExpression, object: P.select() }, getRequireExpressionArguments).otherwise(() => null);
}
function isInitializedFromReact(name, importSource, initialScope) {
  if (name.toLowerCase() === "react") return true;
  const latestDef = VAR3.findVariable(name, initialScope)?.defs.at(-1);
  if (latestDef == null) return false;
  const { node, parent } = latestDef;
  if (node.type === AST_NODE_TYPES.VariableDeclarator && node.init != null) {
    const { init } = node;
    if (init.type === AST_NODE_TYPES.MemberExpression && init.object.type === AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.object.name, importSource, initialScope);
    }
    if (init.type === AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.name, importSource, initialScope);
    }
    const args = getRequireExpressionArguments(init);
    const arg0 = args?.[0];
    if (arg0 == null || !AST9.isLiteral(arg0, "string")) {
      return false;
    }
    return arg0.value === importSource || arg0.value.startsWith(`${importSource}/`);
  }
  return parent?.type === AST_NODE_TYPES.ImportDeclaration && parent.source.value === importSource;
}
function isInstanceIdEqual(context, a, b) {
  return AST9.isNodeEqual(a, b) || VAR3.isNodeValueEqual(a, b, [
    context.sourceCode.getScope(a),
    context.sourceCode.getScope(b)
  ]);
}
function isReactAPI(api) {
  const func = (context, node) => {
    if (node == null) return false;
    const getText = (n) => context.sourceCode.getText(n);
    const name = AST9.toString(node, getText);
    if (name === api) return true;
    if (name.substring(name.indexOf(".") + 1) === api) return true;
    return false;
  };
  return dual(2, func);
}
function isReactAPICall(api) {
  const func = (context, node) => {
    if (node == null) return false;
    if (node.type !== AST_NODE_TYPES.CallExpression) return false;
    return isReactAPI(api)(context, node.callee);
  };
  return dual(2, func);
}
var isCaptureOwnerStack = isReactAPI("captureOwnerStack");
var isChildrenCount = isReactAPI("Children.count");
var isChildrenForEach = isReactAPI("Children.forEach");
var isChildrenMap = isReactAPI("Children.map");
var isChildrenOnly = isReactAPI("Children.only");
var isChildrenToArray = isReactAPI("Children.toArray");
var isCloneElement = isReactAPI("cloneElement");
var isCreateContext = isReactAPI("createContext");
var isCreateElement = isReactAPI("createElement");
var isCreateRef = isReactAPI("createRef");
var isForwardRef = isReactAPI("forwardRef");
var isMemo = isReactAPI("memo");
var isLazy = isReactAPI("lazy");
var isCaptureOwnerStackCall = isReactAPICall("captureOwnerStack");
var isChildrenCountCall = isReactAPICall("Children.count");
var isChildrenForEachCall = isReactAPICall("Children.forEach");
var isChildrenMapCall = isReactAPICall("Children.map");
var isChildrenOnlyCall = isReactAPICall("Children.only");
var isChildrenToArrayCall = isReactAPICall("Children.toArray");
var isCloneElementCall = isReactAPICall("cloneElement");
var isCreateContextCall = isReactAPICall("createContext");
var isCreateElementCall = isReactAPICall("createElement");
var isCreateRefCall = isReactAPICall("createRef");
var isForwardRefCall = isReactAPICall("forwardRef");
var isMemoCall = isReactAPICall("memo");
var isLazyCall = isReactAPICall("lazy");

// src/hook/hook-name.ts
function isReactHookName(name) {
  return name === "use" || /^use[A-Z0-9]/.test(name);
}

// src/hook/hook-is.ts
function isReactHook(node) {
  if (node == null) return false;
  const id = AST9.getFunctionId(node);
  return id?.name != null && isReactHookName(id.name);
}
function isReactHookCall(node) {
  if (node == null) return false;
  if (node.type !== AST_NODE_TYPES.CallExpression) {
    return false;
  }
  if (node.callee.type === AST_NODE_TYPES.Identifier) {
    return isReactHookName(node.callee.name);
  }
  if (node.callee.type === AST_NODE_TYPES.MemberExpression) {
    return node.callee.property.type === AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
  }
  return false;
}
function isReactHookCallWithName(context, node) {
  if (node == null || node.type !== AST_NODE_TYPES.CallExpression) return constFalse;
  const {
    importSource = DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = coerceSettings(context.settings);
  const initialScope = context.sourceCode.getScope(node);
  return (name) => {
    switch (true) {
      case (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameLoose(node) {
  if (node == null || node.type !== AST_NODE_TYPES.CallExpression) return constFalse;
  return (name) => {
    switch (node.callee.type) {
      case AST_NODE_TYPES.Identifier:
        return node.callee.name === name;
      case AST_NODE_TYPES.MemberExpression:
        return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name;
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameAlias(context, name, alias = []) {
  const {
    importSource = DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = coerceSettings(context.settings);
  return (node) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return alias.some(isReactHookCallWithNameLoose(node));
    }
  };
}
function isUseEffectCallLoose(node) {
  if (node == null) return false;
  if (node.type !== AST_NODE_TYPES.CallExpression) {
    return false;
  }
  switch (node.callee.type) {
    case AST_NODE_TYPES.Identifier:
      return /^use\w*Effect$/u.test(node.callee.name);
    case AST_NODE_TYPES.MemberExpression:
      return node.callee.property.type === AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
    default:
      return false;
  }
}
var isUseCall = flip(isReactHookCallWithName)("use");
var isUseActionStateCall = flip(isReactHookCallWithName)("useActionState");
var isUseCallbackCall = flip(isReactHookCallWithName)("useCallback");
var isUseContextCall = flip(isReactHookCallWithName)("useContext");
var isUseDebugValueCall = flip(isReactHookCallWithName)("useDebugValue");
var isUseDeferredValueCall = flip(isReactHookCallWithName)("useDeferredValue");
var isUseEffectCall = flip(isReactHookCallWithName)("useEffect");
var isUseFormStatusCall = flip(isReactHookCallWithName)("useFormStatus");
var isUseIdCall = flip(isReactHookCallWithName)("useId");
var isUseImperativeHandleCall = flip(isReactHookCallWithName)("useImperativeHandle");
var isUseInsertionEffectCall = flip(isReactHookCallWithName)("useInsertionEffect");
var isUseLayoutEffectCall = flip(isReactHookCallWithName)("useLayoutEffect");
var isUseMemoCall = flip(isReactHookCallWithName)("useMemo");
var isUseOptimisticCall = flip(isReactHookCallWithName)("useOptimistic");
var isUseReducerCall = flip(isReactHookCallWithName)("useReducer");
var isUseRefCall = flip(isReactHookCallWithName)("useRef");
var isUseStateCall = flip(isReactHookCallWithName)("useState");
var isUseSyncExternalStoreCall = flip(isReactHookCallWithName)("useSyncExternalStore");
var isUseTransitionCall = flip(isReactHookCallWithName)("useTransition");

// src/hook/hook-collector.ts
function useHookCollector() {
  const hooks = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const onFunctionEnter = (node) => {
    const id = AST9.getFunctionId(node);
    const key = getId();
    const name = id?.name;
    if (name != null && isReactHookName(name)) {
      functionEntries.push({ key, node, isHook: true });
      hooks.set(key, {
        id,
        key,
        kind: "function",
        name,
        node,
        flag: 0n,
        hint: 0n,
        hookCalls: []
      });
      return;
    }
    functionEntries.push({ key, node, isHook: false });
  };
  const onFunctionExit = () => {
    functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllHooks(node) {
      return hooks;
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "CallExpression[type]"(node) {
      if (!isReactHookCall(node)) {
        return;
      }
      const fEntry = functionEntries.at(-1);
      if (fEntry?.key == null) {
        return;
      }
      const hook = hooks.get(fEntry.key);
      if (hook == null) {
        return;
      }
      hook.hookCalls.push(node);
    }
  };
  return { ctx, listeners };
}
function isFunctionOfUseEffectSetup(node) {
  if (node == null) return false;
  return node.parent?.type === AST_NODE_TYPES.CallExpression && node.parent.callee !== node && node.parent.callee.type === AST_NODE_TYPES.Identifier && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isFunctionOfUseEffectCleanup(node) {
  if (node == null) return false;
  const pReturn = AST9.findParentNode(node, AST9.is(AST_NODE_TYPES.ReturnStatement));
  const pFunction = AST9.findParentNode(node, AST9.isFunction);
  const pFunctionOfReturn = AST9.findParentNode(pReturn, AST9.isFunction);
  if (pFunction !== pFunctionOfReturn) return false;
  return isFunctionOfUseEffectSetup(pFunction);
}
function stringifyJsx(node) {
  switch (node.type) {
    case AST_NODE_TYPES.JSXIdentifier:
      return node.name;
    case AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case AST_NODE_TYPES.JSXMemberExpression:
      return `${stringifyJsx(node.object)}.${stringifyJsx(node.property)}`;
    case AST_NODE_TYPES.JSXText:
      return node.value;
    case AST_NODE_TYPES.JSXOpeningElement:
      return `<${stringifyJsx(node.name)}>`;
    case AST_NODE_TYPES.JSXClosingElement:
      return `</${stringifyJsx(node.name)}>`;
    case AST_NODE_TYPES.JSXOpeningFragment:
      return "<>";
    case AST_NODE_TYPES.JSXClosingFragment:
      return "</>";
  }
}

// src/jsx/jsx-attribute-name.ts
function getAttributeName(context, node) {
  return stringifyJsx(node.name);
}

// src/jsx/jsx-attribute.ts
function getAttribute(context, name, attributes, initialScope) {
  return attributes.findLast((attr) => {
    if (attr.type === AST_NODE_TYPES.JSXAttribute) {
      return getAttributeName(context, attr) === name;
    }
    if (initialScope == null) return false;
    switch (attr.argument.type) {
      case AST_NODE_TYPES.Identifier: {
        const variable = VAR3.findVariable(attr.argument.name, initialScope);
        const variableNode = VAR3.getVariableInitNode(variable, 0);
        if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) {
          return VAR3.findPropertyInProperties(name, variableNode.properties, initialScope) != null;
        }
        return false;
      }
      case AST_NODE_TYPES.ObjectExpression:
        return VAR3.findPropertyInProperties(name, attr.argument.properties, initialScope) != null;
    }
    return false;
  });
}
function getAttributeValue(context, node, name) {
  const initialScope = context.sourceCode.getScope(node);
  switch (node.type) {
    case AST_NODE_TYPES.JSXAttribute:
      if (node.value?.type === AST_NODE_TYPES.Literal) {
        return {
          kind: "some",
          node: node.value,
          initialScope,
          value: node.value.value
        };
      }
      if (node.value?.type === AST_NODE_TYPES.JSXExpressionContainer) {
        return VAR3.toStaticValue({
          kind: "lazy",
          node: node.value.expression,
          initialScope
        });
      }
      return { kind: "none", node, initialScope };
    case AST_NODE_TYPES.JSXSpreadAttribute: {
      const staticValue = VAR3.toStaticValue({
        kind: "lazy",
        node: node.argument,
        initialScope
      });
      if (staticValue.kind === "none") {
        return staticValue;
      }
      return match(staticValue.value).with({ [name]: P.select(P.any) }, (value) => ({
        kind: "some",
        node: node.argument,
        initialScope,
        value
      })).otherwise(() => ({ kind: "none", node, initialScope }));
    }
    default:
      return { kind: "none", node, initialScope };
  }
}

// src/jsx/jsx-detection-hint.ts
var JSXDetectionHint = {
  None: 0n,
  SkipUndefined: 1n << 0n,
  SkipNullLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipBigIntLiteral: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  SkipCreateElement: 1n << 7n,
  StrictArray: 1n << 8n,
  StrictLogical: 1n << 9n,
  StrictConditional: 1n << 10n
};
var DEFAULT_JSX_DETECTION_HINT = 0n | JSXDetectionHint.SkipUndefined | JSXDetectionHint.SkipBooleanLiteral;

// src/jsx/jsx-detection.ts
function isJsxText(node) {
  if (node == null) return false;
  return node.type === AST_NODE_TYPES.JSXText || node.type === AST_NODE_TYPES.Literal;
}
function isJsxLike(code, node, hint = DEFAULT_JSX_DETECTION_HINT) {
  if (node == null) return false;
  if (AST9.isJSX(node)) return true;
  switch (node.type) {
    case AST_NODE_TYPES.Literal: {
      switch (typeof node.value) {
        case "boolean":
          return !(hint & JSXDetectionHint.SkipBooleanLiteral);
        case "string":
          return !(hint & JSXDetectionHint.SkipStringLiteral);
        case "number":
          return !(hint & JSXDetectionHint.SkipNumberLiteral);
        case "bigint":
          return !(hint & JSXDetectionHint.SkipBigIntLiteral);
      }
      if (node.value == null) {
        return !(hint & JSXDetectionHint.SkipNullLiteral);
      }
      return false;
    }
    case AST_NODE_TYPES.TemplateLiteral: {
      return !(hint & JSXDetectionHint.SkipStringLiteral);
    }
    case AST_NODE_TYPES.ArrayExpression: {
      if (hint & JSXDetectionHint.StrictArray) {
        return node.elements.every((n) => isJsxLike(code, n, hint));
      }
      return node.elements.some((n) => isJsxLike(code, n, hint));
    }
    case AST_NODE_TYPES.LogicalExpression: {
      if (hint & JSXDetectionHint.StrictLogical) {
        return isJsxLike(code, node.left, hint) && isJsxLike(code, node.right, hint);
      }
      return isJsxLike(code, node.left, hint) || isJsxLike(code, node.right, hint);
    }
    case AST_NODE_TYPES.ConditionalExpression: {
      let leftHasJSX2 = function(node2) {
        if (Array.isArray(node2.consequent)) {
          if (node2.consequent.length === 0) {
            return !(hint & JSXDetectionHint.SkipEmptyArray);
          }
          if (hint & JSXDetectionHint.StrictArray) {
            return node2.consequent.every((n) => isJsxLike(code, n, hint));
          }
          return node2.consequent.some((n) => isJsxLike(code, n, hint));
        }
        return isJsxLike(code, node2.consequent, hint);
      }, rightHasJSX2 = function(node2) {
        return isJsxLike(code, node2.alternate, hint);
      };
      if (hint & JSXDetectionHint.StrictConditional) {
        return leftHasJSX2(node) && rightHasJSX2(node);
      }
      return leftHasJSX2(node) || rightHasJSX2(node);
    }
    case AST_NODE_TYPES.SequenceExpression: {
      const exp = node.expressions.at(-1);
      return isJsxLike(code, exp, hint);
    }
    case AST_NODE_TYPES.CallExpression: {
      if (hint & JSXDetectionHint.SkipCreateElement) {
        return false;
      }
      switch (node.callee.type) {
        case AST_NODE_TYPES.Identifier:
          return node.callee.name === "createElement";
        case AST_NODE_TYPES.MemberExpression:
          return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
      }
      return false;
    }
    case AST_NODE_TYPES.Identifier: {
      const { name } = node;
      if (name === "undefined") {
        return !(hint & JSXDetectionHint.SkipUndefined);
      }
      if (AST9.isJSXTagNameExpression(node)) {
        return true;
      }
      const variable = VAR3.findVariable(name, code.getScope(node));
      const variableNode = variable && VAR3.getVariableInitNode(variable, 0);
      return !!variableNode && isJsxLike(code, variableNode, hint);
    }
  }
  return false;
}
function getElementType(context, node) {
  if (node.type === AST_NODE_TYPES.JSXFragment) {
    return "";
  }
  return stringifyJsx(node.openingElement.name);
}

// src/jsx/jsx-has.ts
function hasAttribute(context, name, attributes, initialScope) {
  return getAttribute(context, name, attributes, initialScope) != null;
}
function hasAnyAttribute(context, names, attributes, initialScope) {
  return names.some((n) => hasAttribute(context, n, attributes, initialScope));
}
function hasEveryAttribute(context, names, attributes, initialScope) {
  return names.every((n) => hasAttribute(context, n, attributes, initialScope));
}
function findParentAttribute(node, test = constTrue) {
  const guard = (node2) => {
    return node2.type === AST_NODE_TYPES.JSXAttribute && test(node2);
  };
  return AST9.findParentNode(node, guard);
}
function isHostElement(context, node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && /^[a-z]/u.test(node.openingElement.name.name);
}
function isKeyedElement(context, node, initialScope) {
  return node.type === AST_NODE_TYPES.JSXElement && hasAttribute(context, "key", node.openingElement.attributes, initialScope);
}
function isFragmentElement(context, node, allowJSXFragment = false) {
  if (node == null) return false;
  if (node.type !== AST_NODE_TYPES.JSXElement && node.type !== AST_NODE_TYPES.JSXFragment) return false;
  if (node.type === AST_NODE_TYPES.JSXFragment) return allowJSXFragment;
  return getElementType(context, node).split(".").at(-1) === "Fragment";
}

// src/component/component-detection-hint.ts
var ComponentDetectionHint = {
  /**
   * 1n << 0n - 1n << 63n are reserved for JSXDetectionHint
   */
  ...JSXDetectionHint,
  /**
   * Skip function component created by React.memo
   */
  SkipMemo: 1n << 64n,
  /**
   * Skip function component created by React.forwardRef
   */
  SkipForwardRef: 1n << 65n,
  /**
   * Skip function component defined as array map argument
   */
  SkipArrayMapArgument: 1n << 66n,
  /**
   * Skip function component defined on object method
   */
  SkipObjectMethod: 1n << 67n,
  /**
   * Skip function component defined on class method
   */
  SkipClassMethod: 1n << 68n,
  /**
   * Skip function component defined on class property
   */
  SkipClassProperty: 1n << 69n
};
var DEFAULT_COMPONENT_DETECTION_HINT = 0n | ComponentDetectionHint.SkipBooleanLiteral | ComponentDetectionHint.SkipEmptyArray | ComponentDetectionHint.SkipArrayMapArgument | ComponentDetectionHint.SkipNumberLiteral | ComponentDetectionHint.SkipStringLiteral | ComponentDetectionHint.SkipUndefined | ComponentDetectionHint.StrictArray | ComponentDetectionHint.StrictConditional | ComponentDetectionHint.StrictLogical;
function isClassComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^(?:Pure)?Component$/u;
    switch (true) {
      case node.superClass.type === AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === AST_NODE_TYPES.MemberExpression && node.superClass.property.type === AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}
function isPureComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^PureComponent$/u;
    switch (true) {
      case node.superClass.type === AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === AST_NODE_TYPES.MemberExpression && node.superClass.property.type === AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}
function isComponentDidCatch(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidCatch";
}
function isComponentDidMount(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentDidUpdate(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
function isComponentWillMount(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
function isComponentWillReceiveProps(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
function isComponentWillUnmount(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentWillUpdate(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
function isGetChildContext(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getChildContext";
}
function isGetDefaultProps(node) {
  return AST9.isMethodOrProperty(node) && node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getDefaultProps";
}
function isGetInitialState(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getInitialState";
}
function isGetSnapshotBeforeUpdate(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getSnapshotBeforeUpdate";
}
function isShouldComponentUpdate(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
function isUnsafeComponentWillMount(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
function isUnsafeComponentWillReceiveProps(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
function isUnsafeComponentWillUpdate(node) {
  return AST9.isMethodOrProperty(node) && !node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
function isGetDerivedStateFromProps(node) {
  return AST9.isMethodOrProperty(node) && node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromProps";
}
function isGetDerivedStateFromError(node) {
  return AST9.isMethodOrProperty(node) && node.static && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromError";
}
function isRenderLike(node) {
  return AST9.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "render" && node.parent.parent.type === AST_NODE_TYPES.ClassDeclaration;
}
function isFunctionOfRender(node) {
  if (!isRenderLike(node.parent)) {
    return false;
  }
  return isClassComponent(node.parent.parent.parent);
}
function isRenderMethodLike(node) {
  return AST9.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name.startsWith("render") && node.parent.parent.type === AST_NODE_TYPES.ClassDeclaration;
}

// src/component/component-hierarchy.ts
function isChildrenOfCreateElement(context, node) {
  const parent = node.parent;
  if (parent == null || parent.type !== AST_NODE_TYPES.CallExpression) return false;
  if (!isCreateElementCall(context, parent)) return false;
  return parent.arguments.slice(2).some((arg) => arg === node);
}
function isInsideRenderMethod(node) {
  return AST9.findParentNode(node, (n) => isRenderLike(n) && isClassComponent(n.parent.parent)) != null;
}
function isFunctionOfComponentDidMount(node) {
  return AST9.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isFunctionOfComponentWillUnmount(node) {
  return AST9.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
function isFunctionOfRenderMethod(node) {
  if (!isRenderMethodLike(node.parent)) {
    return false;
  }
  return isClassComponent(node.parent.parent.parent);
}

// src/component/component-definition.ts
var isFunctionOfClassMethod = isMatching({
  type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
  parent: AST_NODE_TYPES.MethodDefinition
});
var isFunctionOfClassProperty = isMatching({
  type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
  parent: AST_NODE_TYPES.Property
});
var isFunctionOfObjectMethod = isMatching({
  type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
  parent: {
    type: AST_NODE_TYPES.Property,
    parent: {
      type: AST_NODE_TYPES.ObjectExpression
    }
  }
});
function isValidComponentDefinition(context, node, hint) {
  if (isChildrenOfCreateElement(context, node) || isFunctionOfRenderMethod(node)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipObjectMethod && isFunctionOfObjectMethod(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipClassMethod && isFunctionOfClassMethod(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipClassProperty && isFunctionOfClassProperty(node.parent)) {
    return false;
  }
  if (hint & ComponentDetectionHint.SkipArrayMapArgument && AST9.isArrayMapCall(node.parent)) {
    return false;
  }
  const significantParent = AST9.findParentNode(
    node,
    AST9.isOneOf([
      AST_NODE_TYPES.JSXExpressionContainer,
      AST_NODE_TYPES.ArrowFunctionExpression,
      AST_NODE_TYPES.FunctionExpression,
      AST_NODE_TYPES.Property,
      AST_NODE_TYPES.ClassBody
    ])
  );
  return significantParent == null || significantParent.type !== AST_NODE_TYPES.JSXExpressionContainer;
}
function isComponentWrapperCall(context, node) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  return isMemoCall(context, node) || isForwardRefCall(context, node);
}
function isComponentWrapperCallLoose(context, node) {
  if (node.type !== AST_NODE_TYPES.CallExpression) return false;
  return isComponentWrapperCall(context, node) || isUseCallbackCall(context, node);
}

// src/component/component-id.ts
function getFunctionComponentId(context, node) {
  const functionId = AST9.getFunctionId(node);
  if (functionId != null) {
    return functionId;
  }
  const { parent } = node;
  if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === AST_NODE_TYPES.Identifier) {
    return parent.parent.id;
  }
  if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent.parent) && parent.parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === AST_NODE_TYPES.Identifier) {
    return parent.parent.parent.id;
  }
  return _;
}

// src/component/component-flag.ts
var ComponentFlag = {
  None: 0n,
  PureComponent: 1n << 0n,
  CreateElement: 1n << 1n,
  Memo: 1n << 2n,
  ForwardRef: 1n << 3n,
  Async: 1n << 4n
};

// src/component/component-init-path.ts
function getComponentFlagFromInitPath(initPath) {
  let flag = ComponentFlag.None;
  if (initPath != null && AST9.hasCallInFunctionInitPath("memo", initPath)) {
    flag |= ComponentFlag.Memo;
  }
  if (initPath != null && AST9.hasCallInFunctionInitPath("forwardRef", initPath)) {
    flag |= ComponentFlag.ForwardRef;
  }
  return flag;
}
function isComponentName(name) {
  return RegExp.COMPONENT_NAME.test(name);
}
function isComponentNameLoose(name) {
  return RegExp.COMPONENT_NAME_LOOSE.test(name);
}
function getComponentNameFromId(id) {
  if (id == null) return _;
  return Array.isArray(id) ? id.map((n) => n.name).join(".") : id.name;
}
function hasNoneOrLooseComponentName(context, fn) {
  const id = getFunctionComponentId(context, fn);
  if (id == null) return true;
  const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
  return name != null && isComponentNameLoose(name);
}

// src/component/component-collector.ts
function useComponentCollector(context, options = {}) {
  const {
    collectDisplayName = false,
    collectHookCalls = false,
    hint = DEFAULT_COMPONENT_DETECTION_HINT
  } = options;
  const components = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const getCurrentEntry = () => functionEntries.at(-1);
  const onFunctionEnter = (node) => {
    const key = getId();
    functionEntries.push({ key, node, hookCalls: [], isComponent: false });
  };
  const onFunctionExit = () => {
    const entry = functionEntries.at(-1);
    if (entry == null) return;
    if (!entry.isComponent) return functionEntries.pop();
    const shouldDrop = AST9.getNestedReturnStatements(entry.node.body).slice().reverse().some((r) => {
      return context.sourceCode.getScope(r).block === entry.node && r.argument != null && !isJsxLike(context.sourceCode, r.argument, hint);
    });
    if (shouldDrop) {
      components.delete(entry.key);
    }
    return functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    },
    getCurrentEntries() {
      return [...functionEntries];
    },
    getCurrentEntry
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "ArrowFunctionExpression[body.type!='BlockStatement']"() {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const { body } = entry.node;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, body, hint) && isValidComponentDefinition(context, entry.node, hint);
      if (!isComponent) return;
      const initPath = AST9.getFunctionInitPath(entry.node);
      const id = getFunctionComponentId(context, entry.node);
      const name = getComponentNameFromId(id);
      const key = getId();
      components.set(key, {
        id,
        key,
        kind: "function",
        name,
        node: entry.node,
        displayName: _,
        flag: getComponentFlagFromInitPath(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    },
    ...collectDisplayName ? {
      [Selector.DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
        const { left, right } = node;
        if (left.type !== AST_NODE_TYPES.MemberExpression) return;
        const componentName = left.object.type === AST_NODE_TYPES.Identifier ? left.object.name : _;
        const component = [...components.values()].findLast(({ name }) => name != null && name === componentName);
        if (component == null) return;
        component.displayName = right;
      }
    } : {},
    ...collectHookCalls ? {
      "CallExpression[type]:exit"(node) {
        if (!isReactHookCall(node)) return;
        const entry = getCurrentEntry();
        if (entry == null) return;
        entry.hookCalls.push(node);
      }
    } : {},
    "ReturnStatement[type]"(node) {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, node.argument, hint) && isValidComponentDefinition(context, entry.node, hint);
      if (!isComponent) return;
      entry.isComponent = true;
      const initPath = AST9.getFunctionInitPath(entry.node);
      const id = getFunctionComponentId(context, entry.node);
      const name = getComponentNameFromId(id);
      components.set(entry.key, {
        id,
        key: entry.key,
        kind: "function",
        name,
        node: entry.node,
        displayName: _,
        flag: getComponentFlagFromInitPath(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    }
  };
  return { ctx, listeners };
}
function useComponentCollectorLegacy() {
  const components = /* @__PURE__ */ new Map();
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    }
  };
  const collect = (node) => {
    if (!isClassComponent(node)) {
      return;
    }
    const id = AST9.getClassId(node);
    const key = getId();
    const flag = isPureComponent(node) ? ComponentFlag.PureComponent : ComponentFlag.None;
    components.set(
      key,
      {
        id,
        key,
        kind: "class",
        name: id?.name,
        node,
        // TODO: Get displayName of class component
        displayName: _,
        flag,
        hint: 0n,
        // TODO: Get methods of class component
        methods: []
      }
    );
  };
  const listeners = {
    "ClassDeclaration[type]": collect,
    "ClassExpression[type]": collect
  };
  return { ctx, listeners };
}
var ComponentPhaseRelevance = birecord({
  mount: "unmount",
  setup: "cleanup"
});
var isInversePhase = dual(2, (a, b) => ComponentPhaseRelevance.get(a) === b);
function isRenderFunctionLoose(context, node) {
  const { body, parent } = node;
  if (AST9.getFunctionId(node)?.name.startsWith("render")) {
    return parent.type === AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
  }
  return isJsxLike(
    context.sourceCode,
    body,
    JSXDetectionHint.SkipNullLiteral | JSXDetectionHint.SkipUndefined | JSXDetectionHint.StrictLogical | JSXDetectionHint.StrictConditional
  );
}
function isRenderPropLoose(context, node) {
  if (node.name.type !== AST_NODE_TYPES.JSXIdentifier) {
    return false;
  }
  return node.name.name.startsWith("render") && node.value?.type === AST_NODE_TYPES.JSXExpressionContainer && AST9.isFunction(node.value.expression) && isRenderFunctionLoose(context, node.value.expression);
}
function isDirectValueOfRenderPropertyLoose(node) {
  const matching = (node2) => {
    return node2.type === AST_NODE_TYPES.Property && node2.key.type === AST_NODE_TYPES.Identifier && node2.key.name.startsWith("render");
  };
  return matching(node) || node.parent != null && matching(node.parent);
}
function isDeclaredInRenderPropLoose(node) {
  if (isDirectValueOfRenderPropertyLoose(node)) {
    return true;
  }
  const parent = AST9.findParentNode(node, AST9.is(AST_NODE_TYPES.JSXExpressionContainer))?.parent;
  if (parent?.type !== AST_NODE_TYPES.JSXAttribute) {
    return false;
  }
  return parent.name.type === AST_NODE_TYPES.JSXIdentifier && parent.name.name.startsWith("render");
}
function isThisSetState(node) {
  const { callee } = node;
  return callee.type === AST_NODE_TYPES.MemberExpression && AST9.isThisExpression(callee.object) && callee.property.type === AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}
function isAssignmentToThisState(node) {
  const { left } = node;
  return left.type === AST_NODE_TYPES.MemberExpression && AST9.isThisExpression(left.object) && AST9.getPropertyName(left.property) === "state";
}

export { ComponentDetectionHint, ComponentFlag, ComponentPhaseRelevance, DEFAULT_COMPONENT_DETECTION_HINT, DEFAULT_JSX_DETECTION_HINT, JSXDetectionHint, findParentAttribute, getAttribute, getAttributeName, getAttributeValue, getComponentFlagFromInitPath, getComponentNameFromId, getElementType, getFunctionComponentId, getInstanceId, hasAnyAttribute, hasAttribute, hasEveryAttribute, hasNoneOrLooseComponentName, isAssignmentToThisState, isCaptureOwnerStack, isCaptureOwnerStackCall, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentName, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUnmount, isComponentWillUpdate, isComponentWrapperCall, isComponentWrapperCallLoose, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRender, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetChildContext, isGetDefaultProps, isGetDerivedStateFromError, isGetDerivedStateFromProps, isGetInitialState, isGetSnapshotBeforeUpdate, isHostElement, isInitializedFromReact, isInsideRenderMethod, isInstanceIdEqual, isInversePhase, isJsxLike, isJsxText, isKeyedElement, isLazy, isLazyCall, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderLike, isRenderMethodLike, isRenderPropLoose, isShouldComponentUpdate, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseActionStateCall, isUseCall, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseFormStatusCall, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseOptimisticCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, isValidComponentDefinition, stringifyJsx, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
