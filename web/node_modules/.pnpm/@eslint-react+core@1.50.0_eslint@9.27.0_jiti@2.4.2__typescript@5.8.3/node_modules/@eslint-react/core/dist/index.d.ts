import { TSESTree } from '@typescript-eslint/types';
import { ESLintUtils, TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as AST from '@eslint-react/ast';
import { _ } from '@eslint-react/eff';
import { RuleContext } from '@eslint-react/kit';
import * as birecord from 'birecord';
import { Scope } from '@typescript-eslint/scope-manager';
import * as VAR from '@eslint-react/var';

type ComponentDetectionHint = bigint;
/**
 * Hints for component collector
 */
declare const ComponentDetectionHint: {
    /**
     * Skip function component created by React.memo
     */
    readonly SkipMemo: bigint;
    /**
     * Skip function component created by React.forwardRef
     */
    readonly SkipForwardRef: bigint;
    /**
     * Skip function component defined as array map argument
     */
    readonly SkipArrayMapArgument: bigint;
    /**
     * Skip function component defined on object method
     */
    readonly SkipObjectMethod: bigint;
    /**
     * Skip function component defined on class method
     */
    readonly SkipClassMethod: bigint;
    /**
     * Skip function component defined on class property
     */
    readonly SkipClassProperty: bigint;
    readonly None: 0n;
    readonly SkipUndefined: bigint;
    readonly SkipNullLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipBigIntLiteral: bigint;
    readonly SkipEmptyArray: bigint;
    readonly SkipCreateElement: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
/**
 * Default component detection hint
 */
declare const DEFAULT_COMPONENT_DETECTION_HINT: bigint;

type ComponentEffectPhaseKind = "cleanup" | "setup";
type ComponentLifecyclePhaseKind = "mount" | "unmount";
type ComponentPhaseKind = ComponentEffectPhaseKind | ComponentLifecyclePhaseKind;
declare const ComponentPhaseRelevance: birecord.BiRecord<{
    readonly mount: "unmount";
    readonly setup: "cleanup";
}>;
declare const isInversePhase: {
    (a: ComponentPhaseKind): (b: ComponentPhaseKind) => boolean;
    (a: ComponentPhaseKind, b: ComponentPhaseKind): boolean;
};

interface SemanticEntry {
    node: TSESTree.Node;
    phase: ComponentPhaseKind;
}

interface SemanticNode {
    id: _ | TSESTree.Identifier | TSESTree.Identifier[];
    key: string;
    kind: string;
    name: _ | string;
    node: TSESTree.Node;
    flag: bigint;
    hint: bigint;
}

type ComponentFlag = bigint;
declare const ComponentFlag: {
    None: bigint;
    PureComponent: bigint;
    CreateElement: bigint;
    Memo: bigint;
    ForwardRef: bigint;
    Async: bigint;
};

interface FunctionComponent extends SemanticNode {
    id: _ | TSESTree.Identifier | TSESTree.Identifier[];
    kind: "function";
    node: AST.TSESTreeFunction;
    flag: ComponentFlag;
    hint: ComponentDetectionHint;
    initPath: _ | AST.FunctionInitPath;
    hookCalls: TSESTree.CallExpression[];
    displayName: _ | TSESTree.Expression;
}
interface ClassComponent extends SemanticNode {
    id: _ | TSESTree.Identifier;
    kind: "class";
    node: AST.TSESTreeClass;
    flag: ComponentFlag;
    hint: ComponentDetectionHint;
    methods: AST.TSESTreeMethodOrProperty[];
    displayName: _ | TSESTree.Expression;
}
type Component = ClassComponent | FunctionComponent;

type FunctionEntry = {
    key: string;
    node: AST.TSESTreeFunction;
    hookCalls: TSESTree.CallExpression[];
    isComponent: boolean;
};
declare namespace useComponentCollector {
    type Options = {
        collectDisplayName?: boolean;
        collectHookCalls?: boolean;
        hint?: ComponentDetectionHint;
    };
    type ReturnType = {
        ctx: {
            getAllComponents: (node: TSESTree.Program) => Map<string, FunctionComponent>;
            getCurrentEntries: () => FunctionEntry[];
            getCurrentEntry: () => FunctionEntry | _;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
/**
 * Get a ctx and listeners for the rule to collect function components
 * @param context The ESLint rule context
 * @param options The options to use
 * @returns The component collector
 */
declare function useComponentCollector(context: RuleContext, options?: useComponentCollector.Options): useComponentCollector.ReturnType;

declare namespace useComponentCollectorLegacy {
    type ReturnType = {
        ctx: {
            getAllComponents: (node: TSESTree$1.Program) => Map<string, ClassComponent>;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
/**
 * Get a ctx and listeners object for the rule to collect class components
 * @returns The context and listeners for the rule
 */
declare function useComponentCollectorLegacy(): useComponentCollectorLegacy.ReturnType;

declare function isValidComponentDefinition(context: RuleContext, node: AST.TSESTreeFunction, hint: bigint): boolean;

/**
 * Determines whether inside `createElement`'s children.
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if the node is inside createElement's children
 */
declare function isChildrenOfCreateElement(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Check whether given node is declared inside class component's render block
 * ```tsx
 * class Component extends React.Component {
 *   render() {
 *     class NestedClassComponent extends React.Component {
 *      render() { return <div />; }
 *     }
 *     const nestedFunctionComponent = () => <div />;
 *  }
 * }
 * ```
 * @param node The AST node being checked
 * @returns `true` if node is inside class component's render block, `false` if not
 */
declare function isInsideRenderMethod(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentDidMount(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentWillUnmount(node: TSESTree.Node): boolean;
/**
 * Check whether given node is a function of a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;

declare function getFunctionComponentId(context: RuleContext, node: AST.TSESTreeFunction): TSESTree.Identifier | TSESTree.Identifier[] | _;

declare function getComponentFlagFromInitPath(initPath: FunctionComponent["initPath"]): bigint;

/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree.Node): boolean;

type ComponentKind = "classComponent" | "functionComponent";

declare function isComponentDidCatch(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentDidMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentDidUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillReceiveProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillUnmount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetChildContext(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDefaultProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetInitialState(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetSnapshotBeforeUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isShouldComponentUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillReceiveProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isUnsafeComponentWillUpdate(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromError(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;

declare function isComponentName(name: string): boolean;
declare function isComponentNameLoose(name: string): boolean;
declare function getComponentNameFromId(id: TSESTree.Identifier | TSESTree.Identifier[] | _): string | undefined;
declare function hasNoneOrLooseComponentName(context: RuleContext, fn: AST.TSESTreeFunction): boolean;

/**
 * Check whether given node is a render function of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   render() {
 *    return <div />;
 *  }
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
/**
 * Check whether given node is a function of a render function of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   render = () => <div />;
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isFunctionOfRender(node: AST.TSESTreeFunction): boolean;

/**
 * Check whether given node is a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderMethodLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;

/**
 * Unsafe check whether given node is a render function
 * ```tsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(context: RuleContext, node: AST.TSESTreeFunction): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```tsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(context: RuleContext, node: TSESTree.JSXAttribute): boolean;
/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```tsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```tsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;

type ComponentStateKind = "actionState" | "state";
declare function isThisSetState(node: TSESTree.CallExpression): boolean;
declare function isAssignmentToThisState(node: TSESTree.AssignmentExpression): boolean;

/**
 * Check if the node is a call expression for a component wrapper
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper
 */
declare function isComponentWrapperCall(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Check if the node is a call expression for a component wrapper loosely
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper loosely
 */
declare function isComponentWrapperCallLoose(context: RuleContext, node: TSESTree.Node): boolean;

type EffectKind = "useEffect" | "useLayoutEffect" | "useInsertionEffect";

interface Hook extends SemanticNode {
    id: TSESTree.Identifier | _;
    node: AST.TSESTreeFunction;
    name: string;
    hookCalls: TSESTree.CallExpression[];
}

declare namespace useHookCollector {
    type ReturnType = {
        ctx: {
            getAllHooks(node: TSESTree$1.Program): Map<string, Hook>;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
declare function useHookCollector(): useHookCollector.ReturnType;

declare function isFunctionOfUseEffectSetup(node: TSESTree.Node | _): boolean;
declare function isFunctionOfUseEffectCleanup(node: TSESTree.Node | _): boolean;

declare function isReactHook(node: AST.TSESTreeFunction | _): boolean;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.Node | _): boolean;
declare function isReactHookCallWithName(context: RuleContext, node: TSESTree.Node | _): (name: string) => boolean;
declare function isReactHookCallWithNameLoose(node: TSESTree.Node | _): (name: string) => boolean;
declare function isReactHookCallWithNameAlias(context: RuleContext, name: string, alias?: _ | string[]): (node: TSESTree.CallExpression) => boolean;
declare function isUseEffectCallLoose(node: TSESTree.Node | _): boolean;
declare const isUseCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseActionStateCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseCallbackCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseContextCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseDebugValueCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseDeferredValueCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseFormStatusCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseIdCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseImperativeHandleCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseInsertionEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseLayoutEffectCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseMemoCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseOptimisticCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseReducerCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseRefCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseStateCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseSyncExternalStoreCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;
declare const isUseTransitionCall: (context: RuleContext, node: TSESTree.Node | undefined) => boolean;

type HookKind = "custom" | "useActionState" | "useCallback" | "useContext" | "useDebugValue" | "useDeferredValue" | "useEffect" | "useId" | "useImperativeHandle" | "useInsertionEffect" | "useLayoutEffect" | "useMemo" | "useOptimistic" | "useReducer" | "useRef" | "useState" | "useSyncExternalStore" | "useTransition";

/**
 * Catch all identifiers that begin with "use" followed by an uppercase Latin
 * character to exclude identifiers like "user".
 * @param name The name of the identifier to check.
 * @see https://github.com/facebook/react/blob/1d6c8168db1d82713202e842df3167787ffa00ed/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts#L16
 */
declare function isReactHookName(name: string): boolean;

/**
 * Get the JSX attribute node with the given name
 * @param context The ESLint rule context
 * @param name The name of the attribute
 * @param attributes The attributes to search
 * @param initialScope The initial scope to use for variable resolution
 * @returns The JSX attribute node or undefined
 */
declare function getAttribute(context: RuleContext, name: string, attributes: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], initialScope?: Scope): TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute | _;

/**
 * Get the stringified name of a JSX attribute
 * @param context The ESLint rule context
 * @param node The JSX attribute node
 * @returns The name of the attribute
 */
declare function getAttributeName(context: RuleContext, node: TSESTree$1.JSXAttribute): string;

/**
 * Get a StaticValue of the attribute value
 * @param context The rule context
 * @param node The JSX attribute node
 * @param name The name of the attribute
 * @returns The StaticValue of the attribute value
 */
declare function getAttributeValue(context: RuleContext, node: TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute, name: string): Exclude<VAR.LazyValue, {
    kind: "lazy";
}>;

type JSXDetectionHint = bigint;
declare const JSXDetectionHint: {
    readonly None: 0n;
    readonly SkipUndefined: bigint;
    readonly SkipNullLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipBigIntLiteral: bigint;
    readonly SkipEmptyArray: bigint;
    readonly SkipCreateElement: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_JSX_DETECTION_HINT: bigint;

/**
 * Check if a node is a `JSXText` or a `Literal` node
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXText` or a `Literal` node
 */
declare function isJsxText(node: TSESTree$1.Node | null | _): node is TSESTree$1.JSXText | TSESTree$1.Literal;
/**
 * Heuristic decision to determine if a node is a JSX-like node.
 * @param code The sourceCode object
 * @param code.getScope The function to get the scope of a node
 * @param node The AST node to check
 * @param hint The `JSXDetectionHint` to use
 * @returns boolean
 */
declare function isJsxLike(code: {
    getScope: (node: TSESTree$1.Node) => Scope;
}, node: TSESTree$1.Node | _ | null, hint?: JSXDetectionHint): boolean;

/**
 * Get the stringified type of a JSX element
 * @param context The ESLint rule context
 * @param node The JSX element node
 * @returns The type of the element
 */
declare function getElementType(context: RuleContext, node: TSESTree.JSXElement | TSESTree.JSXFragment): string;

declare function hasAttribute(context: RuleContext, name: string, attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasAnyAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasEveryAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;

/**
 * Find the parent JSX attribute node of a node
 * @param node The node to find the parent attribute of
 * @param test The test to apply to the parent attribute
 * @returns The parent attribute node or undefined
 */
declare function findParentAttribute(node: TSESTree.Node, test?: (node: TSESTree.JSXAttribute) => boolean): TSESTree.JSXAttribute | _;

declare function isHostElement(context: RuleContext, node: TSESTree.Node): boolean;
declare function isKeyedElement(context: RuleContext, node: TSESTree.Node, initialScope?: Scope): boolean;
declare function isFragmentElement(context: RuleContext, node: TSESTree.Node | null | _, allowJSXFragment?: false): node is TSESTree.JSXElement;
declare function isFragmentElement(context: RuleContext, node: TSESTree.Node | null | _, allowJSXFragment?: true): node is TSESTree.JSXElement | TSESTree.JSXFragment;

/**
 * Get the stringified representation of a JSX node
 * @param node The JSX node
 * @returns The stringified representation
 */
declare function stringifyJsx(node: TSESTree$1.JSXIdentifier | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXClosingElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXText): string;

/** @internal */
declare function getInstanceId(node: TSESTree.Node, prev?: TSESTree.Node): TSESTree.ArrayExpression | TSESTree.ArrayPattern | TSESTree.ArrowFunctionExpression | TSESTree.AssignmentExpression | TSESTree.AwaitExpression | TSESTree.BinaryExpression | TSESTree.CallExpression | TSESTree.ChainExpression | TSESTree.ClassExpression | TSESTree.ConditionalExpression | TSESTree.FunctionExpression | TSESTree.Identifier | TSESTree.ImportExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.TemplateLiteral | TSESTree.LogicalExpression | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.NewExpression | TSESTree.ObjectExpression | TSESTree.ObjectPattern | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.ThisExpression | TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion | TSESTree.UnaryExpression | TSESTree.UpdateExpression | TSESTree.YieldExpression | TSESTree.PrivateIdentifier | undefined;

/**
 * Check if an identifier is initialized from react
 * @param name The top-level identifier's name
 * @param importSource The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier is initialized from react
 */
declare function isInitializedFromReact(name: string, importSource: string, initialScope: Scope): boolean;

/** @internal */
declare function isInstanceIdEqual(context: RuleContext, a: TSESTree.Node, b: TSESTree.Node): boolean;

declare namespace isReactAPI {
    type ReturnType = {
        (context: RuleContext, node: _ | null | TSESTree.Node): node is TSESTree.Identifier | TSESTree.MemberExpression;
        (context: RuleContext): (node: _ | null | TSESTree.Node) => node is TSESTree.MemberExpression | TSESTree.Identifier;
    };
}
declare function isReactAPI(api: string): isReactAPI.ReturnType;
declare namespace isReactAPICall {
    type ReturnType = {
        (context: RuleContext, node: _ | null | TSESTree.Node): node is TSESTree.CallExpression;
        (context: RuleContext): (node: _ | null | TSESTree.Node) => node is TSESTree.CallExpression;
    };
}
declare function isReactAPICall(api: string): isReactAPICall.ReturnType;
declare const isCaptureOwnerStack: isReactAPI.ReturnType;
declare const isChildrenCount: isReactAPI.ReturnType;
declare const isChildrenForEach: isReactAPI.ReturnType;
declare const isChildrenMap: isReactAPI.ReturnType;
declare const isChildrenOnly: isReactAPI.ReturnType;
declare const isChildrenToArray: isReactAPI.ReturnType;
declare const isCloneElement: isReactAPI.ReturnType;
declare const isCreateContext: isReactAPI.ReturnType;
declare const isCreateElement: isReactAPI.ReturnType;
declare const isCreateRef: isReactAPI.ReturnType;
declare const isForwardRef: isReactAPI.ReturnType;
declare const isMemo: isReactAPI.ReturnType;
declare const isLazy: isReactAPI.ReturnType;
declare const isCaptureOwnerStackCall: isReactAPICall.ReturnType;
declare const isChildrenCountCall: isReactAPICall.ReturnType;
declare const isChildrenForEachCall: isReactAPICall.ReturnType;
declare const isChildrenMapCall: isReactAPICall.ReturnType;
declare const isChildrenOnlyCall: isReactAPICall.ReturnType;
declare const isChildrenToArrayCall: isReactAPICall.ReturnType;
declare const isCloneElementCall: isReactAPICall.ReturnType;
declare const isCreateContextCall: isReactAPICall.ReturnType;
declare const isCreateElementCall: isReactAPICall.ReturnType;
declare const isCreateRefCall: isReactAPICall.ReturnType;
declare const isForwardRefCall: isReactAPICall.ReturnType;
declare const isMemoCall: isReactAPICall.ReturnType;
declare const isLazyCall: isReactAPICall.ReturnType;

export { type ClassComponent, type Component, ComponentDetectionHint, type ComponentEffectPhaseKind, ComponentFlag, type ComponentKind, type ComponentLifecyclePhaseKind, type ComponentPhaseKind, ComponentPhaseRelevance, type ComponentStateKind, DEFAULT_COMPONENT_DETECTION_HINT, DEFAULT_JSX_DETECTION_HINT, type EffectKind, type FunctionComponent, type Hook, type HookKind, JSXDetectionHint, type SemanticEntry, type SemanticNode, findParentAttribute, getAttribute, getAttributeName, getAttributeValue, getComponentFlagFromInitPath, getComponentNameFromId, getElementType, getFunctionComponentId, getInstanceId, hasAnyAttribute, hasAttribute, hasEveryAttribute, hasNoneOrLooseComponentName, isAssignmentToThisState, isCaptureOwnerStack, isCaptureOwnerStackCall, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentName, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUnmount, isComponentWillUpdate, isComponentWrapperCall, isComponentWrapperCallLoose, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRender, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetChildContext, isGetDefaultProps, isGetDerivedStateFromError, isGetDerivedStateFromProps, isGetInitialState, isGetSnapshotBeforeUpdate, isHostElement, isInitializedFromReact, isInsideRenderMethod, isInstanceIdEqual, isInversePhase, isJsxLike, isJsxText, isKeyedElement, isLazy, isLazyCall, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderLike, isRenderMethodLike, isRenderPropLoose, isShouldComponentUpdate, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseActionStateCall, isUseCall, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseFormStatusCall, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseOptimisticCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, isValidComponentDefinition, stringifyJsx, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
