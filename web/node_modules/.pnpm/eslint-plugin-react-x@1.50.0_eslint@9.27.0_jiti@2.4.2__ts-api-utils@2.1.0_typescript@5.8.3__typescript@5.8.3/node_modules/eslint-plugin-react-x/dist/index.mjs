import { getDocsUrl, getSettingsFromContext, coerceSettings, DEFAULT_ESLINT_REACT_SETTINGS } from '@eslint-react/shared';
import * as ER25 from '@eslint-react/core';
import { ESLintUtils } from '@typescript-eslint/utils';
import { JsxConfig, Reporter, Selector } from '@eslint-react/kit';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import * as VAR2 from '@eslint-react/var';
import { match, isMatching, P } from 'ts-pattern';
import * as AST8 from '@eslint-react/ast';
import { flow, getOrElseUpdate, constTrue, constFalse, _ } from '@eslint-react/eff';
import { compare } from 'compare-versions';
import { getConstrainedTypeAtLocation, isTypeReadonly } from '@typescript-eslint/type-utils';
import { unionTypeParts, isTypeFlagSet, isTrueLiteralType, isFalseLiteralType } from 'ts-api-utils';
import ts from 'typescript';
import { getTypeImmutability, isUnknown, isImmutable, isReadonlyShallow, isReadonlyDeep } from 'is-immutable-type';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name5 in all)
    __defProp(target, name5, { get: all[name5], enumerable: true });
};

// src/configs/recommended.ts
var recommended_exports = {};
__export(recommended_exports, {
  name: () => name,
  rules: () => rules,
  settings: () => settings
});
var name = "react-x/recommended";
var rules = {
  "react-x/jsx-key-before-spread": "warn",
  "react-x/jsx-no-duplicate-props": "warn",
  "react-x/jsx-uses-react": "warn",
  "react-x/jsx-uses-vars": "warn",
  "react-x/no-access-state-in-setstate": "error",
  "react-x/no-array-index-key": "warn",
  "react-x/no-children-count": "warn",
  "react-x/no-children-for-each": "warn",
  "react-x/no-children-map": "warn",
  "react-x/no-children-only": "warn",
  "react-x/no-children-to-array": "warn",
  "react-x/no-clone-element": "warn",
  "react-x/no-comment-textnodes": "warn",
  "react-x/no-component-will-mount": "error",
  "react-x/no-component-will-receive-props": "error",
  "react-x/no-component-will-update": "error",
  "react-x/no-context-provider": "warn",
  "react-x/no-create-ref": "error",
  "react-x/no-default-props": "error",
  "react-x/no-direct-mutation-state": "error",
  "react-x/no-duplicate-key": "warn",
  "react-x/no-forward-ref": "warn",
  "react-x/no-implicit-key": "warn",
  "react-x/no-missing-key": "error",
  "react-x/no-misused-capture-owner-stack": "error",
  "react-x/no-nested-component-definitions": "error",
  "react-x/no-nested-lazy-component-declarations": "warn",
  "react-x/no-prop-types": "error",
  "react-x/no-redundant-should-component-update": "error",
  "react-x/no-set-state-in-component-did-mount": "warn",
  "react-x/no-set-state-in-component-did-update": "warn",
  "react-x/no-set-state-in-component-will-update": "warn",
  "react-x/no-string-refs": "error",
  "react-x/no-unsafe-component-will-mount": "warn",
  "react-x/no-unsafe-component-will-receive-props": "warn",
  "react-x/no-unsafe-component-will-update": "warn",
  "react-x/no-unstable-context-value": "warn",
  "react-x/no-unstable-default-props": "warn",
  "react-x/no-unused-class-component-members": "warn",
  "react-x/no-unused-state": "warn",
  "react-x/no-use-context": "warn",
  "react-x/no-useless-forward-ref": "warn"
};
var settings = {
  "react-x": DEFAULT_ESLINT_REACT_SETTINGS
};

// src/configs/recommended-type-checked.ts
var recommended_type_checked_exports = {};
__export(recommended_type_checked_exports, {
  name: () => name3,
  rules: () => rules3,
  settings: () => settings3
});

// src/configs/recommended-typescript.ts
var recommended_typescript_exports = {};
__export(recommended_typescript_exports, {
  name: () => name2,
  rules: () => rules2,
  settings: () => settings2
});
var name2 = "react-x/recommended-typescript";
var rules2 = {
  ...rules,
  "react-x/jsx-no-duplicate-props": "off",
  "react-x/jsx-no-undef": "off",
  "react-x/jsx-uses-react": "off",
  "react-x/jsx-uses-vars": "off"
};
var settings2 = {
  ...settings
};

// src/configs/recommended-type-checked.ts
var name3 = "react-x/recommended-type-checked";
var rules3 = {
  ...rules2,
  "react-x/no-leaked-conditional-rendering": "warn"
  // "react-x/prefer-read-only-props": "warn",
};
var settings3 = {
  ...settings2
};

// package.json
var name4 = "eslint-plugin-react-x";
var version = "1.50.0";
var createRule = ESLintUtils.RuleCreator(getDocsUrl("x"));

// src/rules/avoid-shorthand-boolean.ts
var RULE_NAME = "avoid-shorthand-boolean";
var RULE_FEATURES = [];
var avoid_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces explicit boolean values for boolean attributes.",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    fixable: "code",
    messages: {
      avoidShorthandBoolean: "Avoid using shorthand boolean attribute '{{propName}}'. Use '{{propName}}={true}' instead."
    },
    schema: []
  },
  name: RULE_NAME,
  create,
  defaultOptions: []
});
function create(context) {
  return {
    JSXAttribute(node) {
      if (node.value == null) {
        context.report({
          messageId: "avoidShorthandBoolean",
          node,
          data: {
            propName: ER25.getAttributeName(context, node)
          },
          fix: (fixer) => fixer.insertTextAfter(node.name, `={true}`)
        });
      }
    }
  };
}
var RULE_NAME2 = "avoid-shorthand-fragment";
var RULE_FEATURES2 = [];
var avoid_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces explicit `<Fragment>` components instead of the shorthand `<>` or `</>` syntax.",
      [Symbol.for("rule_features")]: RULE_FEATURES2
    },
    messages: {
      avoidShorthandFragment: "Avoid using shorthand fragment syntax. Use '{{jsxFragmentFactory}}' component instead."
    },
    schema: []
  },
  name: RULE_NAME2,
  create: create2,
  defaultOptions: []
});
function create2(context) {
  const jsxConfigFromContext = JsxConfig.getFromContext(context);
  const jsxConfigFromAnnotation = JsxConfig.getFromAnnotation(context);
  const jsxConfig = {
    ...jsxConfigFromContext,
    ...jsxConfigFromAnnotation
  };
  return {
    JSXFragment(node) {
      context.report({
        messageId: "avoidShorthandFragment",
        node,
        data: {
          jsxFragmentFactory: jsxConfig.jsxFragmentFactory
        }
      });
    }
  };
}
var RULE_NAME3 = "jsx-key-before-spread";
var RULE_FEATURES3 = [
  "EXP"
];
var jsx_key_before_spread_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces that the 'key' attribute is placed before the spread attribute in JSX elements.",
      [Symbol.for("rule_features")]: RULE_FEATURES3
    },
    messages: {
      jsxKeyBeforeSpread: "The 'key' attribute must be placed before the spread attribute."
    },
    schema: []
  },
  name: RULE_NAME3,
  create: create3,
  defaultOptions: []
});
function create3(context) {
  return {
    JSXOpeningElement(node) {
      let firstSpreadAttributeIndex = null;
      for (const [index, attr] of node.attributes.entries()) {
        if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) {
          firstSpreadAttributeIndex ??= index;
          continue;
        }
        if (attr.name.name === "key" && firstSpreadAttributeIndex != null && index > firstSpreadAttributeIndex) {
          context.report({
            messageId: "jsxKeyBeforeSpread",
            node: attr
          });
        }
      }
    }
  };
}
var RULE_NAME4 = "jsx-no-duplicate-props";
var RULE_FEATURES4 = [];
var jsx_no_duplicate_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow duplicate props in JSX elements.",
      [Symbol.for("rule_features")]: RULE_FEATURES4
    },
    messages: {
      jsxNoDuplicateProps: "This JSX property is assigned multiple times."
    },
    schema: []
  },
  name: RULE_NAME4,
  create: create4,
  defaultOptions: []
});
function create4(context) {
  return {
    JSXOpeningElement(node) {
      const props = [];
      for (const attr of node.attributes) {
        if (attr.type === AST_NODE_TYPES.JSXSpreadAttribute) {
          continue;
        }
        const name5 = attr.name.name;
        if (typeof name5 !== "string") {
          continue;
        }
        if (!props.includes(name5)) {
          props.push(name5);
          continue;
        }
        context.report({
          messageId: "jsxNoDuplicateProps",
          node: attr
        });
      }
    }
  };
}
var RULE_NAME5 = "jsx-no-undef";
var RULE_FEATURES5 = [];
var jsx_no_undef_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow undefined variables in JSX.",
      [Symbol.for("rule_features")]: RULE_FEATURES5
    },
    messages: {
      jsxNoUndef: "JSX variable '{{name}}' is not defined."
    },
    schema: []
  },
  name: RULE_NAME5,
  create: create5,
  defaultOptions: []
});
function create5(context) {
  return {
    JSXOpeningElement(node) {
      const name5 = match(node.name).with({ type: AST_NODE_TYPES.JSXIdentifier }, (n) => n.name).with({ type: AST_NODE_TYPES.JSXMemberExpression, object: { type: AST_NODE_TYPES.JSXIdentifier } }, (n) => n.object.name).otherwise(() => null);
      if (name5 == null) return;
      if (name5 === "this") return;
      if (/^[a-z]/u.test(name5)) return;
      if (VAR2.findVariable(name5, context.sourceCode.getScope(node)) == null) {
        context.report({
          messageId: "jsxNoUndef",
          node,
          data: {
            name: name5
          }
        });
      }
    }
  };
}
var { JsxEmit } = JsxConfig;
var RULE_NAME6 = "jsx-uses-react";
var RULE_FEATURES6 = [];
var jsx_uses_react_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Marks React variables as used when JSX is used.",
      [Symbol.for("rule_features")]: RULE_FEATURES6
    },
    messages: {
      jsxUsesReact: "Marked {{name}} as used."
    },
    schema: []
  },
  name: RULE_NAME6,
  create: create6,
  defaultOptions: []
});
function create6(context) {
  const jsxConfig = {
    ...JsxConfig.getFromContext(context),
    ...JsxConfig.getFromAnnotation(context)
  };
  const { jsx, jsxFactory, jsxFragmentFactory } = jsxConfig;
  if (jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev) return {};
  function handleJsxElement(node) {
    context.sourceCode.markVariableAsUsed(jsxFactory, node);
    debugReport(context, node, jsxFactory);
  }
  function handleJsxFragment(node) {
    context.sourceCode.markVariableAsUsed(jsxFragmentFactory, node);
    debugReport(context, node, jsxFragmentFactory);
  }
  return {
    JSXFragment: handleJsxFragment,
    JSXOpeningElement: handleJsxElement,
    JSXOpeningFragment: handleJsxElement
  };
}
function debugReport(context, node, name5) {
  if (process.env["ESLINT_REACT_DEBUG"] !== "1") return;
  context.report({
    messageId: "jsxUsesReact",
    node,
    data: { name: name5 }
  });
}
var RULE_NAME7 = "jsx-uses-vars";
var RULE_FEATURES7 = [];
var jsx_uses_vars_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Marks variables used in JSX elements as used.",
      [Symbol.for("rule_features")]: RULE_FEATURES7
    },
    messages: {
      jsxUsesVars: ""
    },
    schema: []
  },
  name: RULE_NAME7,
  create: create7,
  defaultOptions: []
});
function create7(context) {
  return {
    JSXOpeningElement(node) {
      switch (node.name.type) {
        case AST_NODE_TYPES.JSXIdentifier: {
          if (/^[a-z]/u.test(node.name.name)) {
            return;
          }
          context.sourceCode.markVariableAsUsed(node.name.name, node);
          break;
        }
        case AST_NODE_TYPES.JSXMemberExpression: {
          const { object } = node.name;
          if (object.type === AST_NODE_TYPES.JSXIdentifier) {
            context.sourceCode.markVariableAsUsed(object.name, node);
          }
          break;
        }
      }
    }
  };
}
var RULE_NAME8 = "no-access-state-in-setstate";
var RULE_FEATURES8 = [];
function isKeyLiteral(node, key) {
  return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({ type: AST_NODE_TYPES.TemplateLiteral, expressions: [] }, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_access_state_in_setstate_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow accessing `this.state` inside `setState` calls.",
      [Symbol.for("rule_features")]: RULE_FEATURES8
    },
    messages: {
      noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead."
    },
    schema: []
  },
  name: RULE_NAME8,
  create: create8,
  defaultOptions: []
});
function create8(context) {
  if (!context.sourceCode.text.includes("setState")) {
    return {};
  }
  const classEntries = [];
  const methodEntries = [];
  const setStateEntries = [];
  return {
    CallExpression(node) {
      if (!ER25.isThisSetState(node)) {
        return;
      }
      setStateEntries.push([node, false]);
    },
    "CallExpression:exit"(node) {
      if (!ER25.isThisSetState(node)) {
        return;
      }
      setStateEntries.pop();
    },
    ClassDeclaration(node) {
      classEntries.push([node, ER25.isClassComponent(node)]);
    },
    "ClassDeclaration:exit"() {
      classEntries.pop();
    },
    ClassExpression(node) {
      classEntries.push([node, ER25.isClassComponent(node)]);
    },
    "ClassExpression:exit"() {
      classEntries.pop();
    },
    MemberExpression(node) {
      if (!AST8.isThisExpression(node.object)) {
        return;
      }
      const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
      if (currClass == null || !isComponent) {
        return;
      }
      const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
      if (currMethod == null || isStatic) {
        return;
      }
      const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
      if (setState == null || hasThisState) {
        return;
      }
      if (AST8.getPropertyName(node.property) !== "state") {
        return;
      }
      context.report({ messageId: "noAccessStateInSetstate", node });
    },
    MethodDefinition(node) {
      methodEntries.push([node, node.static]);
    },
    "MethodDefinition:exit"() {
      methodEntries.pop();
    },
    PropertyDefinition(node) {
      methodEntries.push([node, node.static]);
    },
    "PropertyDefinition:exit"() {
      methodEntries.pop();
    },
    VariableDeclarator(node) {
      const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
      if (currClass == null || !isComponent) {
        return;
      }
      const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
      if (currMethod == null || isStatic) {
        return;
      }
      const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
      if (setState == null || hasThisState) {
        return;
      }
      if (node.init == null || !AST8.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) {
        return;
      }
      const hasState = node.id.properties.some(
        (prop) => prop.type === AST_NODE_TYPES.Property && isKeyLiteral(prop, prop.key) && AST8.getPropertyName(prop.key) === "state"
      );
      if (!hasState) {
        return;
      }
      context.report({ messageId: "noAccessStateInSetstate", node });
    }
  };
}
var RULE_NAME9 = "no-array-index-key";
var RULE_FEATURES9 = [];
var reactChildrenMethod = ["forEach", "map"];
function isReactChildrenMethod(name5) {
  return reactChildrenMethod.some((method) => method === name5);
}
function isUsingReactChildren(context, node) {
  const { importSource = "react" } = coerceSettings(context.settings);
  const { callee } = node;
  if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) {
    return false;
  }
  if (!isReactChildrenMethod(callee.property.name)) {
    return false;
  }
  const initialScope = context.sourceCode.getScope(node);
  if (callee.object.type === AST_NODE_TYPES.Identifier && callee.object.name === "Children") {
    return true;
  }
  if (callee.object.type === AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) {
    return ER25.isInitializedFromReact(callee.object.object.name, importSource, initialScope);
  }
  return false;
}
function getMapIndexParamName(context, node) {
  const { callee } = node;
  if (callee.type !== AST_NODE_TYPES.MemberExpression) {
    return _;
  }
  if (callee.property.type !== AST_NODE_TYPES.Identifier) {
    return _;
  }
  const { name: name5 } = callee.property;
  const indexPosition = AST8.getArrayMethodCallbackIndexParamPosition(name5);
  if (indexPosition === -1) {
    return _;
  }
  const callbackArg = node.arguments[isUsingReactChildren(context, node) ? 1 : 0];
  if (callbackArg == null) {
    return _;
  }
  if (!AST8.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(callbackArg)) {
    return _;
  }
  const { params } = callbackArg;
  if (params.length < indexPosition + 1) {
    return _;
  }
  const param = params.at(indexPosition);
  return param != null && "name" in param ? param.name : _;
}
function getIdentifiersFromBinaryExpression(side) {
  if (side.type === AST_NODE_TYPES.Identifier) {
    return [side];
  }
  if (side.type === AST_NODE_TYPES.BinaryExpression) {
    return [
      ...getIdentifiersFromBinaryExpression(side.left),
      ...getIdentifiersFromBinaryExpression(side.right)
    ];
  }
  return [];
}
var no_array_index_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow an item's index in the array as its key.",
      [Symbol.for("rule_features")]: RULE_FEATURES9
    },
    messages: {
      noArrayIndexKey: "Do not use item index in the array as its key."
    },
    schema: []
  },
  name: RULE_NAME9,
  create: create9,
  defaultOptions: []
});
function create9(context) {
  const report = Reporter.make(context);
  const indexParamNames = [];
  function isArrayIndex(node) {
    return node.type === AST_NODE_TYPES.Identifier && indexParamNames.some((name5) => name5 != null && name5 === node.name);
  }
  function isCreateOrCloneElementCall(node) {
    return ER25.isCreateElementCall(context, node) || ER25.isCloneElementCall(context, node);
  }
  function getReportDescriptors(node) {
    switch (node.type) {
      // key={bar}
      case AST_NODE_TYPES.Identifier: {
        if (indexParamNames.some((name5) => name5 != null && name5 === node.name)) {
          return [{
            messageId: "noArrayIndexKey",
            node
          }];
        }
        return [];
      }
      // key={`foo-${bar}`} or key={'foo' + bar}
      case AST_NODE_TYPES.TemplateLiteral:
      case AST_NODE_TYPES.BinaryExpression: {
        const descriptors = [];
        const expressions = node.type === AST_NODE_TYPES.TemplateLiteral ? node.expressions : getIdentifiersFromBinaryExpression(node);
        for (const expression of expressions) {
          if (isArrayIndex(expression)) {
            descriptors.push({
              messageId: "noArrayIndexKey",
              node: expression
            });
          }
        }
        return descriptors;
      }
      // key={bar.toString()} or key={String(bar)}
      case AST_NODE_TYPES.CallExpression: {
        switch (true) {
          // key={bar.toString()}
          case (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "toString" && isArrayIndex(node.callee.object)): {
            return [{
              messageId: "noArrayIndexKey",
              node: node.callee.object
            }];
          }
          // key={String(bar)}
          case (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === "String" && node.arguments[0] != null && isArrayIndex(node.arguments[0])): {
            return [{
              messageId: "noArrayIndexKey",
              node: node.arguments[0]
            }];
          }
        }
      }
    }
    return [];
  }
  return {
    CallExpression(node) {
      indexParamNames.push(getMapIndexParamName(context, node));
      if (node.arguments.length === 0) {
        return;
      }
      if (!isCreateOrCloneElementCall(node)) {
        return;
      }
      const [, props] = node.arguments;
      if (props?.type !== AST_NODE_TYPES.ObjectExpression) {
        return;
      }
      for (const prop of props.properties) {
        if (!isMatching({ key: { name: "key" } })(prop)) {
          continue;
        }
        if (!("value" in prop)) {
          continue;
        }
        for (const descriptor of getReportDescriptors(prop.value)) {
          report.send(descriptor);
        }
      }
    },
    "CallExpression:exit"() {
      indexParamNames.pop();
    },
    JSXAttribute(node) {
      if (node.name.name !== "key") {
        return;
      }
      if (indexParamNames.length === 0) {
        return;
      }
      if (node.value?.type !== AST_NODE_TYPES.JSXExpressionContainer) {
        return;
      }
      for (const descriptor of getReportDescriptors(node.value.expression)) {
        report.send(descriptor);
      }
    }
  };
}
var RULE_NAME10 = "no-children-count";
var RULE_FEATURES10 = [];
var no_children_count_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `Children.count`.",
      [Symbol.for("rule_features")]: RULE_FEATURES10
    },
    messages: {
      noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME10,
  create: create10,
  defaultOptions: []
});
function create10(context) {
  return {
    MemberExpression(node) {
      if (ER25.isChildrenCount(context, node)) {
        context.report({
          messageId: "noChildrenCount",
          node: node.property
        });
      }
    }
  };
}
var RULE_NAME11 = "no-children-for-each";
var RULE_FEATURES11 = [];
var no_children_for_each_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow 'Children.forEach'.",
      [Symbol.for("rule_features")]: RULE_FEATURES11
    },
    messages: {
      noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME11,
  create: create11,
  defaultOptions: []
});
function create11(context) {
  return {
    MemberExpression(node) {
      if (ER25.isChildrenForEach(context, node)) {
        context.report({
          messageId: "noChildrenForEach",
          node: node.property
        });
      }
    }
  };
}
var RULE_NAME12 = "no-children-map";
var RULE_FEATURES12 = [];
var no_children_map_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `Children.map`.",
      [Symbol.for("rule_features")]: RULE_FEATURES12
    },
    messages: {
      noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME12,
  create: create12,
  defaultOptions: []
});
function create12(context) {
  return {
    MemberExpression(node) {
      if (ER25.isChildrenMap(context, node)) {
        context.report({
          messageId: "noChildrenMap",
          node: node.property
        });
      }
    }
  };
}
var RULE_NAME13 = "no-children-only";
var RULE_FEATURES13 = [];
var no_children_only_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `Children.only`.",
      [Symbol.for("rule_features")]: RULE_FEATURES13
    },
    messages: {
      noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME13,
  create: create13,
  defaultOptions: []
});
function create13(context) {
  return {
    MemberExpression(node) {
      if (ER25.isChildrenOnly(context, node)) {
        context.report({
          messageId: "noChildrenOnly",
          node: node.property
        });
      }
    }
  };
}
var RULE_NAME14 = "no-children-prop";
var RULE_FEATURES14 = [];
var no_children_prop_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow passing `children` as a prop.",
      [Symbol.for("rule_features")]: RULE_FEATURES14
    },
    messages: {
      noChildrenProp: "Do not pass 'children' as props."
    },
    schema: []
  },
  name: RULE_NAME14,
  create: create14,
  defaultOptions: []
});
function create14(context) {
  return {
    JSXElement(node) {
      const attributes = node.openingElement.attributes;
      const childrenProp = ER25.getAttribute(context, "children", attributes, context.sourceCode.getScope(node));
      if (childrenProp != null) {
        context.report({
          messageId: "noChildrenProp",
          node: childrenProp
        });
      }
    }
  };
}
var RULE_NAME15 = "no-children-to-array";
var RULE_FEATURES15 = [];
var no_children_to_array_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `Children.toArray`.",
      [Symbol.for("rule_features")]: RULE_FEATURES15
    },
    messages: {
      noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME15,
  create: create15,
  defaultOptions: []
});
function create15(context) {
  return {
    MemberExpression(node) {
      if (ER25.isChildrenToArray(context, node)) {
        context.report({
          messageId: "noChildrenToArray",
          node: node.property
        });
      }
    }
  };
}
var RULE_NAME16 = "no-class-component";
var RULE_FEATURES16 = [];
var no_class_component_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow class components except for error boundaries.",
      [Symbol.for("rule_features")]: RULE_FEATURES16
    },
    messages: {
      noClassComponent: "Avoid using class components. Use function components instead."
    },
    schema: []
  },
  name: RULE_NAME16,
  create: create16,
  defaultOptions: []
});
function create16(context) {
  if (!context.sourceCode.text.includes("Component")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { name: name5 = "anonymous", node: component } of components.values()) {
        if (component.body.body.some((m) => ER25.isComponentDidCatch(m) || ER25.isGetDerivedStateFromError(m))) {
          continue;
        }
        context.report({
          messageId: "noClassComponent",
          node: component,
          data: {
            name: name5
          }
        });
      }
    }
  };
}
var RULE_NAME17 = "no-clone-element";
var RULE_FEATURES17 = [];
var no_clone_element_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `cloneElement`.",
      [Symbol.for("rule_features")]: RULE_FEATURES17
    },
    messages: {
      noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME17,
  create: create17,
  defaultOptions: []
});
function create17(context) {
  return {
    CallExpression(node) {
      if (ER25.isCloneElementCall(context, node)) {
        context.report({
          messageId: "noCloneElement",
          node
        });
      }
    }
  };
}
var RULE_NAME18 = "no-comment-textnodes";
var RULE_FEATURES18 = [];
var no_comment_textnodes_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents comments from being inserted as text nodes.",
      [Symbol.for("rule_features")]: RULE_FEATURES18
    },
    messages: {
      noCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces."
    },
    schema: []
  },
  name: RULE_NAME18,
  create: create18,
  defaultOptions: []
});
function create18(context) {
  function hasCommentLike(node) {
    if (AST8.isOneOf([AST_NODE_TYPES.JSXAttribute, AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) {
      return false;
    }
    const rawValue = context.sourceCode.getText(node);
    return /^\s*\/(?:\/|\*)/mu.test(rawValue);
  }
  const visitorFunction = (node) => {
    if (!AST8.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent)) {
      return;
    }
    if (!hasCommentLike(node)) {
      return;
    }
    if (!node.parent.type.includes("JSX")) {
      return;
    }
    context.report({
      messageId: "noCommentTextnodes",
      node
    });
  };
  return {
    JSXText: visitorFunction,
    Literal: visitorFunction
  };
}
var RULE_NAME19 = "no-complex-conditional-rendering";
var RULE_FEATURES19 = [
  "EXP"
];
var no_complex_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow complex conditional rendering in JSX expressions.",
      [Symbol.for("rule_features")]: RULE_FEATURES19
    },
    messages: {
      noComplexConditionalRendering: "Avoid complex conditional rendering. Extract the logic into separate elements or components."
    },
    schema: []
  },
  name: RULE_NAME19,
  create: create19,
  defaultOptions: []
});
function create19(context) {
  const visitorFunction = (node) => {
    const jsxExpContainer = node.parent?.parent;
    if (!AST8.is(AST_NODE_TYPES.JSXExpressionContainer)(jsxExpContainer)) {
      return;
    }
    if (!AST8.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(jsxExpContainer.parent)) {
      return;
    }
    if (!jsxExpContainer.parent.children.includes(jsxExpContainer)) {
      return;
    }
    context.report({
      messageId: "noComplexConditionalRendering",
      node: jsxExpContainer
    });
  };
  return {
    "JSXExpressionContainer > ConditionalExpression > ConditionalExpression": visitorFunction,
    "JSXExpressionContainer > ConditionalExpression > LogicalExpression": visitorFunction,
    "JSXExpressionContainer > LogicalExpression > ConditionalExpression": visitorFunction,
    "JSXExpressionContainer > LogicalExpression[operator='&&'] > LogicalExpression[operator='||']": visitorFunction,
    "JSXExpressionContainer > LogicalExpression[operator='||'] > LogicalExpression[operator='&&']": visitorFunction
  };
}
var RULE_NAME20 = "no-component-will-mount";
var RULE_FEATURES20 = [
  "MOD"
];
var no_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replace usages of `componentWillMount` with `UNSAFE_componentWillMount`.",
      [Symbol.for("rule_features")]: RULE_FEATURES20
    },
    fixable: "code",
    messages: {
      noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead."
    },
    schema: []
  },
  name: RULE_NAME20,
  create: create20,
  defaultOptions: []
});
function create20(context) {
  if (!context.sourceCode.text.includes("componentWillMount")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (ER25.isComponentWillMount(member)) {
            context.report({
              messageId: "noComponentWillMount",
              node: member,
              fix(fixer) {
                if (!("key" in member)) {
                  return null;
                }
                return fixer.replaceText(member.key, "UNSAFE_componentWillMount");
              }
            });
          }
        }
      }
    }
  };
}
var RULE_NAME21 = "no-component-will-receive-props";
var RULE_FEATURES21 = [
  "MOD"
];
var no_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replace usages of `componentWillReceiveProps` with `UNSAFE_componentWillReceiveProps`.",
      [Symbol.for("rule_features")]: RULE_FEATURES21
    },
    fixable: "code",
    messages: {
      noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead."
    },
    schema: []
  },
  name: RULE_NAME21,
  create: create21,
  defaultOptions: []
});
function create21(context) {
  if (!context.sourceCode.text.includes("componentWillReceiveProps")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (ER25.isComponentWillReceiveProps(member)) {
            context.report({
              messageId: "noComponentWillReceiveProps",
              node: member,
              fix(fixer) {
                if (!("key" in member)) {
                  return null;
                }
                return fixer.replaceText(member.key, "UNSAFE_componentWillReceiveProps");
              }
            });
          }
        }
      }
    }
  };
}
var RULE_NAME22 = "no-component-will-update";
var RULE_FEATURES22 = [
  "MOD"
];
var no_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replace usages of `componentWillUpdate` with `UNSAFE_componentWillUpdate`.",
      [Symbol.for("rule_features")]: RULE_FEATURES22
    },
    fixable: "code",
    messages: {
      noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead."
    },
    schema: []
  },
  name: RULE_NAME22,
  create: create22,
  defaultOptions: []
});
function create22(context) {
  if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (ER25.isComponentWillUpdate(member)) {
            context.report({
              messageId: "noComponentWillUpdate",
              node: member,
              fix(fixer) {
                if (!("key" in member)) {
                  return null;
                }
                return fixer.replaceText(member.key, "UNSAFE_componentWillUpdate");
              }
            });
          }
        }
      }
    }
  };
}
var RULE_NAME23 = "no-context-provider";
var RULE_FEATURES23 = [
  "MOD"
];
var no_context_provider_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replace usages of `<Context.Provider>` with `<Context>`.",
      [Symbol.for("rule_features")]: RULE_FEATURES23
    },
    fixable: "code",
    messages: {
      noContextProvider: "In React 19, you can render '<Context>' as a provider instead of '<Context.Provider>'."
    },
    schema: []
  },
  name: RULE_NAME23,
  create: create23,
  defaultOptions: []
});
function create23(context) {
  if (!context.sourceCode.text.includes("Provider")) return {};
  const { version: version2 } = getSettingsFromContext(context);
  if (compare(version2, "19.0.0", "<")) return {};
  return {
    JSXElement(node) {
      const fullName = ER25.getElementType(context, node);
      const parts = fullName.split(".");
      const selfName = parts.pop();
      const contextFullName = parts.join(".");
      const contextSelfName = parts.pop();
      if (selfName !== "Provider") return;
      if (contextSelfName == null) return;
      context.report({
        messageId: "noContextProvider",
        node,
        fix(fixer) {
          if (!ER25.isComponentNameLoose(contextSelfName)) return null;
          const openingElement = node.openingElement;
          const closingElement = node.closingElement;
          if (closingElement == null) {
            return fixer.replaceText(openingElement.name, contextFullName);
          }
          return [
            fixer.replaceText(openingElement.name, contextFullName),
            fixer.replaceText(closingElement.name, contextFullName)
          ];
        }
      });
    }
  };
}
var RULE_NAME24 = "no-create-ref";
var RULE_FEATURES24 = [];
var no_create_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `createRef` in function components.",
      [Symbol.for("rule_features")]: RULE_FEATURES24
    },
    messages: {
      noCreateRef: "[Deprecated] Use 'useRef' instead."
    },
    schema: []
  },
  name: RULE_NAME24,
  create: create24,
  defaultOptions: []
});
function create24(context) {
  return {
    CallExpression(node) {
      if (ER25.isCreateRefCall(context, node) && AST8.findParentNode(node, ER25.isClassComponent) == null) {
        context.report({ messageId: "noCreateRef", node });
      }
    }
  };
}
var RULE_NAME25 = "no-default-props";
var RULE_FEATURES25 = [];
var no_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `defaultProps` property in favor of ES6 default parameters.",
      [Symbol.for("rule_features")]: RULE_FEATURES25
    },
    messages: {
      noDefaultProps: "[Deprecated] Use ES6 default parameters instead."
    },
    schema: []
  },
  name: RULE_NAME25,
  create: create25,
  defaultOptions: []
});
function create25(context) {
  if (!context.sourceCode.text.includes("defaultProps")) return {};
  return {
    AssignmentExpression(node) {
      if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) {
        return;
      }
      const { object, property } = node.left;
      if (object.type !== AST_NODE_TYPES.Identifier) {
        return;
      }
      if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "defaultProps") {
        return;
      }
      if (!ER25.isComponentNameLoose(object.name)) {
        return;
      }
      const variable = VAR2.findVariable(object.name, context.sourceCode.getScope(node));
      const variableNode = VAR2.getVariableInitNode(variable, 0);
      if (variableNode == null) return;
      if (!AST8.isFunction(variableNode) && !ER25.isClassComponent(variableNode)) return;
      context.report({ messageId: "noDefaultProps", node: property });
    },
    PropertyDefinition(node) {
      if (!ER25.isClassComponent(node.parent.parent)) {
        return;
      }
      if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "defaultProps") {
        return;
      }
      context.report({ messageId: "noDefaultProps", node });
    }
  };
}
var RULE_NAME26 = "no-direct-mutation-state";
var RULE_FEATURES26 = [];
function isConstructorFunction(node) {
  return AST8.isOneOf([AST_NODE_TYPES.FunctionDeclaration, AST_NODE_TYPES.FunctionExpression])(node) && AST8.isMethodOrProperty(node.parent) && node.parent.key.type === AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow direct mutation of `this.state`.",
      [Symbol.for("rule_features")]: RULE_FEATURES26
    },
    messages: {
      noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead."
    },
    schema: []
  },
  name: RULE_NAME26,
  create: create26,
  defaultOptions: []
});
function create26(context) {
  return {
    AssignmentExpression(node) {
      if (!ER25.isAssignmentToThisState(node)) return;
      const parentClass = AST8.findParentNode(
        node,
        AST8.isOneOf([
          AST_NODE_TYPES.ClassDeclaration,
          AST_NODE_TYPES.ClassExpression
        ])
      );
      if (parentClass == null) return;
      if (ER25.isClassComponent(parentClass) && context.sourceCode.getScope(node).block !== AST8.findParentNode(node, isConstructorFunction)) {
        context.report({
          messageId: "noDirectMutationState",
          node
        });
      }
    }
  };
}
var RULE_NAME27 = "no-duplicate-key";
var RULE_FEATURES27 = [];
var no_duplicate_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow duplicate `key` on elements in the same array or a list of `children`.",
      [Symbol.for("rule_features")]: RULE_FEATURES27
    },
    messages: {
      noDuplicateKey: "A key must be unique. '{{value}}' is duplicated."
    },
    schema: []
  },
  name: RULE_NAME27,
  create: create27,
  defaultOptions: []
});
function create27(context) {
  if (!context.sourceCode.getText().includes("key=")) {
    return {};
  }
  const keyedEntries = /* @__PURE__ */ new Map();
  function isKeyValueEqual(a, b) {
    const aValue = a.value;
    const bValue = b.value;
    if (aValue == null || bValue == null) {
      return false;
    }
    return AST8.isNodeEqual(aValue, bValue);
  }
  return {
    "JSXAttribute[name.name='key']"(node) {
      const jsxElement = node.parent.parent;
      switch (jsxElement.parent.type) {
        case AST_NODE_TYPES.ArrayExpression:
        case AST_NODE_TYPES.JSXElement:
        case AST_NODE_TYPES.JSXFragment: {
          const root = jsxElement.parent;
          const prevKeys = keyedEntries.get(root)?.keys ?? [];
          keyedEntries.set(root, {
            hasDuplicate: prevKeys.some((prevKey) => isKeyValueEqual(prevKey, node)),
            keys: [...prevKeys, node],
            root: jsxElement.parent
          });
          break;
        }
        default: {
          const call = AST8.findParentNode(jsxElement, AST8.isArrayMapCall);
          const iter = AST8.findParentNode(jsxElement, (n) => n === call || AST8.isFunction(n));
          if (!AST8.isFunction(iter)) return;
          const arg0 = call?.arguments[0];
          if (call == null || arg0 == null) return;
          if (AST8.getJSExpression(arg0) !== iter) {
            return;
          }
          keyedEntries.set(call, {
            hasDuplicate: node.value?.type === AST_NODE_TYPES.Literal,
            keys: [node],
            root: call
          });
        }
      }
    },
    "Program:exit"() {
      for (const { hasDuplicate, keys } of keyedEntries.values()) {
        if (!hasDuplicate) {
          continue;
        }
        for (const key of keys) {
          context.report({
            messageId: "noDuplicateKey",
            node: key,
            data: {
              value: context.sourceCode.getText(key)
            }
          });
        }
      }
    }
  };
}
var RULE_NAME28 = "no-forward-ref";
var RULE_FEATURES28 = [
  "MOD"
];
var no_forward_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replaces usages of `forwardRef` with passing `ref` as a prop.",
      [Symbol.for("rule_features")]: RULE_FEATURES28
    },
    fixable: "code",
    messages: {
      noForwardRef: "In React 19, 'forwardRef' is no longer necessary. Pass 'ref' as a prop instead."
    },
    schema: []
  },
  name: RULE_NAME28,
  create: create28,
  defaultOptions: []
});
function create28(context) {
  if (!context.sourceCode.text.includes("forwardRef")) {
    return {};
  }
  const { version: version2 } = getSettingsFromContext(context);
  if (compare(version2, "19.0.0", "<")) {
    return {};
  }
  return {
    CallExpression(node) {
      if (!ER25.isForwardRefCall(context, node)) {
        return;
      }
      const id = AST8.getFunctionId(node);
      context.report({
        messageId: "noForwardRef",
        node: id ?? node,
        fix: getFix(context, node)
      });
    }
  };
}
function getFix(context, node) {
  return (fixer) => {
    const [componentNode] = node.arguments;
    if (componentNode == null || !AST8.isFunction(componentNode)) {
      return [];
    }
    return [
      // unwrap component from forwardRef call
      fixer.removeRange([node.range[0], componentNode.range[0]]),
      fixer.removeRange([componentNode.range[1], node.range[1]]),
      // update component props and ref arguments to match the new signature
      ...getComponentPropsFixes(
        context,
        fixer,
        componentNode,
        node.typeArguments?.params ?? []
      )
    ];
  };
}
function getComponentPropsFixes(context, fixer, node, typeArguments) {
  const getText = (node2) => context.sourceCode.getText(node2);
  const [arg0, arg1] = node.params;
  const [typeArg0, typeArg1] = typeArguments;
  if (arg0 == null) {
    return [];
  }
  const fixedArg0Text = match(arg0).with({ type: AST_NODE_TYPES.Identifier }, (n) => `...${n.name}`).with({ type: AST_NODE_TYPES.ObjectPattern }, (n) => n.properties.map(getText).join(", ")).otherwise(() => null);
  const fixedArg1Text = match(arg1).with(P.nullish, () => "ref").with({ type: AST_NODE_TYPES.Identifier, name: "ref" }, () => "ref").with({ type: AST_NODE_TYPES.Identifier, name: P.string }, (n) => `ref: ${n.name}`).otherwise(() => null);
  if (fixedArg0Text == null || fixedArg1Text == null) {
    return [];
  }
  if (typeArg0 == null || typeArg1 == null) {
    return [
      fixer.replaceText(
        arg0,
        [
          "{",
          fixedArg1Text + ",",
          fixedArg0Text,
          "}"
        ].join(" ")
      ),
      ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]
    ];
  }
  const typeArg0Text = getText(typeArg0);
  const typeArg1Text = getText(typeArg1);
  return [
    fixer.replaceText(
      arg0,
      [
        "{",
        fixedArg1Text + ",",
        fixedArg0Text,
        "}:",
        typeArg1Text,
        "&",
        "{",
        `ref?:`,
        `React.RefObject<${typeArg0Text} | null>`,
        "}"
      ].join(" ")
    ),
    ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]
  ];
}
var RULE_NAME29 = "no-implicit-key";
var RULE_FEATURES29 = [
  "EXP"
];
var no_implicit_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents `key` from not being explicitly specified (e.g. spreading `key` from objects).",
      [Symbol.for("rule_features")]: RULE_FEATURES29
    },
    messages: {
      noImplicitKey: "Do not use implicit 'key' props."
    },
    schema: []
  },
  name: RULE_NAME29,
  create: create29,
  defaultOptions: []
});
function create29(context) {
  return {
    JSXOpeningElement(node) {
      const initialScope = context.sourceCode.getScope(node);
      const keyProp = ER25.getAttribute(context, "key", node.attributes, initialScope);
      const isKeyPropOnElement = node.attributes.some(
        (n) => n.type === AST_NODE_TYPES.JSXAttribute && n.name.type === AST_NODE_TYPES.JSXIdentifier && n.name.name === "key"
      );
      if (keyProp != null && !isKeyPropOnElement) {
        context.report({ messageId: "noImplicitKey", node: keyProp });
      }
    }
  };
}
var RULE_NAME30 = "no-leaked-conditional-rendering";
var RULE_FEATURES30 = [
  "TSC"
];
var tsHelpers = {
  isAnyType: (type) => isTypeFlagSet(type, ts.TypeFlags.TypeParameter | ts.TypeFlags.Any),
  isBigIntType: (type) => isTypeFlagSet(type, ts.TypeFlags.BigIntLike),
  isBooleanType: (type) => isTypeFlagSet(type, ts.TypeFlags.BooleanLike),
  isEnumType: (type) => isTypeFlagSet(type, ts.TypeFlags.EnumLike),
  isFalsyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: "0" } }, type),
  isFalsyNumberType: (type) => type.isNumberLiteral() && type.value === 0,
  isFalsyStringType: (type) => type.isStringLiteral() && type.value === "",
  isNeverType: (type) => isTypeFlagSet(type, ts.TypeFlags.Never),
  isNullishType: (type) => isTypeFlagSet(
    type,
    ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike
  ),
  isNumberType: (type) => isTypeFlagSet(type, ts.TypeFlags.NumberLike),
  isObjectType: (type) => !isTypeFlagSet(
    type,
    ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike | ts.TypeFlags.BooleanLike | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike | ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Never
  ),
  isStringType: (type) => isTypeFlagSet(type, ts.TypeFlags.StringLike),
  isTruthyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: P.not("0") } }, type),
  isTruthyNumberType: (type) => type.isNumberLiteral() && type.value !== 0,
  isTruthyStringType: (type) => type.isStringLiteral() && type.value !== "",
  isUnknownType: (type) => isTypeFlagSet(type, ts.TypeFlags.Unknown)
};
function inspectVariantTypes(types) {
  const variantTypes = /* @__PURE__ */ new Set();
  if (types.some(tsHelpers.isUnknownType)) {
    variantTypes.add("unknown");
    return variantTypes;
  }
  if (types.some(tsHelpers.isNullishType)) {
    variantTypes.add("nullish");
  }
  const booleans = types.filter(tsHelpers.isBooleanType);
  switch (true) {
    case (booleans.length === 1 && booleans[0] != null): {
      const first = booleans[0];
      if (isTrueLiteralType(first)) {
        variantTypes.add("truthy boolean");
      } else if (isFalseLiteralType(first)) {
        variantTypes.add("falsy boolean");
      }
      break;
    }
    case booleans.length === 2: {
      variantTypes.add("boolean");
      break;
    }
  }
  const strings = types.filter(tsHelpers.isStringType);
  if (strings.length > 0) {
    const evaluated = match(strings).when((types2) => types2.every(tsHelpers.isTruthyStringType), () => "truthy string").when((types2) => types2.every(tsHelpers.isFalsyStringType), () => "falsy string").otherwise(() => "string");
    variantTypes.add(evaluated);
  }
  const bigints = types.filter(tsHelpers.isBigIntType);
  if (bigints.length > 0) {
    const evaluated = match(bigints).when((types2) => types2.every(tsHelpers.isTruthyBigIntType), () => "truthy bigint").when((types2) => types2.every(tsHelpers.isFalsyBigIntType), () => "falsy bigint").otherwise(() => "bigint");
    variantTypes.add(evaluated);
  }
  const numbers = types.filter(tsHelpers.isNumberType);
  if (numbers.length > 0) {
    const evaluated = match(numbers).when((types2) => types2.every(tsHelpers.isTruthyNumberType), () => "truthy number").when((types2) => types2.every(tsHelpers.isFalsyNumberType), () => "falsy number").otherwise(() => "number");
    variantTypes.add(evaluated);
  }
  if (types.some(tsHelpers.isEnumType)) {
    variantTypes.add("enum");
  }
  if (types.some(tsHelpers.isObjectType)) {
    variantTypes.add("object");
  }
  if (types.some(tsHelpers.isAnyType)) {
    variantTypes.add("any");
  }
  if (types.some(tsHelpers.isNeverType)) {
    variantTypes.add("never");
  }
  return variantTypes;
}
var no_leaked_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents problematic leaked values from being rendered.",
      [Symbol.for("rule_features")]: RULE_FEATURES30
    },
    messages: {
      noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes."
    },
    schema: []
  },
  name: RULE_NAME30,
  create: create30,
  defaultOptions: []
});
function create30(context) {
  if (!context.sourceCode.text.includes("&&")) return {};
  const { version: version2 } = getSettingsFromContext(context);
  const allowedVariants = [
    "any",
    "boolean",
    "nullish",
    "object",
    "falsy boolean",
    "truthy bigint",
    "truthy boolean",
    "truthy number",
    "truthy string",
    ...compare(version2, "18.0.0", "<") ? [] : ["string", "falsy string"]
  ];
  const services = ESLintUtils.getParserServices(context, false);
  function getReportDescriptor(node) {
    if (node == null) return _;
    if (AST8.is(AST_NODE_TYPES.JSXExpressionContainer)(node)) return getReportDescriptor(node.expression);
    if (AST8.isJSX(node)) return _;
    if (AST8.isTypeExpression(node)) return getReportDescriptor(node.expression);
    return match(node).with({ type: AST_NODE_TYPES.LogicalExpression, operator: "&&" }, ({ left, right }) => {
      const isLeftUnaryNot = left.type === AST_NODE_TYPES.UnaryExpression && left.operator === "!";
      if (isLeftUnaryNot) {
        return getReportDescriptor(right);
      }
      const initialScope = context.sourceCode.getScope(left);
      const isLeftNan = left.type === AST_NODE_TYPES.Identifier && left.name === "NaN" || VAR2.toStaticValue({ kind: "lazy", node: left, initialScope }).value === "NaN";
      if (isLeftNan) {
        return {
          messageId: "noLeakedConditionalRendering",
          node: left,
          data: { value: context.sourceCode.getText(left) }
        };
      }
      const leftType = getConstrainedTypeAtLocation(services, left);
      const leftTypeVariants = inspectVariantTypes(unionTypeParts(leftType));
      const isLeftValid = Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type));
      if (isLeftValid) {
        return getReportDescriptor(right);
      }
      return {
        messageId: "noLeakedConditionalRendering",
        node: left,
        data: { value: context.sourceCode.getText(left) }
      };
    }).with({ type: AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
      return getReportDescriptor(consequent) ?? getReportDescriptor(alternate);
    }).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
      const variable = VAR2.findVariable(n.name, context.sourceCode.getScope(n));
      const variableDefNode = variable?.defs.at(0)?.node;
      return match(variableDefNode).with({ init: P.select({ type: P.not(AST_NODE_TYPES.VariableDeclaration) }) }, getReportDescriptor).otherwise(() => _);
    }).otherwise(() => _);
  }
  return {
    JSXExpressionContainer: flow(getReportDescriptor, Reporter.make(context).send)
  };
}
var RULE_NAME31 = "no-missing-component-display-name";
var RULE_FEATURES31 = [];
var no_missing_component_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces that all components have a `displayName` which can be used in devtools.",
      [Symbol.for("rule_features")]: RULE_FEATURES31
    },
    messages: {
      noMissingComponentDisplayName: "Add missing 'displayName' for component."
    },
    schema: []
  },
  name: RULE_NAME31,
  create: create31,
  defaultOptions: []
});
function create31(context) {
  if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) return {};
  const {
    ctx,
    listeners
  } = ER25.useComponentCollector(
    context,
    {
      collectDisplayName: true,
      collectHookCalls: false,
      hint: ER25.DEFAULT_COMPONENT_DETECTION_HINT
    }
  );
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node, displayName, flag } of components.values()) {
        const isMemoOrForwardRef = (flag & (ER25.ComponentFlag.ForwardRef | ER25.ComponentFlag.Memo)) > 0n;
        if (AST8.getFunctionId(node) != null) {
          continue;
        }
        if (!isMemoOrForwardRef) {
          continue;
        }
        if (displayName == null) {
          const id = AST8.getFunctionId(node);
          context.report({
            messageId: "noMissingComponentDisplayName",
            node: id ?? node
          });
        }
      }
    }
  };
}
var RULE_NAME32 = "no-missing-context-display-name";
var RULE_FEATURES32 = [];
var no_missing_context_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces that all contexts have a `displayName` which can be used in devtools.",
      [Symbol.for("rule_features")]: RULE_FEATURES32
    },
    messages: {
      noMissingContextDisplayName: "Add missing 'displayName' for context."
    },
    schema: []
  },
  name: RULE_NAME32,
  create: create32,
  defaultOptions: []
});
function create32(context) {
  if (!context.sourceCode.text.includes("createContext")) return {};
  const createCalls = [];
  const displayNameAssignments = [];
  return {
    CallExpression(node) {
      if (!ER25.isCreateContextCall(context, node)) return;
      createCalls.push(node);
    },
    "Program:exit"() {
      for (const call of createCalls) {
        const id = ER25.getInstanceId(call);
        if (id == null) {
          context.report({
            messageId: "noMissingContextDisplayName",
            node: call
          });
          continue;
        }
        const hasDisplayNameAssignment = displayNameAssignments.some((node) => {
          const left = node.left;
          if (left.type !== AST_NODE_TYPES.MemberExpression) return false;
          const object = left.object;
          return ER25.isInstanceIdEqual(context, id, object);
        });
        if (!hasDisplayNameAssignment) {
          context.report({
            messageId: "noMissingContextDisplayName",
            node: id
          });
        }
      }
    },
    [Selector.DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
      displayNameAssignments.push(node);
    }
  };
}
var RULE_NAME33 = "no-missing-key";
var RULE_FEATURES33 = [];
var no_missing_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow missing `key` on items in list rendering.",
      [Symbol.for("rule_features")]: RULE_FEATURES33
    },
    messages: {
      missingKey: "Missing 'key' for element when rendering list.",
      unexpectedFragmentSyntax: "Use fragment component instead of '<>' because it does not support `key`."
    },
    schema: []
  },
  name: RULE_NAME33,
  create: create33,
  defaultOptions: []
});
function create33(context) {
  const report = Reporter.make(context);
  const state = { isWithinChildrenToArray: false };
  function checkIteratorElement(node) {
    switch (node.type) {
      case AST_NODE_TYPES.JSXElement: {
        const initialScope = context.sourceCode.getScope(node);
        if (!ER25.hasAttribute(context, "key", node.openingElement.attributes, initialScope)) {
          return {
            messageId: "missingKey",
            node
          };
        }
        return null;
      }
      case AST_NODE_TYPES.JSXFragment: {
        return {
          messageId: "unexpectedFragmentSyntax",
          node
        };
      }
      default:
        return null;
    }
  }
  function checkExpression(node) {
    switch (node.type) {
      case AST_NODE_TYPES.ConditionalExpression:
        if ("consequent" in node) {
          return checkIteratorElement(node.consequent) ?? checkIteratorElement(node.alternate);
        }
        return null;
      case AST_NODE_TYPES.JSXElement:
      case AST_NODE_TYPES.JSXFragment:
        return checkIteratorElement(node);
      case AST_NODE_TYPES.LogicalExpression:
        if ("left" in node) {
          return checkIteratorElement(node.left) ?? checkIteratorElement(node.right);
        }
        return null;
      default:
        return null;
    }
  }
  function checkBlockStatement(node) {
    const descriptors = [];
    for (const statement of AST8.getNestedReturnStatements(node)) {
      if (statement.argument == null) continue;
      const descriptor = checkIteratorElement(statement.argument);
      if (descriptor != null) descriptors.push(descriptor);
    }
    return descriptors;
  }
  return {
    ArrayExpression(node) {
      if (state.isWithinChildrenToArray) {
        return;
      }
      const elements = node.elements.filter(AST8.is(AST_NODE_TYPES.JSXElement));
      if (elements.length === 0) {
        return;
      }
      const initialScope = context.sourceCode.getScope(node);
      for (const element of elements) {
        if (!ER25.hasAttribute(context, "key", element.openingElement.attributes, initialScope)) {
          report.send({
            messageId: "missingKey",
            node: element
          });
        }
      }
    },
    CallExpression(node) {
      state.isWithinChildrenToArray ||= ER25.isChildrenToArrayCall(context, node);
      if (state.isWithinChildrenToArray) return;
      const callback = match(node).when(AST8.isArrayMapCall, (n) => n.arguments[0]).when(AST8.isArrayFromCall, (n) => n.arguments[1]).otherwise(() => null);
      if (!AST8.isFunction(callback)) return;
      const body = callback.body;
      if (body.type === AST_NODE_TYPES.BlockStatement) {
        checkBlockStatement(body).forEach(report.send);
        return;
      }
      report.send(checkExpression(body));
    },
    "CallExpression:exit"(node) {
      if (!ER25.isChildrenToArrayCall(context, node)) {
        return;
      }
      state.isWithinChildrenToArray = false;
    },
    JSXFragment(node) {
      if (state.isWithinChildrenToArray) {
        return;
      }
      if (node.parent.type === AST_NODE_TYPES.ArrayExpression) {
        report.send({
          messageId: "unexpectedFragmentSyntax",
          node
        });
      }
    }
  };
}
var RULE_NAME34 = "no-misused-capture-owner-stack";
var RULE_FEATURES34 = [
  "EXP"
];
var no_misused_capture_owner_stack_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents incorrect usage of `captureOwnerStack`.",
      [Symbol.for("rule_features")]: RULE_FEATURES34
    },
    fixable: "code",
    messages: {
      useNamespaceImport: "Don't use named imports of 'captureOwnerStack' in files that are bundled for development and production. Use a namespace import instead.",
      // eslint-disable-next-line perfectionist/sort-objects
      missingDevelopmentOnlyCheck: `Don't call 'captureOwnerStack' directly. Use 'if (process.env.NODE_ENV !== "production") {...}' to conditionally access it.`
    },
    schema: []
  },
  name: RULE_NAME34,
  create: create34,
  defaultOptions: []
});
function create34(context) {
  if (!context.sourceCode.text.includes("captureOwnerStack")) return {};
  const { importSource } = getSettingsFromContext(context);
  return {
    CallExpression(node) {
      if (!ER25.isCaptureOwnerStackCall(context, node)) return;
      if (AST8.findParentNode(node, isDevelopmentOnlyCheck) == null) {
        context.report({
          messageId: "missingDevelopmentOnlyCheck",
          node
        });
      }
    },
    ImportDeclaration(node) {
      if (node.source.value !== importSource) return;
      for (const specifier of node.specifiers) {
        if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
        if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
        if (specifier.imported.name === "captureOwnerStack") {
          context.report({
            messageId: "useNamespaceImport",
            node: specifier
          });
        }
      }
    }
  };
}
function isDevelopmentOnlyCheck(node) {
  if (node.type !== AST_NODE_TYPES.IfStatement) return false;
  if (AST8.isProcessEnvNodeEnvCompare(node.test, "!==", "production")) return true;
  return false;
}
var RULE_NAME35 = "no-nested-component-definitions";
var RULE_FEATURES35 = [];
var no_nested_component_definitions_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow nesting component definitions inside other components.",
      [Symbol.for("rule_features")]: RULE_FEATURES35
    },
    messages: {
      noNestedComponentDefinitions: "Do not nest component definitions inside other components or props. {{suggestion}}"
    },
    schema: []
  },
  name: RULE_NAME35,
  create: create35,
  defaultOptions: []
});
function create35(context) {
  const hint = ER25.ComponentDetectionHint.SkipArrayMapArgument | ER25.ComponentDetectionHint.SkipNullLiteral | ER25.ComponentDetectionHint.SkipUndefined | ER25.ComponentDetectionHint.SkipBooleanLiteral | ER25.ComponentDetectionHint.SkipStringLiteral | ER25.ComponentDetectionHint.SkipNumberLiteral | ER25.ComponentDetectionHint.StrictLogical | ER25.ComponentDetectionHint.StrictConditional;
  const collector = ER25.useComponentCollector(context, { hint });
  const collectorLegacy = ER25.useComponentCollectorLegacy();
  return {
    ...collector.listeners,
    ...collectorLegacy.listeners,
    "Program:exit"(program) {
      const functionComponents = [
        ...collector.ctx.getAllComponents(program).values()
      ];
      const classComponents = [
        ...collectorLegacy.ctx.getAllComponents(program).values()
      ];
      const isFunctionComponent = (node) => {
        return AST8.isFunction(node) && functionComponents.some((component) => component.node === node);
      };
      const isClassComponent12 = (node) => {
        return AST8.isClass(node) && classComponents.some((component) => component.node === node);
      };
      for (const { name: name5, node: component } of functionComponents) {
        if (name5 == null) continue;
        if (ER25.isDirectValueOfRenderPropertyLoose(component)) continue;
        if (isInsideJSXAttributeValue(component)) {
          if (!ER25.isDeclaredInRenderPropLoose(component)) {
            context.report({
              messageId: "noNestedComponentDefinitions",
              node: component,
              data: {
                name: name5,
                suggestion: "Move it to the top level or pass it as a prop."
              }
            });
          }
          continue;
        }
        if (isInsideCreateElementProps(context, component)) {
          context.report({
            messageId: "noNestedComponentDefinitions",
            node: component,
            data: {
              name: name5,
              suggestion: "Move it to the top level or pass it as a prop."
            }
          });
          continue;
        }
        const parentComponent = AST8.findParentNode(component, isFunctionComponent);
        if (parentComponent != null && !ER25.isDirectValueOfRenderPropertyLoose(parentComponent)) {
          context.report({
            messageId: "noNestedComponentDefinitions",
            node: component,
            data: {
              name: name5,
              suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
            }
          });
          continue;
        }
        if (ER25.isInsideRenderMethod(component)) {
          context.report({
            messageId: "noNestedComponentDefinitions",
            node: component,
            data: {
              name: name5,
              suggestion: "Move it to the top level."
            }
          });
        }
      }
      for (const { name: name5 = "unknown", node: component } of classComponents) {
        if (AST8.findParentNode(component, (n) => isClassComponent12(n) || isFunctionComponent(n)) == null) {
          continue;
        }
        context.report({
          messageId: "noNestedComponentDefinitions",
          node: component,
          data: {
            name: name5,
            suggestion: component.parent.type === AST_NODE_TYPES.Property ? "Move it to the top level or pass it as a prop." : "Move it to the top level."
          }
        });
      }
    }
  };
}
function isInsideJSXAttributeValue(node) {
  return node.parent.type === AST_NODE_TYPES.JSXAttribute || ER25.findParentAttribute(node, (n) => n.value?.type === AST_NODE_TYPES.JSXExpressionContainer) != null;
}
function isInsideCreateElementProps(context, node) {
  const call = AST8.findParentNode(node, ER25.isCreateElementCall(context));
  if (call == null) return false;
  const prop = AST8.findParentNode(node, AST8.is(AST_NODE_TYPES.ObjectExpression));
  if (prop == null) return false;
  return prop === call.arguments[1];
}
var RULE_NAME36 = "no-nested-component-definitions";
var RULE_FEATURES36 = [];
var no_nested_lazy_component_declarations_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow nesting lazy component declarations inside other components.",
      [Symbol.for("rule_features")]: RULE_FEATURES36
    },
    messages: {
      noNestedComponentDefinitions: "Do not declare lazy components inside other components. Instead, always declare them at the top level of your module."
    },
    schema: []
  },
  name: RULE_NAME36,
  create: create36,
  defaultOptions: []
});
function create36(context) {
  const hint = ER25.ComponentDetectionHint.None;
  const collector = ER25.useComponentCollector(context, { hint });
  const collectorLegacy = ER25.useComponentCollectorLegacy();
  const lazyComponentDeclarations = /* @__PURE__ */ new Set();
  return {
    ...collector.listeners,
    ...collectorLegacy.listeners,
    ImportExpression(node) {
      const lazyCall = AST8.findParentNode(node, (n) => ER25.isLazyCall(context, n));
      if (lazyCall != null) {
        lazyComponentDeclarations.add(lazyCall);
      }
    },
    "Program:exit"(program) {
      const functionComponents = [
        ...collector.ctx.getAllComponents(program).values()
      ];
      const classComponents = [
        ...collectorLegacy.ctx.getAllComponents(program).values()
      ];
      for (const lazy of lazyComponentDeclarations) {
        const significantParent = AST8.findParentNode(lazy, (n) => {
          if (AST8.isJSX(n)) return true;
          if (n.type === AST_NODE_TYPES.CallExpression) {
            return ER25.isReactHookCall(n) || ER25.isCreateElementCall(context, n) || ER25.isCreateContextCall(context, n);
          }
          if (AST8.isFunction(n)) {
            return functionComponents.some((c) => c.node === n);
          }
          if (AST8.isClass(n)) {
            return classComponents.some((c) => c.node === n);
          }
          return false;
        });
        if (significantParent != null) {
          context.report({
            messageId: "noNestedComponentDefinitions",
            node: lazy
          });
        }
      }
    }
  };
}
var RULE_NAME37 = "no-prop-types";
var RULE_FEATURES37 = [];
var no_prop_types_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `propTypes` in favor of TypeScript or another type-checking solution.",
      [Symbol.for("rule_features")]: RULE_FEATURES37
    },
    messages: {
      noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead."
    },
    schema: []
  },
  name: RULE_NAME37,
  create: create37,
  defaultOptions: []
});
function create37(context) {
  if (!context.sourceCode.text.includes("propTypes")) {
    return {};
  }
  return {
    AssignmentExpression(node) {
      if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) {
        return;
      }
      const { object, property } = node.left;
      if (object.type !== AST_NODE_TYPES.Identifier) {
        return;
      }
      if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "propTypes") {
        return;
      }
      if (!ER25.isComponentNameLoose(object.name)) {
        return;
      }
      const variable = VAR2.findVariable(object.name, context.sourceCode.getScope(node));
      const variableNode = VAR2.getVariableInitNode(variable, 0);
      if (variableNode != null && (AST8.isFunction(variableNode) || ER25.isClassComponent(variableNode))) {
        context.report({ messageId: "noPropTypes", node: property });
      }
    },
    PropertyDefinition(node) {
      if (!ER25.isClassComponent(node.parent.parent)) {
        return;
      }
      if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") {
        return;
      }
      context.report({ messageId: "noPropTypes", node });
    }
  };
}
var RULE_NAME38 = "no-redundant-should-component-update";
var RULE_FEATURES38 = [];
function isShouldComponentUpdate(node) {
  return AST8.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow `shouldComponentUpdate` when extending `React.PureComponent`.",
      [Symbol.for("rule_features")]: RULE_FEATURES38
    },
    messages: {
      noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'."
    },
    schema: []
  },
  name: RULE_NAME38,
  create: create38,
  defaultOptions: []
});
function create38(context) {
  if (!context.sourceCode.text.includes("shouldComponentUpdate")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { name: name5 = "PureComponent", node: component, flag } of components.values()) {
        if ((flag & ER25.ComponentFlag.PureComponent) === 0n) {
          continue;
        }
        const { body } = component.body;
        for (const member of body) {
          if (isShouldComponentUpdate(member)) {
            context.report({
              messageId: "noRedundantShouldComponentUpdate",
              node: member,
              data: {
                componentName: name5
              }
            });
          }
        }
      }
    }
  };
}
var RULE_NAME39 = "no-set-state-in-component-did-mount";
var RULE_FEATURES39 = [];
var no_set_state_in_component_did_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow calling `this.setState` in `componentDidMount` outside of functions, such as callbacks.",
      [Symbol.for("rule_features")]: RULE_FEATURES39
    },
    messages: {
      noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME39,
  create: create39,
  defaultOptions: []
});
function create39(context) {
  if (!context.sourceCode.text.includes("componentDidMount")) return {};
  return {
    CallExpression(node) {
      if (!ER25.isThisSetState(node)) {
        return;
      }
      const clazz = AST8.findParentNode(node, ER25.isClassComponent);
      const method = AST8.findParentNode(node, (n) => n === clazz || ER25.isComponentDidMount(n));
      if (clazz == null || method == null || method === clazz) return;
      const methodScope = context.sourceCode.getScope(method);
      const upperScope = context.sourceCode.getScope(node).upper;
      if (method.parent === clazz.body && upperScope === methodScope) {
        context.report({
          messageId: "noSetStateInComponentDidMount",
          node
        });
      }
    }
  };
}
var RULE_NAME40 = "no-set-state-in-component-did-update";
var RULE_FEATURES40 = [];
var no_set_state_in_component_did_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow calling `this.setState` in `componentDidUpdate` outside of functions, such as callbacks.",
      [Symbol.for("rule_features")]: RULE_FEATURES40
    },
    messages: {
      noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME40,
  create: create40,
  defaultOptions: []
});
function create40(context) {
  if (!context.sourceCode.text.includes("componentDidUpdate")) return {};
  return {
    CallExpression(node) {
      if (!ER25.isThisSetState(node)) {
        return;
      }
      const clazz = AST8.findParentNode(node, ER25.isClassComponent);
      const method = AST8.findParentNode(node, (n) => n === clazz || ER25.isComponentDidUpdate(n));
      if (clazz == null || method == null || method === clazz) return;
      const methodScope = context.sourceCode.getScope(method);
      const upperScope = context.sourceCode.getScope(node).upper;
      if (method.parent === clazz.body && upperScope === methodScope) {
        context.report({
          messageId: "noSetStateInComponentDidUpdate",
          node
        });
      }
    }
  };
}
var RULE_NAME41 = "no-set-state-in-component-will-update";
var RULE_FEATURES41 = [];
var no_set_state_in_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallows calling `this.setState` in `componentWillUpdate` outside of functions, such as callbacks.",
      [Symbol.for("rule_features")]: RULE_FEATURES41
    },
    messages: {
      noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME41,
  create: create41,
  defaultOptions: []
});
function create41(context) {
  if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
  return {
    CallExpression(node) {
      if (!ER25.isThisSetState(node)) {
        return;
      }
      const clazz = AST8.findParentNode(node, ER25.isClassComponent);
      const method = AST8.findParentNode(node, (n) => n === clazz || ER25.isComponentWillUpdate(n));
      if (clazz == null || method == null || method === clazz) return;
      const methodScope = context.sourceCode.getScope(method);
      const upperScope = context.sourceCode.getScope(node).upper;
      if (method.parent === clazz.body && upperScope === methodScope) {
        context.report({
          messageId: "noSetStateInComponentWillUpdate",
          node
        });
      }
    }
  };
}
var RULE_NAME42 = "no-string-refs";
var RULE_FEATURES42 = [
  "MOD"
];
var no_string_refs_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replaces string refs with callback refs.",
      [Symbol.for("rule_features")]: RULE_FEATURES42
    },
    fixable: "code",
    messages: {
      noStringRefs: "[Deprecated] Use callback refs instead."
    },
    schema: []
  },
  name: RULE_NAME42,
  create: create42,
  defaultOptions: []
});
function create42(context) {
  const state = {
    isWithinClassComponent: false
  };
  function onClassBodyEnter(node) {
    if (ER25.isClassComponent(node.parent)) {
      state.isWithinClassComponent = true;
    }
  }
  function onClassBodyExit() {
    state.isWithinClassComponent = false;
  }
  return {
    ClassBody: onClassBodyEnter,
    "ClassBody:exit": onClassBodyExit,
    JSXAttribute(node) {
      if (node.name.name !== "ref") return;
      const refNameText = getAttributeValueText(context, node.value);
      if (refNameText == null) return;
      context.report({
        messageId: "noStringRefs",
        node,
        fix(fixer) {
          if (node.value == null) return null;
          if (!state.isWithinClassComponent) return null;
          return fixer.replaceText(node.value, `{(ref) => { this.refs[${refNameText}] = ref; }}`);
        }
      });
    }
  };
}
function getAttributeValueText(context, node) {
  if (node == null) return null;
  switch (true) {
    case (node.type === AST_NODE_TYPES.Literal && typeof node.value === "string"):
      return context.sourceCode.getText(node);
    case (node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.Literal && typeof node.expression.value === "string"):
      return context.sourceCode.getText(node.expression);
    case (node.type === AST_NODE_TYPES.JSXExpressionContainer && node.expression.type === AST_NODE_TYPES.TemplateLiteral):
      return context.sourceCode.getText(node.expression);
    default:
      return null;
  }
}
var RULE_NAME43 = "no-unsafe-component-will-mount";
var RULE_FEATURES43 = [];
function isUnsafeComponentWillMount(node) {
  return AST8.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
var no_unsafe_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Warns the usage of `UNSAFE_componentWillMount` in class components.",
      [Symbol.for("rule_features")]: RULE_FEATURES43
    },
    messages: {
      noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'."
    },
    schema: []
  },
  name: RULE_NAME43,
  create: create43,
  defaultOptions: []
});
function create43(context) {
  if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (isUnsafeComponentWillMount(member)) {
            context.report({
              messageId: "noUnsafeComponentWillMount",
              node: member
            });
          }
        }
      }
    }
  };
}
var RULE_NAME44 = "no-unsafe-component-will-receive-props";
var RULE_FEATURES44 = [];
function isUnsafeComponentWillReceiveProps(node) {
  return AST8.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
var no_unsafe_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Warns the usage of `UNSAFE_componentWillReceiveProps` in class components.",
      [Symbol.for("rule_features")]: RULE_FEATURES44
    },
    messages: {
      noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'."
    },
    schema: []
  },
  name: RULE_NAME44,
  create: create44,
  defaultOptions: []
});
function create44(context) {
  if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) {
    return {};
  }
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (isUnsafeComponentWillReceiveProps(member)) {
            context.report({
              messageId: "noUnsafeComponentWillReceiveProps",
              node: member
            });
          }
        }
      }
    }
  };
}
var RULE_NAME45 = "no-unsafe-component-will-update";
var RULE_FEATURES45 = [];
function isUnsafeComponentWillUpdate(node) {
  return AST8.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
var no_unsafe_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Warns the usage of `UNSAFE_componentWillUpdate` in class components.",
      [Symbol.for("rule_features")]: RULE_FEATURES45
    },
    messages: {
      noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'."
    },
    schema: []
  },
  name: RULE_NAME45,
  create: create45,
  defaultOptions: []
});
function create45(context) {
  if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) return {};
  const { ctx, listeners } = ER25.useComponentCollectorLegacy();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { body } = component.body;
        for (const member of body) {
          if (isUnsafeComponentWillUpdate(member)) {
            context.report({
              messageId: "noUnsafeComponentWillUpdate",
              node: member
            });
          }
        }
      }
    }
  };
}
var RULE_NAME46 = "no-unstable-context-value";
var RULE_FEATURES46 = [];
var no_unstable_context_value_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents non-stable values (i.e. object literals) from being used as a value for `Context.Provider`.",
      [Symbol.for("rule_features")]: RULE_FEATURES46
    },
    messages: {
      unstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. {{suggestion}}"
    },
    schema: []
  },
  name: RULE_NAME46,
  create: create46,
  defaultOptions: []
});
function create46(context) {
  const { version: version2 } = getSettingsFromContext(context);
  const isReact18OrBelow = compare(version2, "19.0.0", "<");
  const { ctx, listeners } = ER25.useComponentCollector(context);
  const constructions = /* @__PURE__ */ new WeakMap();
  return {
    ...listeners,
    JSXOpeningElement(node) {
      const fullName = ER25.getElementType(context, node.parent);
      const selfName = fullName.split(".").at(-1);
      if (selfName == null) return;
      if (!isContextName(selfName, isReact18OrBelow)) return;
      const functionEntry = ctx.getCurrentEntry();
      if (functionEntry == null) return;
      const attribute = node.attributes.find(
        (attribute2) => attribute2.type === AST_NODE_TYPES.JSXAttribute && attribute2.name.name === "value"
      );
      if (attribute == null || !("value" in attribute)) return;
      const value = attribute.value;
      if (value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
      const valueExpression = value.expression;
      const initialScope = context.sourceCode.getScope(valueExpression);
      const construction = VAR2.getConstruction(valueExpression, initialScope);
      if (construction == null) return;
      if (ER25.isReactHookCall(construction.node)) {
        return;
      }
      getOrElseUpdate(constructions, functionEntry.node, () => []).push(construction);
    },
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program).values();
      for (const { node: component } of components) {
        for (const construction of constructions.get(component) ?? []) {
          const { kind, node: constructionNode } = construction;
          const suggestion = kind.startsWith("Function") ? "Consider wrapping it in a useCallback hook." : "Consider wrapping it in a useMemo hook.";
          context.report({
            messageId: "unstableContextValue",
            node: constructionNode,
            data: {
              type: AST8.toDelimiterCaseType(constructionNode),
              suggestion
            }
          });
        }
      }
    }
  };
}
function isContextName(name5, isReact18OrBelow) {
  if (name5 === "Provider") return true;
  if (!isReact18OrBelow) {
    return name5.endsWith("Context") || name5.endsWith("CONTEXT");
  }
  return false;
}
var RULE_NAME47 = "no-unstable-default-props";
var RULE_FEATURES47 = [];
var no_unstable_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Prevents using referential-type values as default props in object destructuring.",
      [Symbol.for("rule_features")]: RULE_FEATURES47
    },
    messages: {
      noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'."
    },
    schema: []
  },
  name: RULE_NAME47,
  create: create47,
  defaultOptions: []
});
function create47(context) {
  const { ctx, listeners } = ER25.useComponentCollector(context);
  const declarators = /* @__PURE__ */ new WeakMap();
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const { node: component } of components.values()) {
        const { params } = component;
        const [props] = params;
        if (props == null) {
          continue;
        }
        const properties = match(props).with({ type: AST_NODE_TYPES.ObjectPattern }, ({ properties: properties2 }) => properties2).with({ type: AST_NODE_TYPES.Identifier }, ({ name: name5 }) => {
          return declarators.get(component)?.filter((d) => d.init.name === name5).flatMap((d) => d.id.properties) ?? [];
        }).otherwise(() => []);
        for (const prop of properties) {
          if (prop.type !== AST_NODE_TYPES.Property || prop.value.type !== AST_NODE_TYPES.AssignmentPattern) {
            continue;
          }
          const { value } = prop;
          const { right } = value;
          const initialScope = context.sourceCode.getScope(value);
          const construction = VAR2.getConstruction(
            value,
            initialScope,
            VAR2.ConstructionDetectionHint.StrictCallExpression
          );
          if (construction == null) {
            continue;
          }
          if (ER25.isReactHookCall(construction.node)) {
            continue;
          }
          const forbiddenType = AST8.toDelimiterCaseType(right);
          context.report({
            messageId: "noUnstableDefaultProps",
            node: right,
            data: {
              forbiddenType
            }
          });
        }
      }
    },
    [Selector.OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR](node) {
      const functionEntry = ctx.getCurrentEntry();
      if (functionEntry == null) return;
      getOrElseUpdate(
        declarators,
        functionEntry.node,
        () => []
      ).push(node);
    }
  };
}
var RULE_NAME48 = "no-unused-class-component-members";
var RULE_FEATURES48 = [];
var LIFECYCLE_METHODS = /* @__PURE__ */ new Set([
  "componentDidCatch",
  "componentDidMount",
  "componentDidUpdate",
  "componentWillMount",
  "componentWillReceiveProps",
  "componentWillUnmount",
  "componentWillUpdate",
  "constructor",
  "getSnapshotBeforeUpdate",
  "render",
  "shouldComponentUpdate",
  "state",
  "UNSAFE_componentWillMount",
  "UNSAFE_componentWillReceiveProps",
  "UNSAFE_componentWillUpdate"
]);
function isKeyLiteral2(node, key) {
  return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({ type: AST_NODE_TYPES.TemplateLiteral, expressions: [] }, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_class_component_members_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Warns unused class component methods and properties.",
      [Symbol.for("rule_features")]: RULE_FEATURES48
    },
    messages: {
      noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'."
    },
    schema: []
  },
  name: RULE_NAME48,
  create: create48,
  defaultOptions: []
});
function create48(context) {
  const classEntries = [];
  const methodEntries = [];
  const propertyDefs = /* @__PURE__ */ new WeakMap();
  const propertyUsages = /* @__PURE__ */ new WeakMap();
  function classEnter(node) {
    classEntries.push(node);
    if (!ER25.isClassComponent(node)) {
      return;
    }
    propertyDefs.set(node, /* @__PURE__ */ new Set());
    propertyUsages.set(node, /* @__PURE__ */ new Set());
  }
  function classExit() {
    const currentClass = classEntries.pop();
    if (currentClass == null || !ER25.isClassComponent(currentClass)) {
      return;
    }
    const className = AST8.getClassId(currentClass)?.name;
    const defs = propertyDefs.get(currentClass);
    const usages = propertyUsages.get(currentClass);
    if (defs == null) {
      return;
    }
    for (const def of defs) {
      const methodName = AST8.getPropertyName(def);
      if (methodName == null) {
        continue;
      }
      if (usages?.has(methodName) || LIFECYCLE_METHODS.has(methodName)) {
        continue;
      }
      context.report({
        messageId: "noUnusedClassComponentMembers",
        node: def,
        data: {
          className: className ?? "Component",
          methodName
        }
      });
    }
  }
  function methodEnter(node) {
    methodEntries.push(node);
    const currentClass = classEntries.at(-1);
    if (currentClass == null || !ER25.isClassComponent(currentClass)) {
      return;
    }
    if (node.static) {
      return;
    }
    if (isKeyLiteral2(node, node.key)) {
      propertyDefs.get(currentClass)?.add(node.key);
    }
  }
  function methodExit() {
    methodEntries.pop();
  }
  return {
    ClassDeclaration: classEnter,
    "ClassDeclaration:exit": classExit,
    ClassExpression: classEnter,
    "ClassExpression:exit": classExit,
    MemberExpression(node) {
      const currentClass = classEntries.at(-1);
      const currentMethod = methodEntries.at(-1);
      if (currentClass == null || currentMethod == null) {
        return;
      }
      if (!ER25.isClassComponent(currentClass) || currentMethod.static) {
        return;
      }
      if (!AST8.isThisExpression(node.object) || !isKeyLiteral2(node, node.property)) {
        return;
      }
      if (node.parent.type === AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
        propertyDefs.get(currentClass)?.add(node.property);
        return;
      }
      const propertyName = AST8.getPropertyName(node.property);
      if (propertyName != null) {
        propertyUsages.get(currentClass)?.add(propertyName);
      }
    },
    MethodDefinition: methodEnter,
    "MethodDefinition:exit": methodExit,
    PropertyDefinition: methodEnter,
    "PropertyDefinition:exit": methodExit,
    VariableDeclarator(node) {
      const currentClass = classEntries.at(-1);
      const currentMethod = methodEntries.at(-1);
      if (currentClass == null || currentMethod == null) {
        return;
      }
      if (!ER25.isClassComponent(currentClass) || currentMethod.static) {
        return;
      }
      if (node.init != null && AST8.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern) {
        for (const prop of node.id.properties) {
          if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral2(prop, prop.key)) {
            const keyName = AST8.getPropertyName(prop.key);
            if (keyName != null) {
              propertyUsages.get(currentClass)?.add(keyName);
            }
          }
        }
      }
    }
  };
}
var RULE_NAME49 = "no-unused-state";
var RULE_FEATURES49 = [];
function isKeyLiteral3(node, key) {
  return match(key).with({ type: AST_NODE_TYPES.Literal }, constTrue).with({ type: AST_NODE_TYPES.TemplateLiteral, expressions: [] }, constTrue).with({ type: AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(constFalse);
}
var no_unused_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Warns unused class component state.",
      [Symbol.for("rule_features")]: RULE_FEATURES49
    },
    messages: {
      noUnusedState: "Unused class component state in '{{className}}'"
    },
    schema: []
  },
  name: RULE_NAME49,
  create: create49,
  defaultOptions: []
});
function create49(context) {
  const classEntries = [];
  const methodEntries = [];
  const constructorEntries = [];
  const stateDefs = /* @__PURE__ */ new WeakMap();
  function classEnter(node) {
    classEntries.push(node);
  }
  function classExit() {
    const currentClass = classEntries.pop();
    if (currentClass == null || !ER25.isClassComponent(currentClass)) {
      return;
    }
    const className = AST8.getClassId(currentClass)?.name;
    const { node: defNode, isUsed = false } = stateDefs.get(currentClass) ?? {};
    if (defNode == null || isUsed) {
      return;
    }
    context.report({
      messageId: "noUnusedState",
      node: defNode,
      data: {
        className: className ?? "Component"
      }
    });
  }
  function methodEnter(node) {
    methodEntries.push(node);
    const currentClass = classEntries.at(-1);
    if (currentClass == null || !ER25.isClassComponent(currentClass)) {
      return;
    }
    if (node.static) {
      if (ER25.isGetDerivedStateFromProps(node) && isMatching({ params: [P.nonNullable, ...P.array()] })(node.value)) {
        const defNode = stateDefs.get(currentClass)?.node;
        stateDefs.set(currentClass, { node: defNode, isUsed: true });
      }
      return;
    }
    if (AST8.getPropertyName(node.key) === "state") {
      stateDefs.set(currentClass, { node: node.key, isUsed: false });
    }
  }
  function methodExit() {
    methodEntries.pop();
  }
  function constructorEnter(node) {
    constructorEntries.push(node);
  }
  function constructorExit() {
    constructorEntries.pop();
  }
  return {
    AssignmentExpression(node) {
      if (!ER25.isAssignmentToThisState(node)) {
        return;
      }
      const currentClass = classEntries.at(-1);
      if (currentClass == null || !ER25.isClassComponent(currentClass)) {
        return;
      }
      const currentConstructor = constructorEntries.at(-1);
      if (currentConstructor == null || !currentClass.body.body.includes(currentConstructor)) {
        return;
      }
      const isUsed = stateDefs.get(currentClass)?.isUsed ?? false;
      stateDefs.set(currentClass, { node: node.left, isUsed });
    },
    ClassDeclaration: classEnter,
    "ClassDeclaration:exit": classExit,
    ClassExpression: classEnter,
    "ClassExpression:exit": classExit,
    MemberExpression(node) {
      if (!AST8.isThisExpression(node.object)) {
        return;
      }
      if (AST8.getPropertyName(node.property) !== "state") {
        return;
      }
      const currentClass = classEntries.at(-1);
      if (currentClass == null || !ER25.isClassComponent(currentClass)) {
        return;
      }
      const currentMethod = methodEntries.at(-1);
      if (currentMethod == null || currentMethod.static) {
        return;
      }
      if (currentMethod === constructorEntries.at(-1)) {
        return;
      }
      if (!currentClass.body.body.includes(currentMethod)) {
        return;
      }
      const defNode = stateDefs.get(currentClass)?.node;
      stateDefs.set(currentClass, { node: defNode, isUsed: true });
    },
    MethodDefinition: methodEnter,
    "MethodDefinition:exit": methodExit,
    "MethodDefinition[key.name='constructor']": constructorEnter,
    "MethodDefinition[key.name='constructor']:exit": constructorExit,
    PropertyDefinition: methodEnter,
    "PropertyDefinition:exit": methodExit,
    VariableDeclarator(node) {
      const currentClass = classEntries.at(-1);
      if (currentClass == null || !ER25.isClassComponent(currentClass)) {
        return;
      }
      const currentMethod = methodEntries.at(-1);
      if (currentMethod == null || currentMethod.static) {
        return;
      }
      if (currentMethod === constructorEntries.at(-1)) {
        return;
      }
      if (!currentClass.body.body.includes(currentMethod)) {
        return;
      }
      if (node.init == null || !AST8.isThisExpression(node.init) || node.id.type !== AST_NODE_TYPES.ObjectPattern) {
        return;
      }
      const hasState = node.id.properties.some((prop) => {
        if (prop.type === AST_NODE_TYPES.Property && isKeyLiteral3(prop, prop.key)) {
          return AST8.getPropertyName(prop.key) === "state";
        }
        return false;
      });
      if (!hasState) {
        return;
      }
      const defNode = stateDefs.get(currentClass)?.node;
      stateDefs.set(currentClass, { node: defNode, isUsed: true });
    }
  };
}
var RULE_NAME50 = "no-use-context";
var RULE_FEATURES50 = [
  "MOD"
];
var no_use_context_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Replaces usages of `useContext` with `use`.",
      [Symbol.for("rule_features")]: RULE_FEATURES50
    },
    fixable: "code",
    messages: {
      noUseContext: "In React 19, 'use' is preferred over 'useContext' because it is more flexible."
    },
    schema: []
  },
  name: RULE_NAME50,
  create: create50,
  defaultOptions: []
});
function create50(context) {
  if (!context.sourceCode.text.includes("useContext")) return {};
  const settings4 = getSettingsFromContext(context);
  if (compare(settings4.version, "19.0.0", "<")) {
    return {};
  }
  const useContextNames = /* @__PURE__ */ new Set();
  const hookCalls = /* @__PURE__ */ new Set();
  return {
    CallExpression(node) {
      if (!ER25.isReactHookCall(node)) {
        return;
      }
      hookCalls.add(node);
    },
    ImportDeclaration(node) {
      if (node.source.value !== settings4.importSource) {
        return;
      }
      const isUseImported = node.specifiers.some(isMatching({ local: { type: AST_NODE_TYPES.Identifier, name: "use" } }));
      for (const specifier of node.specifiers) {
        if (specifier.type !== AST_NODE_TYPES.ImportSpecifier) continue;
        if (specifier.imported.type !== AST_NODE_TYPES.Identifier) continue;
        if (specifier.imported.name === "useContext") {
          if (specifier.local.name !== "useContext") {
            useContextNames.add(specifier.local.name);
          }
          context.report({
            messageId: "noUseContext",
            node: specifier,
            fix(fixer) {
              if (isUseImported) {
                const tokenBefore = context.sourceCode.getTokenBefore(specifier);
                return [
                  fixer.remove(specifier),
                  ...tokenBefore?.value === "," ? [fixer.replaceTextRange([tokenBefore.range[1], specifier.range[0]], "")] : [],
                  ...getCorrelativeTokens(
                    context,
                    specifier
                  ).map((token) => fixer.remove(token))
                ];
              }
              return fixer.replaceText(specifier.imported, "use");
            }
          });
        }
      }
    },
    "Program:exit"() {
      const isUseContextCall = ER25.isReactHookCallWithNameAlias(context, "useContext", [...useContextNames]);
      for (const node of hookCalls) {
        if (!isUseContextCall(node)) {
          continue;
        }
        context.report({
          messageId: "noUseContext",
          node: node.callee,
          fix(fixer) {
            switch (node.callee.type) {
              case AST_NODE_TYPES.Identifier:
                return fixer.replaceText(node.callee, "use");
              case AST_NODE_TYPES.MemberExpression:
                return fixer.replaceText(node.callee.property, "use");
            }
            return null;
          }
        });
      }
    }
  };
}
function getCorrelativeTokens(context, node) {
  const tokenBefore = context.sourceCode.getTokenBefore(node);
  const tokenAfter = context.sourceCode.getTokenAfter(node);
  const tokens = [];
  if (tokenAfter?.value !== "," && tokenBefore?.value === ",") {
    tokens.push(tokenBefore);
  }
  if (tokenAfter?.value === ",") {
    tokens.push(tokenAfter);
  }
  return tokens;
}
var RULE_NAME51 = "no-useless-forward-ref";
var RULE_FEATURES51 = [];
var no_useless_forward_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Disallow useless `forwardRef` calls on components that don't use `ref`s.",
      [Symbol.for("rule_features")]: RULE_FEATURES51
    },
    messages: {
      noUselessForwardRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set."
    },
    schema: []
  },
  name: RULE_NAME51,
  create: create51,
  defaultOptions: []
});
function create51(context) {
  return {
    CallExpression(node) {
      if (!ER25.isForwardRefCall(context, node)) {
        return;
      }
      const [component] = node.arguments;
      if (component == null || !AST8.isFunction(component)) {
        return;
      }
      const ref = component.params[1];
      if (ref != null) {
        return;
      }
      context.report({
        messageId: "noUselessForwardRef",
        node: node.callee
      });
    }
  };
}
var RULE_NAME52 = "no-useless-fragment";
var defaultOptions = [{
  allowExpressions: true
}];
var no_useless_fragment_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions],
    docs: {
      description: "Disallow useless fragment elements."
    },
    fixable: "code",
    messages: {
      uselessFragment: "A fragment {{reason}} is useless."
    },
    schema: [{
      type: "object",
      additionalProperties: false,
      properties: {
        allowExpressions: {
          type: "boolean",
          description: "Allow fragments with a single expression child"
        }
      }
    }]
  },
  name: RULE_NAME52,
  create: create52,
  defaultOptions
});
function create52(context, [option]) {
  const { allowExpressions = true } = option;
  return {
    JSXElement(node) {
      if (!ER25.isFragmentElement(context, node)) return;
      checkNode(context, node, allowExpressions);
    },
    JSXFragment(node) {
      checkNode(context, node, allowExpressions);
    }
  };
}
function isWhiteSpace(node) {
  return typeof node.value === "string" && node.raw.trim() === "";
}
function isPaddingSpaces(node) {
  return ER25.isJsxText(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
function trimLikeReact(text) {
  const leadingSpaces = /^\s*/.exec(text)?.[0] ?? "";
  const trailingSpaces = /\s*$/.exec(text)?.[0] ?? "";
  const start = leadingSpaces.includes("\n") ? leadingSpaces.length : 0;
  const end = trailingSpaces.includes("\n") ? text.length - trailingSpaces.length : text.length;
  return text.slice(start, end);
}
function checkNode(context, node, allowExpressions) {
  const initialScope = context.sourceCode.getScope(node);
  if (ER25.isKeyedElement(context, node, initialScope)) {
    return;
  }
  if (ER25.isHostElement(context, node.parent)) {
    context.report({
      messageId: "uselessFragment",
      node,
      data: {
        reason: "placed inside a host component"
      },
      fix: getFix2(context, node)
    });
  }
  if (node.children.length === 0) {
    context.report({
      messageId: "uselessFragment",
      node,
      data: {
        reason: "contains less than two children"
      },
      fix: getFix2(context, node)
    });
    return;
  }
  const isChildElement = AST8.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent);
  switch (true) {
    // <Foo content={<>ee eeee eeee ...</>} />
    case (allowExpressions && !isChildElement && node.children.length === 1 && ER25.isJsxText(node.children.at(0))): {
      return;
    }
    // <Foo><>hello, world</></Foo>
    case (!allowExpressions && isChildElement): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix: getFix2(context, node)
      });
      return;
    }
    case (!allowExpressions && !isChildElement && node.children.length === 1): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix: getFix2(context, node)
      });
      return;
    }
  }
  const nonPaddingChildren = node.children.filter((child) => !isPaddingSpaces(child));
  const firstNonPaddingChild = nonPaddingChildren.at(0);
  switch (true) {
    case nonPaddingChildren.length === 0:
    case (nonPaddingChildren.length === 1 && firstNonPaddingChild?.type !== AST_NODE_TYPES.JSXExpressionContainer): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix: getFix2(context, node)
      });
      return;
    }
  }
  return;
}
function getFix2(context, node) {
  if (!canFix(context, node)) return null;
  return (fixer) => {
    const opener = node.type === AST_NODE_TYPES.JSXFragment ? node.openingFragment : node.openingElement;
    const closer = node.type === AST_NODE_TYPES.JSXFragment ? node.closingFragment : node.closingElement;
    const childrenText = opener.type === AST_NODE_TYPES.JSXOpeningElement && opener.selfClosing ? "" : context.sourceCode.getText().slice(opener.range[1], closer?.range[0]);
    return fixer.replaceText(node, trimLikeReact(childrenText));
  };
}
function canFix(context, node) {
  if (node.parent.type === AST_NODE_TYPES.JSXElement || node.parent.type === AST_NODE_TYPES.JSXFragment) {
    return ER25.isHostElement(context, node.parent);
  }
  if (node.children.length === 0) {
    return false;
  }
  if (node.children.some((child) => ER25.isJsxText(child) && !isWhiteSpace(child) || AST8.is(AST_NODE_TYPES.JSXExpressionContainer)(child))) {
    return false;
  }
  return true;
}
var RULE_NAME53 = "prefer-destructuring-assignment";
var RULE_FEATURES52 = [];
function isMemberExpressionWithObjectName(node) {
  return node.object.type === AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces destructuring assignment for component props and context.",
      [Symbol.for("rule_features")]: RULE_FEATURES52
    },
    messages: {
      preferDestructuringAssignment: "Use destructuring assignment for {{name}}."
    },
    schema: []
  },
  name: RULE_NAME53,
  create: create53,
  defaultOptions: []
});
function create53(context) {
  const { ctx, listeners } = ER25.useComponentCollector(context);
  const memberExpressionWithNames = [];
  return {
    ...listeners,
    MemberExpression(node) {
      if (isMemberExpressionWithObjectName(node)) {
        const scope = context.sourceCode.getScope(node);
        memberExpressionWithNames.push([scope, node]);
      }
    },
    "Program:exit"(program) {
      const components = [
        ...ctx.getAllComponents(program).values()
      ];
      function isFunctionComponent(block) {
        if (!AST8.isFunction(block)) {
          return false;
        }
        const id = AST8.getFunctionId(block);
        return id != null && ER25.isComponentNameLoose(id.name) && components.some((component) => component.node === block);
      }
      for (const [initialScope, memberExpression] of memberExpressionWithNames) {
        let scope = initialScope;
        let isComponent = isFunctionComponent(scope.block);
        while (!isComponent && scope.upper != null && scope.upper !== scope) {
          scope = scope.upper;
          isComponent = isFunctionComponent(scope.block);
        }
        if (!isComponent) {
          continue;
        }
        const component = scope.block;
        if (!("params" in component)) {
          continue;
        }
        const [props, ctx2] = component.params;
        const isMatch = (node) => node != null && node.type === AST_NODE_TYPES.Identifier && node.name === memberExpression.object.name;
        if (isMatch(props)) {
          context.report({
            messageId: "preferDestructuringAssignment",
            node: memberExpression,
            data: {
              name: "props"
            }
          });
        }
        if (isMatch(ctx2)) {
          context.report({
            messageId: "preferDestructuringAssignment",
            node: memberExpression,
            data: {
              name: "context"
            }
          });
        }
      }
    }
  };
}
var RULE_NAME54 = "prefer-react-namespace-import";
var RULE_FEATURES53 = [
  "FIX"
];
var prefer_react_namespace_import_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces React is imported via a namespace import.",
      [Symbol.for("rule_features")]: RULE_FEATURES53
    },
    fixable: "code",
    messages: {
      preferReactNamespaceImport: `Prefer importing React as 'import * as React from "{{importSource}}"';`
    },
    schema: []
  },
  name: RULE_NAME54,
  create: create54,
  defaultOptions: []
});
function create54(context) {
  const { importSource } = getSettingsFromContext(context);
  return {
    [`ImportDeclaration[source.value="${importSource}"] ImportDefaultSpecifier`](node) {
      const hasOtherSpecifiers = node.parent.specifiers.length > 1;
      context.report({
        messageId: "preferReactNamespaceImport",
        node: hasOtherSpecifiers ? node : node.parent,
        data: { importSource },
        fix(fixer) {
          const importDeclarationText = context.sourceCode.getText(node.parent);
          const semi = importDeclarationText.endsWith(";") ? ";" : "";
          const quote = node.parent.source.raw.at(0) ?? "'";
          const isTypeImport = node.parent.importKind === "type";
          const importStringPrefix = `import${isTypeImport ? " type" : ""}`;
          const importSourceQuoted = `${quote}${importSource}${quote}`;
          if (!hasOtherSpecifiers) {
            return fixer.replaceText(
              node.parent,
              `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`
            );
          }
          const specifiers = importDeclarationText.slice(importDeclarationText.indexOf("{"), importDeclarationText.indexOf("}") + 1);
          return fixer.replaceText(
            node.parent,
            [
              `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semi}`,
              `${importStringPrefix} ${specifiers} from ${importSourceQuoted}${semi}`
            ].join("\n")
          );
        }
      });
    }
  };
}
var RULE_NAME55 = "prefer-read-only-props";
var RULE_FEATURES54 = [
  "TSC",
  "EXP"
];
var prefer_read_only_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces read-only props in components.",
      [Symbol.for("rule_features")]: RULE_FEATURES54
    },
    messages: {
      preferReadOnlyProps: "A function component's props should be read-only."
    },
    schema: []
  },
  name: RULE_NAME55,
  create: create55,
  defaultOptions: []
});
function create55(context) {
  const services = ESLintUtils.getParserServices(context, false);
  const { ctx, listeners } = ER25.useComponentCollector(context);
  return {
    ...listeners,
    "Program:exit"(program) {
      const components = ctx.getAllComponents(program);
      for (const [, component] of components) {
        const [props] = component.node.params;
        if (props == null) {
          continue;
        }
        const propsType = getConstrainedTypeAtLocation(services, props);
        if (isTypeReadonlyLoose(services, propsType)) {
          continue;
        }
        context.report({ messageId: "preferReadOnlyProps", node: props });
      }
    }
  };
}
function isTypeReadonlyLoose(services, type) {
  if (isTypeReadonly(services.program, type)) return true;
  try {
    const im = getTypeImmutability(services.program, type);
    return isUnknown(im) || isImmutable(im) || isReadonlyShallow(im) || isReadonlyDeep(im);
  } catch {
    return true;
  }
}
var RULE_NAME56 = "prefer-shorthand-boolean";
var RULE_FEATURES55 = [
  "FIX"
];
var prefer_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces shorthand syntax for boolean attributes.",
      [Symbol.for("rule_features")]: RULE_FEATURES55
    },
    fixable: "code",
    messages: {
      preferShorthandBoolean: "Use shorthand boolean attribute '{{propName}}'."
    },
    schema: []
  },
  name: RULE_NAME56,
  create: create56,
  defaultOptions: []
});
function create56(context) {
  return {
    JSXAttribute(node) {
      const { value } = node;
      const propName = ER25.getAttributeName(context, node);
      const hasValueTrue = value?.type === AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === AST_NODE_TYPES.Literal && value.expression.value === true;
      if (!hasValueTrue) {
        return;
      }
      context.report({
        messageId: "preferShorthandBoolean",
        node: node.value ?? node,
        data: {
          propName
        },
        fix: (fixer) => fixer.removeRange([node.name.range[1], value.range[1]])
      });
    }
  };
}
var RULE_NAME57 = "prefer-shorthand-fragment";
var RULE_FEATURES56 = [
  "FIX"
];
var prefer_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "Enforces shorthand syntax for fragments.",
      [Symbol.for("rule_features")]: RULE_FEATURES56
    },
    fixable: "code",
    messages: {
      preferShorthandFragment: "Use fragment shorthand syntax instead of 'Fragment' component."
    },
    schema: []
  },
  name: RULE_NAME57,
  create: create57,
  defaultOptions: []
});
function create57(context) {
  return {
    JSXElement(node) {
      if (!ER25.isFragmentElement(context, node)) return;
      const hasAttributes = node.openingElement.attributes.length > 0;
      if (hasAttributes) {
        return;
      }
      context.report({
        messageId: "preferShorthandFragment",
        node,
        fix: (fixer) => {
          const { closingElement, openingElement } = node;
          if (closingElement == null) {
            return [];
          }
          return [
            fixer.replaceTextRange([openingElement.range[0], openingElement.range[1]], "<>"),
            fixer.replaceTextRange([closingElement.range[0], closingElement.range[1]], "</>")
          ];
        }
      });
    }
  };
}

// src/plugin.ts
var plugin = {
  meta: {
    name: name4,
    version
  },
  rules: {
    "avoid-shorthand-boolean": avoid_shorthand_boolean_default,
    "avoid-shorthand-fragment": avoid_shorthand_fragment_default,
    "no-access-state-in-setstate": no_access_state_in_setstate_default,
    "no-array-index-key": no_array_index_key_default,
    "no-children-count": no_children_count_default,
    "no-children-for-each": no_children_for_each_default,
    "no-children-map": no_children_map_default,
    "no-children-only": no_children_only_default,
    "no-children-prop": no_children_prop_default,
    "no-children-to-array": no_children_to_array_default,
    "no-class-component": no_class_component_default,
    "no-clone-element": no_clone_element_default,
    "no-comment-textnodes": no_comment_textnodes_default,
    "no-complex-conditional-rendering": no_complex_conditional_rendering_default,
    "no-component-will-mount": no_component_will_mount_default,
    "no-component-will-receive-props": no_component_will_receive_props_default,
    "no-component-will-update": no_component_will_update_default,
    "no-context-provider": no_context_provider_default,
    "no-create-ref": no_create_ref_default,
    "no-default-props": no_default_props_default,
    "no-direct-mutation-state": no_direct_mutation_state_default,
    "no-duplicate-key": no_duplicate_key_default,
    "no-forward-ref": no_forward_ref_default,
    "no-implicit-key": no_implicit_key_default,
    "no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
    "no-missing-component-display-name": no_missing_component_display_name_default,
    "no-missing-context-display-name": no_missing_context_display_name_default,
    "no-missing-key": no_missing_key_default,
    "no-misused-capture-owner-stack": no_misused_capture_owner_stack_default,
    "no-nested-component-definitions": no_nested_component_definitions_default,
    "no-nested-lazy-component-declarations": no_nested_lazy_component_declarations_default,
    "no-prop-types": no_prop_types_default,
    "no-redundant-should-component-update": no_redundant_should_component_update_default,
    "no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
    "no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
    "no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
    "no-string-refs": no_string_refs_default,
    "no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
    "no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
    "no-unsafe-component-will-update": no_unsafe_component_will_update_default,
    "no-unstable-context-value": no_unstable_context_value_default,
    "no-unstable-default-props": no_unstable_default_props_default,
    "no-unused-class-component-members": no_unused_class_component_members_default,
    "no-unused-state": no_unused_state_default,
    "no-use-context": no_use_context_default,
    "no-useless-forward-ref": no_useless_forward_ref_default,
    "no-useless-fragment": no_useless_fragment_default,
    "prefer-destructuring-assignment": prefer_destructuring_assignment_default,
    "prefer-react-namespace-import": prefer_react_namespace_import_default,
    "prefer-read-only-props": prefer_read_only_props_default,
    "prefer-shorthand-boolean": prefer_shorthand_boolean_default,
    "prefer-shorthand-fragment": prefer_shorthand_fragment_default,
    // Part: JSX only rules
    "jsx-key-before-spread": jsx_key_before_spread_default,
    "jsx-no-duplicate-props": jsx_no_duplicate_props_default,
    "jsx-no-undef": jsx_no_undef_default,
    "jsx-uses-react": jsx_uses_react_default,
    "jsx-uses-vars": jsx_uses_vars_default,
    // Part: deprecated rules
    /** @deprecated Use `no-useless-forward-ref` instead */
    "ensure-forward-ref-using-ref": no_useless_forward_ref_default,
    /** @deprecated Use `no-complex-conditional-rendering` instead */
    "no-complicated-conditional-rendering": no_complex_conditional_rendering_default,
    /** @deprecated Use `jsx-no-duplicate-props` instead */
    "no-duplicate-jsx-props": jsx_no_duplicate_props_default,
    /** @deprecated Use `no-nested-component-definitions` instead */
    "no-nested-components": no_nested_component_definitions_default,
    /** @deprecated Use `jsx-uses-vars` instead */
    "use-jsx-vars": jsx_uses_vars_default
  }
};

// src/index.ts
function makeConfig(config) {
  return {
    ...config,
    plugins: {
      "react-x": plugin
    }
  };
}
function makeLegacyConfig({ rules: rules4 }) {
  return {
    plugins: ["react-x"],
    rules: rules4
  };
}
var index_default = {
  ...plugin,
  configs: {
    ["recommended"]: makeConfig(recommended_exports),
    ["recommended-legacy"]: makeLegacyConfig(recommended_exports),
    ["recommended-type-checked"]: makeConfig(recommended_type_checked_exports),
    ["recommended-type-checked-legacy"]: makeLegacyConfig(recommended_type_checked_exports),
    ["recommended-typescript"]: makeConfig(recommended_typescript_exports),
    ["recommended-typescript-legacy"]: makeLegacyConfig(recommended_typescript_exports)
  }
};

export { index_default as default };
